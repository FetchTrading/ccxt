"use strict";const e=require("./base/Exchange"),{ExchangeError:t,ExchangeNotAvailable:i,OrderNotFound:s,AuthenticationError:r,InsufficientFunds:a,InvalidOrder:o,InvalidNonce:d}=require("./base/errors");module.exports=class extends e{describe(){return this.deepExtend(super.describe(),{id:"exmo",name:"EXMO",countries:["ES","RU"],rateLimit:350,version:"v1",has:{CORS:!1,fetchClosedOrders:"emulated",fetchDepositAddress:!0,fetchOpenOrders:!0,fetchOrder:"emulated",fetchOrders:"emulated",fetchOrderTrades:!0,fetchOrderBooks:!0,fetchMyTrades:!0,fetchTickers:!0,withdraw:!0},urls:{logo:"https://user-images.githubusercontent.com/1294454/27766491-1b0ea956-5eda-11e7-9225-40d67b481b8d.jpg",api:"https://api.exmo.com",www:"https://exmo.me",referral:"https://exmo.me/?ref=131685",doc:["https://exmo.me/en/api_doc?ref=131685","https://github.com/exmo-dev/exmo_api_lib/tree/master/nodejs"],fees:"https://exmo.com/en/docs/fees"},api:{public:{get:["currency","order_book","pair_settings","ticker","trades"]},private:{post:["user_info","order_create","order_cancel","user_open_orders","user_trades","user_cancelled_orders","order_trades","required_amount","deposit_address","withdraw_crypt","withdraw_get_txid","excode_create","excode_load","wallet_history"]}},fees:{trading:{maker:.002,taker:.002},funding:{withdraw:{BTC:.001,LTC:.01,DOGE:1,DASH:.01,ETH:.01,WAVES:.001,ZEC:.001,USDT:25,XMR:.05,XRP:.02,KICK:350,ETC:.01,BCH:.001},deposit:{USDT:15,KICK:50}}},exceptions:{40005:r,40009:d,40015:t,40016:i,40017:r,50052:a,50054:a,50304:s,50173:s,50319:o,50321:o}})}async fetchMarkets(){let e=await this.publicGetPairSettings(),t=Object.keys(e),i=[];for(let s=0;s<t.length;s++){let r=t[s],a=e[r],o=r.replace("_","/"),[d,n]=o.split("/");i.push({id:r,symbol:o,base:d,quote:n,active:!0,limits:{amount:{min:this.safeFloat(a,"min_quantity"),max:this.safeFloat(a,"max_quantity")},price:{min:this.safeFloat(a,"min_price"),max:this.safeFloat(a,"max_price")},cost:{min:this.safeFloat(a,"min_amount"),max:this.safeFloat(a,"max_amount")}},precision:{amount:8,price:8},info:a})}return i}async fetchBalance(e={}){await this.loadMarkets();let t=await this.privatePostUserInfo(),i={info:t},s=Object.keys(this.currencies);for(let e=0;e<s.length;e++){let r=s[e],a=this.account();r in t.balances&&(a.free=parseFloat(t.balances[r])),r in t.reserved&&(a.used=parseFloat(t.reserved[r])),a.total=this.sum(a.free,a.used),i[r]=a}return this.parseBalance(i)}async fetchOrderBook(e,t,i={}){await this.loadMarkets();let s=this.market(e),r=this.extend({pair:s.id},i);void 0!==t&&(r.limit=t);let a=(await this.publicGetOrderBook(r))[s.id];return this.parseOrderBook(a,void 0,"bid","ask")}async fetchOrderBooks(e,i={}){await this.loadMarkets();let s=void 0;if(e)s=(s=this.marketIds(e)).join(",");else if((s=this.ids.join(",")).length>2048){let e=this.ids.length;throw new t(this.id+" has "+e.toString()+" symbols exceeding max URL length, you are required to specify a list of symbols in the first argument to fetchOrderBooks")}let r=await this.publicGetOrderBook(this.extend({pair:s},i)),a={};s=Object.keys(r);for(let e=0;e<s.length;e++){let t=s[e];a[this.findSymbol(t)]=this.parseOrderBook(r[t],void 0,"bid","ask")}return a}parseTicker(e,t){let i=1e3*e.updated,s=void 0;t&&(s=t.symbol);const r=this.safeFloat(e,"last_trade");return{symbol:s,timestamp:i,datetime:this.iso8601(i),high:this.safeFloat(e,"high"),low:this.safeFloat(e,"low"),bid:this.safeFloat(e,"buy_price"),bidVolume:void 0,ask:this.safeFloat(e,"sell_price"),askVolume:void 0,vwap:void 0,open:void 0,close:r,last:r,previousClose:void 0,change:void 0,percentage:void 0,average:this.safeFloat(e,"avg"),baseVolume:this.safeFloat(e,"vol"),quoteVolume:this.safeFloat(e,"vol_curr"),info:e}}async fetchTickers(e,t={}){await this.loadMarkets();let i=await this.publicGetTicker(t),s={},r=Object.keys(i);for(let e=0;e<r.length;e++){let t=r[e],a=this.markets_by_id[t],o=a.symbol,d=i[t];s[o]=this.parseTicker(d,a)}return s}async fetchTicker(e,t={}){await this.loadMarkets();let i=await this.publicGetTicker(t),s=this.market(e);return this.parseTicker(i[s.id],s)}parseTrade(e,t){let i=1e3*e.date;return{id:e.trade_id.toString(),info:e,timestamp:i,datetime:this.iso8601(i),symbol:t.symbol,order:this.safeString(e,"order_id"),type:void 0,side:e.type,price:this.safeFloat(e,"price"),amount:this.safeFloat(e,"quantity"),cost:this.safeFloat(e,"amount")}}async fetchTrades(e,t,i,s={}){await this.loadMarkets();let r=this.market(e),a=await this.publicGetTrades(this.extend({pair:r.id},s));return this.parseTrades(a[r.id],r,t,i)}async fetchMyTrades(e,t,i,s={}){await this.loadMarkets();let r={},a=void 0;void 0!==e&&(a=this.market(e),r.pair=a.id);let o=await this.privatePostUserTrades(this.extend(r,s));return void 0!==a&&(o=o[a.id]),this.parseTrades(o,a,t,i)}async createOrder(e,t,i,s,r,a={}){await this.loadMarkets();let o="market"===t?t+"_":"",d=this.market(e);"market"===t&&void 0===r&&(r=0);let n={pair:d.id,quantity:this.amountToString(e,s),type:o+i,price:this.priceToPrecision(e,r)},h=await this.privatePostOrderCreate(this.extend(n,a)),l=this.safeString(h,"order_id"),c=this.milliseconds();s=parseFloat(s),r=parseFloat(r);let u={id:l,timestamp:c,datetime:this.iso8601(c),lastTradeTimestamp:void 0,status:"open",symbol:e,type:t,side:i,price:r,cost:r*s,amount:s,remaining:s,filled:0,fee:void 0,trades:void 0};return this.orders[l]=u,this.extend({info:h},u)}async cancelOrder(e,t,i={}){await this.loadMarkets();let s=await this.privatePostOrderCancel({order_id:e});return e in this.orders&&(this.orders[e].status="canceled"),s}async fetchOrder(e,t,i={}){await this.loadMarkets();try{let t=await this.privatePostOrderTrades({order_id:e.toString()});return this.parseOrder(t)}catch(t){if(t instanceof s&&e in this.orders)return this.orders[e]}throw new s(this.id+" fetchOrder order id "+e.toString()+" not found in cache.")}async fetchOrderTrades(e,t,i,s,r={}){let a=void 0;void 0!==t&&(a=this.market(t));let o=await this.privatePostOrderTrades({order_id:e.toString()});return this.parseTrades(o,a,i,s)}updateCachedOrders(e,t){for(let t=0;t<e.length;t++){const i=e[t].id;this.orders[i]=e[t]}let i=this.indexBy(e,"id"),s=Object.keys(this.orders);for(let e=0;e<s.length;e++){let r=s[e],a=this.orders[r];if(!(r in i)){if(void 0!==t&&t!==a.symbol)continue;"open"===a.status&&(void 0===(a=this.extend(a,{status:"closed",cost:void 0,filled:a.amount,remaining:0})).cost&&void 0!==a.filled&&(a.cost=a.filled*a.price),this.orders[r]=a)}}return this.toArray(this.orders)}async fetchOrders(e,t,i,s={}){await this.loadMarkets();let r=await this.privatePostUserOpenOrders(s),a=Object.keys(r),o=[];for(let e=0;e<a.length;e++){let t=a[e],i=void 0;t in this.markets_by_id&&(i=this.markets_by_id[t]);let s=this.parseOrders(r[t],i);o=this.arrayConcat(o,s)}return this.updateCachedOrders(o,e),this.filterBySymbolSinceLimit(this.toArray(this.orders),e,t,i)}async fetchOpenOrders(e,t,i,s={}){await this.fetchOrders(e,t,i,s);let r=this.filterBy(this.orders,"status","open");return this.filterBySymbolSinceLimit(r,e,t,i)}async fetchClosedOrders(e,t,i,s={}){await this.fetchOrders(e,t,i,s);let r=this.filterBy(this.orders,"status","closed");return this.filterBySymbolSinceLimit(r,e,t,i)}parseOrder(e,t){let i=this.safeString(e,"order_id"),s=this.safeInteger(e,"created");void 0!==s&&(s*=1e3);let r=void 0,a=void 0,o=this.safeString(e,"type");if(void 0===t){let i=void 0;"pair"in e?i=e.pair:"in_currency"in e&&"out_currency"in e&&(i="buy"===o?e.in_currency+"_"+e.out_currency:e.out_currency+"_"+e.in_currency),void 0!==i&&i in this.markets_by_id&&(t=this.markets_by_id[i])}let d=this.safeFloat(e,"quantity");if(void 0===d){let t="buy"===o?"in_amount":"out_amount";d=this.safeFloat(e,t)}let n=this.safeFloat(e,"price"),h=this.safeFloat(e,"amount"),l=0,c=[],u=this.safeValue(e,"trades"),p=void 0;if(void 0!==u&&Array.isArray(u))for(let e=0;e<u.length;e++){let r=this.parseTrade(u[e],t);void 0===i&&(i=r.order),void 0===s&&(s=r.timestamp),s>r.timestamp&&(s=r.timestamp),l+=r.amount,void 0===p&&(p=0),void 0===h&&(h=0),h+=r.cost,c.push(r)}void 0!==s&&(r=this.iso8601(s));let m=void 0;void 0!==d&&(m=d-l);let f=this.safeString(e,"status");f=l>=d?"closed":"open",void 0===t&&(t=this.getMarketFromTrades(c));let y=void 0;return void 0!==t&&(a=t.symbol,y=t.quote),void 0===h?void 0!==n&&(h=n*l):void 0===n&&l>0&&(n=h/l),{id:i,datetime:r,timestamp:s,lastTradeTimestamp:void 0,status:f,symbol:a,type:"limit",side:o,price:n,cost:h,amount:d,filled:l,remaining:m,trades:c,fee:{cost:p,currency:y},info:e}}async fetchDepositAddress(e,t={}){await this.loadMarkets();let i=await this.privatePostDepositAddress(t),s=this.safeString(i,e),r=void 0,a=void 0;if(s){let e=s.split(",");r=e[0],e.length>1&&(a=e[1])}return this.checkAddress(r),{currency:e,address:r,tag:a,status:"ok",info:i}}getMarketFromTrades(e){let t=this.indexBy(e,"pair"),i=Object.keys(t);if(1===i.length)return this.markets[i[0]]}calculateFee(e,t,i,s,r,a="taker",o={}){let d=this.markets[e],n=d[a],h=parseFloat(this.costToPrecision(e,s*n)),l="quote";return"sell"===i?h*=r:l="base",{type:a,currency:d[l],rate:n,cost:parseFloat(this.feeToPrecision(e,h))}}async withdraw(e,t,i,s,r={}){await this.loadMarkets();let a={amount:t,currency:e,address:i};void 0!==s&&(a.invoice=s);let o=await this.privatePostWithdrawCrypt(this.extend(a,r));return{info:o,id:o.task_id}}sign(e,t="public",i="GET",s={},r,a){let o=this.urls.api+"/"+this.version+"/"+e;if("public"===t)Object.keys(s).length&&(o+="?"+this.urlencode(s));else{this.checkRequiredCredentials();let e=this.nonce();a=this.urlencode(this.extend({nonce:e},s)),r={"Content-Type":"application/x-www-form-urlencoded",Key:this.apiKey,Sign:this.hmac(this.encode(a),this.encode(this.secret),"sha512")}}return{url:o,method:i,body:a,headers:r}}nonce(){return this.milliseconds()}handleErrors(e,i,s,r,a,o){if("string"==typeof o&&!(o.length<2||"{"!==o[0]&&"["!==o[0])){let e=JSON.parse(o);if("result"in e){let i=this.safeValue(e,"result",!1);if("string"==typeof i&&(i="true"===i||"1"===i),!i){let i=void 0;const s=this.safeString(e,"error").split(":");if(s.length>1){const e=s[0].split(" ");i=e.length>1?e[1]:e[0]}const r=this.id+" "+this.json(e),a=this.exceptions;throw i in a?new a[i](r):new t(r)}}}}};
//# sourceMappingURL=exmo.js.map
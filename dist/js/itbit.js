"use strict";const e=require("./base/Exchange"),{ExchangeError:t}=require("./base/errors"),{AuthenticationError:s}=require("./base/errors");module.exports=class extends e{describe(){return this.deepExtend(super.describe(),{id:"itbit",name:"itBit",countries:"US",rateLimit:2e3,version:"v1",has:{CORS:!0,createMarketOrder:!1},urls:{logo:"https://user-images.githubusercontent.com/1294454/27822159-66153620-60ad-11e7-89e7-005f6d7f3de0.jpg",api:"https://api.itbit.com",www:"https://www.itbit.com",doc:["https://api.itbit.com/docs","https://www.itbit.com/api"]},api:{public:{get:["markets/{symbol}/ticker","markets/{symbol}/order_book","markets/{symbol}/trades"]},private:{get:["wallets","wallets/{walletId}","wallets/{walletId}/balances/{currencyCode}","wallets/{walletId}/funding_history","wallets/{walletId}/trades","wallets/{walletId}/orders","wallets/{walletId}/orders/{id}"],post:["wallet_transfers","wallets","wallets/{walletId}/cryptocurrency_deposits","wallets/{walletId}/cryptocurrency_withdrawals","wallets/{walletId}/orders","wire_withdrawal"],delete:["wallets/{walletId}/orders/{id}"]}},markets:{"BTC/USD":{id:"XBTUSD",symbol:"BTC/USD",base:"BTC",quote:"USD"},"BTC/SGD":{id:"XBTSGD",symbol:"BTC/SGD",base:"BTC",quote:"SGD"},"BTC/EUR":{id:"XBTEUR",symbol:"BTC/EUR",base:"BTC",quote:"EUR"}},fees:{trading:{maker:0,taker:.002}}})}async fetchOrderBook(e,t,s={}){let i=await this.publicGetMarketsSymbolOrderBook(this.extend({symbol:this.marketId(e)},s));return this.parseOrderBook(i)}async fetchTicker(e,s={}){let i=await this.publicGetMarketsSymbolTicker(this.extend({symbol:this.marketId(e)},s));if(!("serverTimeUTC"in i))throw new t(this.id+" fetchTicker returned a bad response: "+this.json(i));let a=this.parse8601(i.serverTimeUTC),r=this.safeFloat(i,"vwap24h"),l=this.safeFloat(i,"volume24h"),d=void 0;void 0!==l&&void 0!==r&&(d=l*r);let o=this.safeFloat(i,"lastPrice");return{symbol:e,timestamp:a,datetime:this.iso8601(a),high:this.safeFloat(i,"high24h"),low:this.safeFloat(i,"low24h"),bid:this.safeFloat(i,"bid"),bidVolume:void 0,ask:this.safeFloat(i,"ask"),askVolume:void 0,vwap:r,open:this.safeFloat(i,"openToday"),close:o,last:o,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:l,quoteVolume:d,info:i}}parseTrade(e,t){let s=this.parse8601(e.timestamp),i=e.matchNumber.toString();return{info:e,timestamp:s,datetime:this.iso8601(s),symbol:t.symbol,id:i,order:i,type:void 0,side:void 0,price:this.safeFloat(e,"price"),amount:this.safeFloat(e,"amount")}}async fetchTrades(e,t,s,i={}){let a=this.market(e),r=await this.publicGetMarketsSymbolTrades(this.extend({symbol:a.id},i));return this.parseTrades(r.recentTrades,a,t,s)}async fetchBalance(e={}){let t=await this.fetchWallets(),s=t[0].balances,i={info:t};for(let e=0;e<s.length;e++){let t=s[e],a=t.currency,r={free:parseFloat(t.availableBalance),used:0,total:parseFloat(t.totalBalance)};r.used=r.total-r.free,i[a]=r}return this.parseBalance(i)}async fetchWallets(){if(!this.userId)throw new s(this.id+" fetchWallets requires userId in API settings");let e={userId:this.userId};return this.privateGetWallets(e)}async fetchWallet(e,t={}){let s={walletId:e};return this.privateGetWalletsWalletId(this.extend(s,t))}async fetchOpenOrders(e,t,s,i={}){return this.fetchOrders(e,t,s,this.extend({status:"open"},i))}async fetchClosedOrders(e,t,s,i={}){return this.fetchOrders(e,t,s,this.extend({status:"filled"},i))}async fetchOrders(e,s,i,a={}){if(!("walletId"in a))throw new t(this.id+" fetchOrders requires a walletId parameter");let r=a.walletId,l=await this.privateGetWalletsWalletIdOrders(this.extend({walletId:r},a));return this.parseOrders(l,void 0,s,i)}parseOrder(e,t){let s=e.side,i=e.type,a=this.markets_by_id[e.instrument].symbol,r=this.parse8601(e.createdTime),l=this.safeFloat(e,"amount"),d=this.safeFloat(e,"amountFilled"),o=l-d,h=this.safeFloat(e,"price"),n=h*this.safeFloat(e,"volumeWeightedAveragePrice");return{id:e.id,info:e,timestamp:r,datetime:this.iso8601(r),lastTradeTimestamp:void 0,status:e.status,symbol:a,type:i,side:s,price:h,cost:n,amount:l,filled:d,remaining:o,fee:void 0}}nonce(){return this.milliseconds()}async createOrder(e,s,i,a,r,l={}){if("market"===s)throw new t(this.id+" allows limit orders only");if(!("walletId"in l))throw new t(this.id+" createOrder requires a walletId parameter");a=a.toString(),r=r.toString();let d=this.market(e),o={side:i,type:s,currency:d.id.replace(d.quote,""),amount:a,display:a,price:r,instrument:d.id},h=await this.privatePostWalletsWalletIdOrders(this.extend(o,l));return{info:h,id:h.id}}async fetchOrder(e,s,i={}){if(!("walletId"in i))throw new t(this.id+" fetchOrder requires a walletId parameter");return await this.privateGetWalletsWalletIdOrdersId(this.extend({id:e},i))}async cancelOrder(e,s,i={}){if(!("walletId"in i))throw new t(this.id+" cancelOrder requires a walletId parameter");return await this.privateDeleteWalletsWalletIdOrdersId(this.extend({id:e},i))}sign(e,t="public",s="GET",i={},a,r){let l=this.urls.api+"/"+this.version+"/"+this.implodeParams(e,i),d=this.omit(i,this.extractParams(e));if("GET"===s&&Object.keys(d).length&&(l+="?"+this.urlencode(d)),r="POST"===s&&Object.keys(d).length?this.json(d):"","private"===t){this.checkRequiredCredentials();let e=this.nonce().toString(),t=e,i=[s,l,r,e,t],d=e+this.json(i).replace("\\/","/"),o=this.hash(this.encode(d),"sha256","binary"),h=this.binaryConcat(l,o),n=this.hmac(h,this.encode(this.secret),"sha512","base64");a={Authorization:this.apiKey+":"+n,"Content-Type":"application/json","X-Auth-Timestamp":t,"X-Auth-Nonce":e}}return{url:l,method:s,body:r,headers:a}}async request(e,s="public",i="GET",a={},r,l){let d=await this.fetch2(e,s,i,a,r,l);if("code"in d)throw new t(this.id+" "+this.json(d));return d}};
//# sourceMappingURL=itbit.js.map
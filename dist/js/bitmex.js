"use strict";const e=require("./base/Exchange"),{ExchangeError:t,DDoSProtection:i,OrderNotFound:s,AuthenticationError:r,PermissionDenied:a}=require("./base/errors");module.exports=class extends e{describe(){return this.deepExtend(super.describe(),{id:"bitmex",name:"BitMEX",countries:"SC",version:"v1",userAgent:void 0,rateLimit:2e3,has:{CORS:!1,fetchOHLCV:!0,withdraw:!0,editOrder:!0,fetchOrder:!0,fetchOrders:!0,fetchOpenOrders:!0,fetchClosedOrders:!0},timeframes:{"1m":"1m","5m":"5m","1h":"1h","1d":"1d"},urls:{test:"https://testnet.bitmex.com",logo:"https://user-images.githubusercontent.com/1294454/27766319-f653c6e6-5ed4-11e7-933d-f0bc3699ae8f.jpg",api:"https://www.bitmex.com",www:"https://www.bitmex.com",doc:["https://www.bitmex.com/app/apiOverview","https://github.com/BitMEX/api-connectors/tree/master/official-http"],fees:"https://www.bitmex.com/app/fees"},api:{public:{get:["announcement","announcement/urgent","funding","instrument","instrument/active","instrument/activeAndIndices","instrument/activeIntervals","instrument/compositeIndex","instrument/indices","insurance","leaderboard","liquidation","orderBook","orderBook/L2","quote","quote/bucketed","schema","schema/websocketHelp","settlement","stats","stats/history","trade","trade/bucketed"]},private:{get:["apiKey","chat","chat/channels","chat/connected","execution","execution/tradeHistory","notification","order","position","user","user/affiliateStatus","user/checkReferralCode","user/commission","user/depositAddress","user/margin","user/minWithdrawalFee","user/wallet","user/walletHistory","user/walletSummary"],post:["apiKey","apiKey/disable","apiKey/enable","chat","order","order/bulk","order/cancelAllAfter","order/closePosition","position/isolate","position/leverage","position/riskLimit","position/transferMargin","user/cancelWithdrawal","user/confirmEmail","user/confirmEnableTFA","user/confirmWithdrawal","user/disableTFA","user/logout","user/logoutAll","user/preferences","user/requestEnableTFA","user/requestWithdrawal"],put:["order","order/bulk","user"],delete:["apiKey","order","order/all"]}},exceptions:{"Invalid API Key.":r,"Access Denied":a},options:{fetchTickerQuotes:!0}})}async fetchMarkets(){let e=await this.publicGetInstrumentActiveAndIndices(),t=[];for(let i=0;i<e.length;i++){let s=e[i],r="Unlisted"!==s.state,a=s.symbol,o=s.underlying,n=s.quoteCurrency,d=void 0,l=!1,h=!1,c=o+n;o=this.commonCurrencyCode(o),n=this.commonCurrencyCode(n);let u=a===c,m=a;u?(d="swap",m=o+"/"+n):a.indexOf("B_")>=0?(h=!0,d="prediction"):(l=!0,d="future");let p={amount:void 0,price:void 0};s.lotSize&&(p.amount=this.precisionFromString(this.truncate_to_string(s.lotSize,16))),s.tickSize&&(p.price=this.precisionFromString(this.truncate_to_string(s.tickSize,16))),t.push({id:a,symbol:m,base:o,quote:n,active:r,precision:p,limits:{amount:{min:s.lotSize,max:s.maxOrderQty},price:{min:s.tickSize,max:s.maxPrice}},taker:s.takerFee,maker:s.makerFee,type:d,spot:!1,swap:u,future:l,prediction:h,info:s})}return t}async fetchBalance(e={}){await this.loadMarkets();let t=await this.privateGetUserMargin({currency:"all"}),i={info:t};for(let e=0;e<t.length;e++){let s=t[e],r=s.currency.toUpperCase();r=this.commonCurrencyCode(r);let a={free:s.availableMargin,used:0,total:s.marginBalance};"BTC"===r&&(a.free=1e-8*a.free,a.total=1e-8*a.total),a.used=a.total-a.free,i[r]=a}return this.parseBalance(i)}async fetchOrderBook(e,t,i={}){await this.loadMarkets();let s={symbol:this.market(e).id};void 0!==t&&(s.depth=t);let r=await this.publicGetOrderBookL2(this.extend(s,i)),a={bids:[],asks:[],timestamp:void 0,datetime:void 0,nonce:void 0};for(let e=0;e<r.length;e++){let t=r[e],i="Sell"===t.side?"asks":"bids",s=t.size,o=t.price;a[i].push([o,s])}return a.bids=this.sortBy(a.bids,0,!0),a.asks=this.sortBy(a.asks,0),a}async fetchOrder(e,t,i={}){let r={filter:{orderID:e}},a=await this.fetchOrders(t,void 0,void 0,this.deepExtend(r,i));if(1===a.length)return a[0];throw new s(this.id+": The order "+e+" not found.")}async fetchOrders(e,t,i,s={}){await this.loadMarkets();let r=void 0,a={};void 0!==e&&(r=this.market(e),a.symbol=r.id),void 0!==t&&(a.startTime=this.iso8601(t)),void 0!==i&&(a.count=i),"filter"in(a=this.deepExtend(a,s))&&(a.filter=this.json(a.filter));let o=await this.privateGetOrder(a);return this.parseOrders(o,r,t,i)}async fetchOpenOrders(e,t,i,s={}){return await this.fetchOrders(e,t,i,this.deepExtend({filter:{open:!0}},s))}async fetchClosedOrders(e,t,i,s={}){let r=await this.fetchOrders(e,t,i,s);return this.filterBy(r,"status","closed")}async fetchTicker(e,i={}){await this.loadMarkets();let s=this.market(e);if(!s.active)throw new t(this.id+": symbol "+e+" is delisted");let r=this.extend({symbol:s.id,binSize:"1d",partial:!0,count:1,reverse:!0},i),a=void 0,o=void 0;if(this.options.fetchTickerQuotes){let e=await this.publicGetQuoteBucketed(r),t=e[e.length-1];a=this.safeFloat(t,"bidPrice"),o=this.safeFloat(t,"askPrice")}let n=(await this.publicGetTradeBucketed(r))[0],d=this.milliseconds(),l=this.safeFloat(n,"open"),h=this.safeFloat(n,"close"),c=h-l;return{symbol:e,timestamp:d,datetime:this.iso8601(d),high:this.safeFloat(n,"high"),low:this.safeFloat(n,"low"),bid:a,bidVolume:void 0,ask:o,askVolume:void 0,vwap:this.safeFloat(n,"vwap"),open:l,close:h,last:h,previousClose:void 0,change:c,percentage:c/l*100,average:this.sum(l,h)/2,baseVolume:this.safeFloat(n,"homeNotional"),quoteVolume:this.safeFloat(n,"foreignNotional"),info:n}}parseOHLCV(e,t,i="1m",s,r){return[this.parse8601(e.timestamp)-1e3*this.parseTimeframe(i),e.open,e.high,e.low,e.close,e.volume]}async fetchOHLCV(e,t="1m",i,s,r={}){await this.loadMarkets();let a=this.market(e),o={symbol:a.id,binSize:this.timeframes[t],partial:!0};if(void 0!==s&&(o.count=s),void 0!==i){let e=this.ymdhms(i).slice(0,16);o.startTime=e}let n=await this.publicGetTradeBucketed(this.extend(o,r));return this.parseOHLCVs(n,a,t,i,s)}parseTrade(e,t){let i=this.parse8601(e.timestamp),s=void 0;return t||"symbol"in e&&(t=this.markets_by_id[e.symbol]),t&&(s=t.symbol),{id:e.trdMatchID,info:e,timestamp:i,datetime:this.iso8601(i),symbol:s,order:void 0,type:void 0,side:e.side.toLowerCase(),price:e.price,amount:e.size}}parseOrderStatus(e){return this.safeString({new:"open",partiallyfilled:"open",filled:"closed",canceled:"canceled",rejected:"rejected",expired:"expired"},e.toLowerCase())}parseOrder(e,t){let i=this.safeValue(e,"ordStatus");void 0!==i&&(i=this.parseOrderStatus(i));let s=void 0;if(t)s=t.symbol;else{let i=e.symbol;i in this.markets_by_id&&(s=(t=this.markets_by_id[i]).symbol)}let r=void 0,a=void 0,o=void 0;"timestamp"in e?r=e.timestamp:"transactTime"in e&&(r=e.transactTime),void 0!==r&&(a=this.parse8601(r),o=this.iso8601(a));let n=this.safeFloat(e,"price"),d=this.safeFloat(e,"orderQty"),l=this.safeFloat(e,"cumQty",0),h=Math.max(d-l,0),c=void 0;return void 0!==n&&void 0!==l&&(c=n*l),{info:e,id:e.orderID.toString(),timestamp:a,datetime:o,lastTradeTimestamp:void 0,symbol:s,type:e.ordType.toLowerCase(),side:e.side.toLowerCase(),price:n,amount:d,cost:c,filled:l,remaining:h,status:i,fee:void 0}}async fetchTrades(e,t,i,s={}){await this.loadMarkets();let r=this.market(e),a={symbol:r.id};void 0!==t&&(a.startTime=this.iso8601(t)),void 0!==i&&(a.count=i);let o=await this.publicGetTrade(this.extend(a,s));return this.parseTrades(o,r)}async createOrder(e,t,i,s,r,a={}){await this.loadMarkets();let o={symbol:this.marketId(e),side:this.capitalize(i),orderQty:s,ordType:this.capitalize(t)};void 0!==r&&(o.price=r);let n=await this.privatePostOrder(this.extend(o,a)),d=this.parseOrder(n),l=d.id;return this.orders[l]=d,this.extend({info:n},d)}async editOrder(e,t,i,s,r,a,o={}){await this.loadMarkets();let n={orderID:e};void 0!==r&&(n.orderQty=r),void 0!==a&&(n.price=a);let d=await this.privatePutOrder(this.extend(n,o)),l=this.parseOrder(d);return this.orders[l.id]=l,this.extend({info:d},l)}async cancelOrder(e,t,i={}){await this.loadMarkets();let r=await this.privateDeleteOrder(this.extend({orderID:e},i)),a=r[0],o=this.safeString(a,"error");if(void 0!==o&&o.indexOf("Unable to cancel order due to existing state")>=0)throw new s(this.id+" cancelOrder() failed: "+o);return a=this.parseOrder(a),this.orders[a.id]=a,this.extend({info:r},a)}isFiat(e){return"EUR"===e||"PLN"===e}async withdraw(e,i,s,r,a={}){if(this.checkAddress(s),await this.loadMarkets(),"BTC"!==e)throw new t(this.id+" supoprts BTC withdrawals only, other currencies coming soon...");let o={currency:"XBt",amount:i,address:s},n=await this.privatePostUserRequestWithdrawal(this.extend(o,a));return{info:n,id:n.transactID}}handleErrors(e,s,r,a,o,n){if(429===e)throw new i(this.id+" "+n);if(e>=400&&n&&"{"===n[0]){let e=JSON.parse(n);if("error"in e&&"message"in e.error){let i=this.id+" "+this.json(e),s=this.safeValue(e.error,"message"),r=this.exceptions;if(void 0!==s&&s in r)throw new r[s](i);throw new t(i)}}}nonce(){return this.milliseconds()}sign(e,t="public",i="GET",s={},r,a){let o="/api/"+this.version+"/"+e;"PUT"!==i&&Object.keys(s).length&&(o+="?"+this.urlencode(s));let n=this.urls.api+o;if("private"===t){this.checkRequiredCredentials();let e=this.nonce().toString(),t=i+o+e;"POST"!==i&&"PUT"!==i||Object.keys(s).length&&(t+=a=this.json(s)),r={"Content-Type":"application/json","api-nonce":e,"api-key":this.apiKey,"api-signature":this.hmac(this.encode(t),this.encode(this.secret))}}return{url:n,method:i,body:a,headers:r}}};
//# sourceMappingURL=bitmex.js.map
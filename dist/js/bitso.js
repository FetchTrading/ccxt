"use strict";const t=require("./base/Exchange"),{ExchangeError:e,InvalidNonce:i,AuthenticationError:a,OrderNotFound:s}=require("./base/errors");module.exports=class extends t{describe(){return this.deepExtend(super.describe(),{id:"bitso",name:"Bitso",countries:"MX",rateLimit:2e3,version:"v3",has:{CORS:!0,fetchMyTrades:!0,fetchOpenOrders:!0},urls:{logo:"https://user-images.githubusercontent.com/1294454/27766335-715ce7aa-5ed5-11e7-88a8-173a27bb30fe.jpg",api:"https://api.bitso.com",www:"https://bitso.com",doc:"https://bitso.com/api_info",fees:"https://bitso.com/fees?l=es"},api:{public:{get:["available_books","ticker","order_book","trades"]},private:{get:["account_status","balance","fees","fundings","fundings/{fid}","funding_destination","kyc_documents","ledger","ledger/trades","ledger/fees","ledger/fundings","ledger/withdrawals","mx_bank_codes","open_orders","order_trades/{oid}","orders/{oid}","user_trades","user_trades/{tid}","withdrawals/","withdrawals/{wid}"],post:["bitcoin_withdrawal","debit_card_withdrawal","ether_withdrawal","ripple_withdrawal","bcash_withdrawal","litecoin_withdrawal","orders","phone_number","phone_verification","phone_withdrawal","spei_withdrawal","ripple_withdrawal","bcash_withdrawal","litecoin_withdrawal"],delete:["orders/{oid}","orders/all"]}},exceptions:{"0201":a,104:i}})}async fetchMarkets(){let t=await this.publicGetAvailableBooks(),e=[];for(let i=0;i<t.payload.length;i++){let a=t.payload[i],s=a.book,r=s.toUpperCase().replace("_","/"),[o,d]=r.split("/"),n={amount:{min:this.safeFloat(a,"minimum_amount"),max:this.safeFloat(a,"maximum_amount")},price:{min:this.safeFloat(a,"minimum_price"),max:this.safeFloat(a,"maximum_price")},cost:{min:this.safeFloat(a,"minimum_value"),max:this.safeFloat(a,"maximum_value")}},h={amount:this.precisionFromString(a.minimum_amount),price:this.precisionFromString(a.minimum_price)},l=n.amount.min;e.push({id:s,symbol:r,base:o,quote:d,info:a,lot:l,limits:n,precision:h})}return e}async fetchBalance(t={}){await this.loadMarkets();let e=await this.privateGetBalance(),i=e.payload.balances,a={info:e};for(let t=0;t<i.length;t++){let e=i[t],s=e.currency.toUpperCase(),r={free:parseFloat(e.available),used:parseFloat(e.locked),total:parseFloat(e.total)};a[s]=r}return this.parseBalance(a)}async fetchOrderBook(t,e,i={}){await this.loadMarkets();let a=(await this.publicGetOrderBook(this.extend({book:this.marketId(t)},i))).payload,s=this.parse8601(a.updated_at);return this.parseOrderBook(a,s,"bids","asks","price","amount")}async fetchTicker(t,e={}){await this.loadMarkets();let i=(await this.publicGetTicker(this.extend({book:this.marketId(t)},e))).payload,a=this.parse8601(i.created_at),s=this.safeFloat(i,"vwap"),r=this.safeFloat(i,"volume"),o=r*s,d=this.safeFloat(i,"last");return{symbol:t,timestamp:a,datetime:this.iso8601(a),high:this.safeFloat(i,"high"),low:this.safeFloat(i,"low"),bid:this.safeFloat(i,"bid"),bidVolume:void 0,ask:this.safeFloat(i,"ask"),askVolume:void 0,vwap:s,open:void 0,close:d,last:d,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:r,quoteVolume:o,info:i}}parseTrade(t,e){let i=this.parse8601(t.created_at),a=void 0;if(void 0===e){let i=this.safeString(t,"book");i in this.markets_by_id&&(e=this.markets_by_id[i])}void 0!==e&&(a=e.symbol);let s=this.safeString(t,"side");void 0===s&&(s=this.safeString(t,"maker_side"));let r=this.safeFloat(t,"amount");void 0===r&&(r=this.safeFloat(t,"major")),void 0!==r&&(r=Math.abs(r));let o=void 0,d=this.safeFloat(t,"fees_amount");if(void 0!==d){let e=this.safeString(t,"fees_currency");void 0!==e&&e in this.currencies_by_id&&(e=this.currencies_by_id[e].code),o={cost:d,currency:e}}let n=this.safeFloat(t,"minor");void 0!==n&&(n=Math.abs(n));let h=this.safeFloat(t,"price"),l=this.safeString(t,"oid");return{id:t.tid.toString(),info:t,timestamp:i,datetime:this.iso8601(i),symbol:a,order:l,type:void 0,side:s,price:h,amount:r,cost:n,fee:o}}async fetchTrades(t,e,i,a={}){await this.loadMarkets();let s=this.market(t),r=await this.publicGetTrades(this.extend({book:s.id},a));return this.parseTrades(r.payload,s,e,i)}async fetchMyTrades(t,i,a=25,s={}){await this.loadMarkets();let r=this.market(t),o="marker"in s;if(void 0!==i&&!o)throw e(this.id+" fetchMyTrades does not support fetching trades starting from a timestamp with the `since` argument, use the `marker` extra param to filter starting from an integer trade id");o&&(s=this.extend(s,{marker:parseInt(s.marker)}));let d={book:r.id,limit:a},n=await this.privateGetUserTrades(this.extend(d,s));return this.parseTrades(n.payload,r,i,a)}async createOrder(t,e,i,a,s,r={}){await this.loadMarkets();let o={book:this.marketId(t),side:i,type:e,major:this.amountToPrecision(t,a)};"limit"===e&&(o.price=this.priceToPrecision(t,s));let d=await this.privatePostOrders(this.extend(o,r));return{info:d,id:d.payload.oid}}async cancelOrder(t,e,i={}){return await this.loadMarkets(),await this.privateDeleteOrdersOid({oid:t})}parseOrderStatus(t){let e={"partial-fill":"open",completed:"closed"};return t in e?e[t]:t}parseOrder(t,e){let i=t.side,a=this.parseOrderStatus(t.status),s=void 0;if(void 0===e){let i=t.book;i in this.markets_by_id&&(e=this.markets_by_id[i])}e&&(s=e.symbol);let r=t.type,o=this.parse8601(t.created_at),d=this.safeFloat(t,"original_amount"),n=this.safeFloat(t,"unfilled_amount"),h=d-n;return{info:t,id:t.oid,timestamp:o,datetime:this.iso8601(o),lastTradeTimestamp:void 0,symbol:s,type:r,side:i,price:this.safeFloat(t,"price"),amount:d,cost:void 0,remaining:n,filled:h,status:a,fee:void 0}}async fetchOpenOrders(t,i,a=25,s={}){await this.loadMarkets();let r=this.market(t),o="marker"in s;if(void 0!==i&&!o)throw e(this.id+" fetchOpenOrders does not support fetching orders starting from a timestamp with the `since` argument, use the `marker` extra param to filter starting from an integer trade id");o&&(s=this.extend(s,{marker:parseInt(s.marker)}));let d={book:r.id,limit:a},n=await this.privateGetOpenOrders(this.extend(d,s));return this.parseOrders(n.payload,r,i,a)}async fetchOrder(t,e,i={}){await this.loadMarkets();let a=this.market(e),r=await this.privateGetOrdersOid({oid:t}),o=r.payload.length;if(!Array.isArray(r.payload)||1!==o)throw new s(this.id+": The order "+t+" not found.");return this.parseOrder(r.payload[0],a)}async fetchOrderTrades(t,e,i={}){await this.loadMarkets();let a=this.market(e),s=await this.privateGetOrderTradesOid({oid:t});return this.parseTrades(s.payload,a)}async fetchDepositAddress(t,e={}){await this.loadMarkets();let i={fund_currency:this.currency(t).id},a=await this.privateGetFundingDestination(this.extend(i,e)),s=this.safeString(a.payload,"account_identifier"),r=void 0;if("XRP"===t){let t=s.split("?dt=",2);s=t[0],r=t[1]}return this.checkAddress(s),{currency:t,address:s,tag:r,status:"ok",info:a}}async withdraw(t,i,a,s,r={}){this.checkAddress(a),await this.loadMarkets();let o={BTC:"Bitcoin",ETH:"Ether",XRP:"Ripple",BCH:"Bcash",LTC:"Litecoin"},d=t in o?o[t]:void 0;if(void 0===d)throw new e(this.id+" not valid withdraw coin: "+t);let n={amount:i,address:a,destination_tag:s},h="privatePost"+d+"Withdrawal",l=await this[h](this.extend(n,r));return{info:l,id:this.safeString(l.payload,"wid")}}sign(t,e="public",i="GET",a={},s,r){let o="/"+this.version+"/"+this.implodeParams(t,a),d=this.omit(a,this.extractParams(t));"GET"===i&&Object.keys(d).length&&(o+="?"+this.urlencode(d));let n=this.urls.api+o;if("private"===e){this.checkRequiredCredentials();let t=this.nonce().toString(),e=[t,i,o].join("");"GET"!==i&&Object.keys(d).length&&(e+=r=this.json(d));let a=this.hmac(this.encode(e),this.encode(this.secret));s={Authorization:"Bitso "+(this.apiKey+":"+t+":"+a),"Content-Type":"application/json"}}return{url:n,method:i,body:r,headers:s}}handleErrors(t,i,a,s,r,o){if("string"==typeof o&&!(o.length<2||"{"!==o[0]&&"["!==o[0])){let t=JSON.parse(o);if("success"in t){let i=this.safeValue(t,"success",!1);if("string"==typeof i&&(i="true"===i||"1"===i),!i){const i=this.id+" "+this.json(t),a=this.safeValue(t,"error");if(void 0===a)throw new e(i);const s=this.safeString(a,"code"),r=this.exceptions;throw s in r?new r[s](i):new e(i)}}}}async request(t,i="public",a="GET",s={},r,o){let d=await this.fetch2(t,i,a,s,r,o);if("success"in d&&d.success)return d;throw new e(this.id+" "+this.json(d))}};
//# sourceMappingURL=bitso.js.map
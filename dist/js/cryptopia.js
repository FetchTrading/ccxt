"use strict";const e=require("./base/Exchange"),{ExchangeError:t,InsufficientFunds:i,OrderNotFound:s,OrderNotCached:r,InvalidNonce:a}=require("./base/errors");module.exports=class extends e{describe(){return this.deepExtend(super.describe(),{id:"cryptopia",name:"Cryptopia",rateLimit:1500,countries:"NZ",has:{CORS:!1,createMarketOrder:!1,fetchClosedOrders:"emulated",fetchCurrencies:!0,fetchDepositAddress:!0,fetchMyTrades:!0,fetchOHLCV:!0,fetchOrder:"emulated",fetchOrderBooks:!0,fetchOrders:"emulated",fetchOpenOrders:!0,fetchTickers:!0,deposit:!0,withdraw:!0},urls:{logo:"https://user-images.githubusercontent.com/1294454/29484394-7b4ea6e2-84c6-11e7-83e5-1fccf4b2dc81.jpg",api:{public:"https://www.cryptopia.co.nz/api",private:"https://www.cryptopia.co.nz/api",web:"https://www.cryptopia.co.nz"},www:"https://www.cryptopia.co.nz",referral:"https://www.cryptopia.co.nz/Register?referrer=kroitor",doc:["https://www.cryptopia.co.nz/Forum/Category/45","https://www.cryptopia.co.nz/Forum/Thread/255","https://www.cryptopia.co.nz/Forum/Thread/256"]},timeframes:{"15m":15,"30m":30,"1h":60,"2h":120,"4h":240,"12h":720,"1d":1440,"1w":10080},api:{web:{get:["Exchange/GetTradePairChart"]},public:{get:["GetCurrencies","GetTradePairs","GetMarkets","GetMarkets/{id}","GetMarkets/{hours}","GetMarkets/{id}/{hours}","GetMarket/{id}","GetMarket/{id}/{hours}","GetMarketHistory/{id}","GetMarketHistory/{id}/{hours}","GetMarketOrders/{id}","GetMarketOrders/{id}/{count}","GetMarketOrderGroups/{ids}","GetMarketOrderGroups/{ids}/{count}"]},private:{post:["CancelTrade","GetBalance","GetDepositAddress","GetOpenOrders","GetTradeHistory","GetTransactions","SubmitTip","SubmitTrade","SubmitTransfer","SubmitWithdraw"]}},commonCurrencies:{ACC:"AdCoin",BAT:"BatCoin",BLZ:"BlazeCoin",BTG:"Bitgem",CC:"CCX",CMT:"Comet",EPC:"ExperienceCoin",FCN:"Facilecoin",FUEL:"FC2",HAV:"Havecoin",LBTC:"LiteBitcoin",LDC:"LADACoin",MARKS:"Bitmark",NET:"NetCoin",QBT:"Cubits",WRC:"WarCoin"},options:{fetchTickersErrors:!0}})}async fetchMarkets(){let e=[],t=(await this.publicGetGetTradePairs()).Data;for(let i=0;i<t.length;i++){let s=t[i],r=s.Id,a=s.Label,o=s.Symbol,d=s.BaseSymbol,n=this.commonCurrencyCode(o),h=this.commonCurrencyCode(d);a=n+"/"+h;let l={amount:8,price:8},c=s.MinimumTrade,m={min:s.MinimumPrice,max:s.MaximumPrice},u={amount:{min:c,max:s.MaximumTrade},price:m,cost:{min:s.MinimumBaseTrade,max:void 0}},p="OK"===s.Status;e.push({id:r,symbol:a,label:s.Label,base:n,quote:h,baseId:o,quoteId:d,info:s,maker:s.TradeFee/100,taker:s.TradeFee/100,lot:u.amount.min,active:p,precision:l,limits:u})}return this.options.marketsByLabel=this.indexBy(e,"label"),e}async fetchOrderBook(e,t,i={}){await this.loadMarkets();let s=(await this.publicGetGetMarketOrdersId(this.extend({id:this.marketId(e)},i))).Data;return this.parseOrderBook(s,void 0,"Buy","Sell","Price","Volume")}async fetchOHLCV(e,t="15m",i,s,r={}){let a=0;if(void 0!==i){const e=[86400,172800,604800,1209600,2592e3,7776e3,15552e3],t=e.length;let s=this.seconds(),r=parseInt(i/1e3);for(let i=1;i<t;i++)s-r>e[i]&&(a=i)}await this.loadMarkets();let o=this.market(e),d={tradePairId:o.id,dataRange:a,dataGroup:this.timeframes[t]},n=await this.webGetExchangeGetTradePairChart(this.extend(d,r)),h=n.Candle,l=n.Volume;for(let e=0;e<h.length;e++)h[e].push(l[e].basev);return this.parseOHLCVs(h,o,t,i,s)}joinMarketIds(e,t="-"){let i=e[0].toString();for(let s=1;s<e.length;s++)i+=t+e[s].toString();return i}async fetchOrderBooks(e,i={}){if(await this.loadMarkets(),void 0===e)throw new t(this.id+" fetchOrderBooks requires the symbols argument as of May 2018 (up to 5 symbols at max)");if(e.length>5)throw new t(this.id+" fetchOrderBooks accepts 5 symbols at max");let s=this.joinMarketIds(this.marketIds(e)),r=(await this.publicGetGetMarketOrderGroupsIds(this.extend({ids:s},i))).Data,a={};for(let e=0;e<r.length;e++){let t=r[e],i=this.safeInteger(t,"TradePairId"),s=i;if(i in this.markets_by_id){s=this.markets_by_id[i].symbol}a[s]=this.parseOrderBook(t,void 0,"Buy","Sell","Price","Volume")}return a}parseTicker(e,t){let i=this.milliseconds(),s=void 0;t&&(s=t.symbol);let r=this.safeFloat(e,"Open"),a=this.safeFloat(e,"LastPrice"),o=a-r,d=this.safeFloat(e,"Volume"),n=this.safeFloat(e,"BaseVolume"),h=void 0;return void 0!==n&&void 0!==d&&d>0&&(h=n/d),{symbol:s,info:e,timestamp:i,datetime:this.iso8601(i),high:this.safeFloat(e,"High"),low:this.safeFloat(e,"Low"),bid:this.safeFloat(e,"BidPrice"),bidVolume:void 0,ask:this.safeFloat(e,"AskPrice"),askVolume:void 0,vwap:h,open:r,close:a,last:a,previousClose:void 0,change:o,percentage:this.safeFloat(e,"Change"),average:this.sum(a,r)/2,baseVolume:d,quoteVolume:n}}async fetchTicker(e,t={}){await this.loadMarkets();let i=this.market(e),s=(await this.publicGetGetMarketId(this.extend({id:i.id},t))).Data;return this.parseTicker(s,i)}async fetchTickers(e,i={}){await this.loadMarkets();let s={},r=(await this.publicGetGetMarkets(i)).Data;for(let e=0;e<r.length;e++){let i=r[e],a=i.TradePairId;if(a in this.markets_by_id){let e=this.markets_by_id[a];s[e.symbol]=this.parseTicker(i,e)}else if(this.options.fetchTickersErrors)throw new t(this.id+" fetchTickers() returned unrecognized pair id "+a.toString())}return this.filterByArray(s,"symbol",e)}parseTrade(e,t){let i=void 0;"Timestamp"in e?i=1e3*e.Timestamp:"TimeStamp"in e&&(i=this.parse8601(e.TimeStamp));let s=this.safeFloat(e,"Price");s||(s=this.safeFloat(e,"Rate"));let r=this.safeFloat(e,"Total"),a=this.safeString(e,"TradeId");t||"TradePairId"in e&&e.TradePairId in this.markets_by_id&&(t=this.markets_by_id[e.TradePairId]);let o=void 0,d=void 0;return t&&(o=t.symbol,"Fee"in e&&(d={currency:t.quote,cost:e.Fee})),{id:a,info:e,order:void 0,timestamp:i,datetime:this.iso8601(i),symbol:o,type:"limit",side:e.Type.toLowerCase(),price:s,cost:r,amount:e.Amount,fee:d}}async fetchTrades(e,t,i,s={}){await this.loadMarkets();let r=this.market(e),a=24;if(void 0!==t){let e=this.milliseconds()-t,i=36e5;a=parseInt(Math.ceil(e/i))}let o={id:r.id,hours:a},d=(await this.publicGetGetMarketHistoryIdHours(this.extend(o,s))).Data;return this.parseTrades(d,r,t,i)}async fetchMyTrades(e,t,i,s={}){await this.loadMarkets();let r={},a=void 0;e&&(a=this.market(e),r.TradePairId=a.id),void 0!==i&&(r.Count=i);let o=await this.privatePostGetTradeHistory(this.extend(r,s));return this.parseTrades(o.Data,a,t,i)}async fetchCurrencies(e={}){let t=(await this.publicGetGetCurrencies(e)).Data,i={};for(let e=0;e<t.length;e++){let s=t[e],r=s.Symbol,a=8,o=this.commonCurrencyCode(r),d="Active"===s.ListingStatus,n=s.Status.toLowerCase();"ok"!==n&&(d=!1),i[o]={id:r,code:o,info:s,name:s.Name,active:d,status:n,fee:s.WithdrawFee,precision:a,limits:{amount:{min:Math.pow(10,-a),max:Math.pow(10,a)},price:{min:Math.pow(10,-a),max:Math.pow(10,a)},cost:{min:s.MinBaseTrade,max:void 0},withdraw:{min:s.MinWithdraw,max:s.MaxWithdraw}}}}return i}async fetchBalance(e={}){await this.loadMarkets();let t=await this.privatePostGetBalance(e),i=t.Data,s={info:t};for(let e=0;e<i.length;e++){let t=i[e],r=t.Symbol,a=this.commonCurrencyCode(r),o={free:t.Available,used:0,total:t.Total};o.used=o.total-o.free,s[a]=o}return this.parseBalance(s)}async createOrder(e,i,s,r,a,o={}){if("market"===i)throw new t(this.id+" allows limit orders only");await this.loadMarkets();let d={TradePairId:this.market(e).id,Type:this.capitalize(s),Rate:a,Amount:r},n=await this.privatePostSubmitTrade(this.extend(d,o));if(!n)throw new t(this.id+" createOrder returned unknown error: "+this.json(n));let h=void 0,l=0,c="open";"Data"in n&&"OrderId"in n.Data&&(n.Data.OrderId?h=n.Data.OrderId.toString():(l=r,c="closed"));let m=this.milliseconds(),u={id:h,timestamp:m,datetime:this.iso8601(m),lastTradeTimestamp:void 0,status:c,symbol:e,type:i,side:s,price:a,cost:a*r,amount:r,remaining:r-l,filled:l,fee:void 0};return h&&(this.orders[h]=u),this.extend({info:n},u)}async cancelOrder(e,t,i={}){await this.loadMarkets();let r=void 0;try{r=await this.privatePostCancelTrade(this.extend({Type:"Trade",OrderId:e},i)),e in this.orders&&(this.orders[e].status="canceled")}catch(e){if(this.last_json_response){let e=this.safeString(this.last_json_response,"Error");if(e&&e.indexOf("does not exist")>=0)throw new s(this.id+" cancelOrder() error: "+this.last_http_response)}throw e}return this.parseOrder(r)}parseOrder(e,t){let i=void 0;if(t)i=t.symbol;else if("Market"in e){let s=e.Market;s in this.markets_by_id?i=(t=this.markets_by_id[s]).symbol:s in this.options.marketsByLabel&&(i=(t=this.options.marketsByLabel[s]).symbol)}let s=this.safeInteger(e,"TimeStamp"),r=void 0;s&&(r=this.iso8601(s));let a=this.safeFloat(e,"Amount"),o=this.safeFloat(e,"Remaining"),d=void 0;void 0!==a&&void 0!==o&&(d=a-o);let n=this.safeValue(e,"OrderId");void 0!==n&&(n=n.toString());let h=this.safeString(e,"Type");return void 0!==h&&(h=h.toLowerCase()),{id:n,info:this.omit(e,"status"),timestamp:s,datetime:r,lastTradeTimestamp:void 0,status:e.status,symbol:i,type:"limit",side:h,price:this.safeFloat(e,"Rate"),cost:this.safeFloat(e,"Total"),amount:a,filled:d,remaining:o,fee:void 0}}async fetchOrders(e,t,i,s={}){await this.loadMarkets();let r=void 0,a={};void 0!==e&&(r=this.market(e),a.TradePairId=r.id);let o=await this.privatePostGetOpenOrders(this.extend(a,s)),d=[];for(let e=0;e<o.Data.length;e++)d.push(this.extend(o.Data[e],{status:"open"}));let n=this.parseOrders(d,r);for(let e=0;e<n.length;e++)this.orders[n[e].id]=n[e];let h=this.indexBy(n,"id"),l=Object.keys(this.orders),c=[];for(let t=0;t<l.length;t++){let i=l[t];if(i in h)this.orders[i]=this.extend(this.orders[i],h[i]);else{let t=this.orders[i];"open"===t.status&&(void 0!==e&&t.symbol!==e||(this.orders[i]=this.extend(t,{status:"closed",cost:t.amount*t.price,filled:t.amount,remaining:0})))}let s=this.orders[i];void 0!==e&&s.symbol!==e||c.push(s)}return this.filterBySinceLimit(c,t,i)}async fetchOrder(e,t,i={}){e=e.toString();let s=await this.fetchOrders(t,void 0,void 0,i);for(let t=0;t<s.length;t++)if(s[t].id===e)return s[t];throw new r(this.id+" order "+e+" not found in cached .orders, fetchOrder requires .orders (de)serialization implemented for this method to work properly")}async fetchOpenOrders(e,t,i,s={}){let r=await this.fetchOrders(e,t,i,s),a=[];for(let e=0;e<r.length;e++)"open"===r[e].status&&a.push(r[e]);return a}async fetchClosedOrders(e,t,i,s={}){let r=await this.fetchOrders(e,t,i,s),a=[];for(let e=0;e<r.length;e++)"closed"===r[e].status&&a.push(r[e]);return a}async fetchDepositAddress(e,t={}){await this.loadMarkets();let i=this.currency(e),s=await this.privatePostGetDepositAddress(this.extend({Currency:i.id},t)),r=this.safeString(s.Data,"BaseAddress");return r||(r=this.safeString(s.Data,"Address")),this.checkAddress(r),{currency:e,address:r,status:"ok",info:s}}async withdraw(e,t,i,s,r={}){await this.loadMarkets();let a=this.currency(e);this.checkAddress(i);let o={Currency:a.id,Amount:t,Address:i};s&&(o.PaymentId=s);let d=await this.privatePostSubmitWithdraw(this.extend(o,r));return{info:d,id:d.Data}}sign(e,t="public",i="GET",s={},r,a){let o=this.urls.api[t]+"/"+this.implodeParams(e,s),d=this.omit(s,this.extractParams(e));if("private"===t){this.checkRequiredCredentials();let e=this.nonce().toString();a=this.json(d,{convertArraysToObjects:!0});let t=this.hash(this.encode(a),"md5","base64"),s=this.base64ToBinary(this.secret),n=this.encodeURIComponent(o).toLowerCase();t=this.binaryToString(t);let h=this.apiKey+i+n+e+t,l=this.hmac(this.encode(h),s,"sha256","base64");r={"Content-Type":"application/json",Authorization:"amx "+this.apiKey+":"+this.binaryToString(l)+":"+e}}else Object.keys(d).length&&(o+="?"+this.urlencode(d));return{url:o,method:i,body:a,headers:r}}nonce(){return this.milliseconds()}handleErrors(e,r,o,d,n,h){if("string"!=typeof h)return;if(h.length<2)return;const l=this.sanitizeBrokenJSONString(h);if("{"===l[0]){let e=JSON.parse(l);if("Success"in e){if("false"===this.safeString(e,"Success")){let r=this.safeString(e,"Error"),o=this.id;if("string"==typeof r){if(o=o+" "+r,r.indexOf("does not exist")>=0)throw new s(o);if(r.indexOf("Insufficient Funds")>=0)throw new i(o);if(r.indexOf("Nonce has already been used")>=0)throw new a(o)}else o=o+" "+l;throw new t(o)}}}}sanitizeBrokenJSONString(e){const t=e.indexOf("{");return t>=0?e.slice(t):e}parseJson(e,t,i,s){return super.parseJson(e,this.sanitizeBrokenJSONString(t),i,s)}};
//# sourceMappingURL=cryptopia.js.map
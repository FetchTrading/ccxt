"use strict";const e=require("./base/Exchange"),{ExchangeError:t,AuthenticationError:i,DDoSProtection:s,ExchangeNotAvailable:r,InvalidOrder:a,OrderNotFound:o,PermissionDenied:d,InsufficientFunds:n}=require("./base/errors");module.exports=class extends e{describe(){return this.deepExtend(super.describe(),{id:"bibox",name:"Bibox",countries:["CN","US","KR"],version:"v1",has:{CORS:!1,publicAPI:!1,fetchBalance:!0,fetchCurrencies:!0,fetchDepositAddress:!0,fetchFundingFees:!0,fetchTickers:!0,fetchOrder:!0,fetchOpenOrders:!0,fetchClosedOrders:!0,fetchMyTrades:!0,fetchOHLCV:!0,createMarketOrder:!1,withdraw:!0},timeframes:{"1m":"1min","5m":"5min","15m":"15min","30m":"30min","1h":"1hour","8h":"12hour","1d":"day","1w":"week"},urls:{logo:"https://user-images.githubusercontent.com/1294454/34902611-2be8bf1a-f830-11e7-91a2-11b2f292e750.jpg",api:"https://api.bibox.com",www:"https://www.bibox.com",doc:["https://github.com/Biboxcom/api_reference/wiki/home_en","https://github.com/Biboxcom/api_reference/wiki/api_reference"],fees:"https://bibox.zendesk.com/hc/en-us/articles/115004417013-Fee-Structure-on-Bibox"},api:{public:{post:["mdata"],get:["mdata"]},private:{post:["user","orderpending","transfer"]}},fees:{trading:{tierBased:!1,percentage:!0,taker:.001,maker:0},funding:{tierBased:!1,percentage:!1,withdraw:{},deposit:{}}},exceptions:{2021:n,2015:i,2027:n,2033:o,2067:a,2068:a,3012:i,3024:d,3025:i,4000:r,4003:s},commonCurrencies:{KEY:"Bihu"}})}async fetchMarkets(e={}){let t=(await this.publicGetMdata(this.extend({cmd:"marketAll"},e))).result,i=[];for(let e=0;e<t.length;e++){let s=t[e],r=s.coin_symbol,a=s.currency_symbol,o=this.commonCurrencyCode(r),d=this.commonCurrencyCode(a),n=o+"/"+d,h=o+"_"+d,c={amount:8,price:8};i.push({id:h,symbol:n,base:o,quote:d,baseId:o,quoteId:d,active:!0,info:s,lot:Math.pow(10,-c.amount),precision:c,limits:{amount:{min:Math.pow(10,-c.amount),max:void 0},price:{min:void 0,max:void 0}}})}return i}parseTicker(e,t){let i=this.safeInteger(e,"timestamp"),s=void 0;if(t)s=t.symbol;else{let t=e.coin_symbol,i=e.currency_symbol;s=this.commonCurrencyCode(t)+"/"+this.commonCurrencyCode(i)}let r=this.safeFloat(e,"last"),a=this.safeFloat(e,"change"),o=void 0;o="vol"in e?this.safeFloat(e,"vol"):this.safeFloat(e,"vol24H");let d=void 0;void 0!==r&&void 0!==a&&(d=r-a);let n=void 0;return void 0!==i&&(n=this.iso8601(i)),{symbol:s,timestamp:i,datetime:n,high:this.safeFloat(e,"high"),low:this.safeFloat(e,"low"),bid:this.safeFloat(e,"buy"),bidVolume:void 0,ask:this.safeFloat(e,"sell"),askVolume:void 0,vwap:void 0,open:d,close:r,last:r,previousClose:void 0,change:a,percentage:this.safeString(e,"percent"),average:void 0,baseVolume:o,quoteVolume:this.safeFloat(e,"amount"),info:e}}async fetchTicker(e,t={}){await this.loadMarkets();let i=this.market(e),s=await this.publicGetMdata(this.extend({cmd:"ticker",pair:i.id},t));return this.parseTicker(s.result,i)}parseTickers(e,t){let i=[];for(let t=0;t<e.length;t++)i.push(this.parseTicker(e[t]));return this.filterByArray(i,"symbol",t)}async fetchTickers(e,t={}){let i=await this.publicGetMdata(this.extend({cmd:"marketAll"},t));return this.parseTickers(i.result,e)}parseTrade(e,t){let i=e.time,s=this.safeInteger(e,"side");if(s=1===(s=this.safeInteger(e,"order_side",s))?"buy":"sell",void 0===t){let i=this.safeString(e,"pair");void 0!==i&&i in this.markets_by_id&&(t=this.markets_by_id[i])}let r=void 0!==t?t.symbol:void 0,a=void 0;return"fee"in e&&(a={cost:this.safeFloat(e,"fee"),currency:void 0}),{id:this.safeString(e,"id"),info:e,timestamp:i,datetime:this.iso8601(i),symbol:r,type:"limit",side:s,price:this.safeFloat(e,"price"),amount:this.safeFloat(e,"amount"),fee:a}}async fetchTrades(e,t,i,s={}){await this.loadMarkets();let r=this.market(e),a=i||200,o=await this.publicGetMdata(this.extend({cmd:"deals",pair:r.id,size:a},s));return this.parseTrades(o.result,r,t,i)}async fetchOrderBook(e,t=200,i={}){await this.loadMarkets();let s={cmd:"depth",pair:this.market(e).id};s.size=t;let r=await this.publicGetMdata(this.extend(s,i));return this.parseOrderBook(r.result,this.safeFloat(r.result,"update_time"),"bids","asks","price","volume")}parseOHLCV(e,t,i="1m",s,r){return[e.time,e.open,e.high,e.low,e.close,e.vol]}async fetchOHLCV(e,t="1m",i,s=1e3,r={}){await this.loadMarkets();let a=this.market(e),o=await this.publicGetMdata(this.extend({cmd:"kline",pair:a.id,period:this.timeframes[t],size:s},r));return this.parseOHLCVs(o.result,a,t,i,s)}async fetchCurrencies(e={}){let t=(await this.privatePostTransfer({cmd:"transfer/coinList",body:{}})).result,i={};for(let e=0;e<t.length;e++){let s=t[e],r=s.symbol,a=this.commonCurrencyCode(r),o=8,d=s.enable_deposit,n=s.enable_withdraw,h=!(!d||!n);i[a]={id:r,code:a,info:s,name:s.name,active:h,status:"ok",fee:void 0,precision:o,limits:{amount:{min:Math.pow(10,-o),max:Math.pow(10,o)},price:{min:Math.pow(10,-o),max:Math.pow(10,o)},cost:{min:void 0,max:void 0},withdraw:{min:void 0,max:Math.pow(10,o)}}}}return i}async fetchBalance(e={}){await this.loadMarkets();let t=(await this.privatePostTransfer({cmd:"transfer/assets",body:this.extend({select:1},e)})).result,i={info:t},s=void 0;s="assets_list"in t?this.indexBy(t.assets_list,"coin_symbol"):t;let r=Object.keys(s);for(let e=0;e<r.length;e++){let t=r[e],a=t.toUpperCase();a.indexOf("TOTAL_")>=0&&(a=a.slice(6)),a in this.currencies_by_id&&(a=this.currencies_by_id[a].code);let o=this.account(),d=s[t];"string"==typeof d?(d=parseFloat(d),o.free=d,o.used=0,o.total=d):(o.free=parseFloat(d.balance),o.used=parseFloat(d.freeze),o.total=this.sum(o.free,o.used)),i[a]=o}return this.parseBalance(i)}async createOrder(e,t,i,s,r,a={}){await this.loadMarkets();let o=this.market(e),d="limit"===t?2:1,n="buy"===i?1:2,h=await this.privatePostOrderpending({cmd:"orderpending/trade",body:this.extend({pair:o.id,account_type:0,order_type:d,order_side:n,pay_bix:0,amount:s,price:r},a)});return{info:h,id:this.safeString(h,"result")}}async cancelOrder(e,t,i={}){return await this.privatePostOrderpending({cmd:"orderpending/cancelTrade",body:this.extend({orders_id:e},i)})}async fetchOrder(e,t,i={}){let s=await this.privatePostOrderpending({cmd:"orderpending/order",body:this.extend({id:e},i)});return this.parseOrder(s.result)}parseOrder(e,t){let i=void 0;i=t?t.symbol:e.coin_symbol+"/"+e.currency_symbol;let s=1===e.order_type?"market":"limit",r=e.createdAt,a=this.safeFloat(e,"price"),o=this.safeFloat(e,"deal_amount"),d=this.safeFloat(e,"amount"),n=this.safeFloat(e,"money"),h=void 0;void 0!==o&&(void 0!==d&&(h=d-o),void 0===n&&(n=a*o));let c=1===e.order_side?"buy":"sell",l=this.safeString(e,"status");return void 0!==l&&(l=this.parseOrderStatus(l)),{info:e,id:this.safeString(e,"id"),timestamp:r,datetime:this.iso8601(r),lastTradeTimestamp:void 0,symbol:i,type:s,side:c,price:a,amount:d,cost:n||parseFloat(a)*o,filled:o,remaining:h,status:l,fee:this.safeFloat(e,"fee")}}parseOrderStatus(e){return this.safeString({1:"pending",2:"open",3:"closed",4:"canceled",5:"canceled",6:"canceled"},e,e.toLowerCase())}async fetchOpenOrders(e,t,i,s={}){let r=void 0,a=void 0;void 0!==e&&(await this.loadMarkets(),a=(r=this.market(e)).id);let o=i||200,d=await this.privatePostOrderpending({cmd:"orderpending/orderPendingList",body:this.extend({pair:a,account_type:0,page:1,size:o},s)}),n=this.safeValue(d.result,"items",[]);return this.parseOrders(n,r,t,i)}async fetchClosedOrders(e,i,s=200,r={}){if(void 0===e)throw new t(this.id+" fetchClosedOrders requires a symbol argument");await this.loadMarkets();let a=this.market(e),o=await this.privatePostOrderpending({cmd:"orderpending/pendingHistoryList",body:this.extend({pair:a.id,account_type:0,page:1,size:s},r)}),d=this.safeValue(o.result,"items",[]);return this.parseOrders(d,a,i,s)}async fetchMyTrades(e,i,s,r={}){if(!e)throw new t(this.id+" fetchMyTrades requires a symbol argument");await this.loadMarkets();let a=this.market(e),o=s||200,d=await this.privatePostOrderpending({cmd:"orderpending/pendingHistoryList",body:this.extend({pair:a.id,account_type:0,page:1,size:o},r)}),n=this.safeValue(d.result,"items",[]);return this.parseOrders(n,a,i,s)}async fetchDepositAddress(e,t={}){await this.loadMarkets();let i=this.currency(e),s=await this.privatePostTransfer({cmd:"transfer/transferIn",body:this.extend({coin_symbol:i.id},t)});return{info:s,address:this.safeString(s,"result")}}async withdraw(e,i,s,r,a={}){this.checkAddress(s),await this.loadMarkets();let o=this.currency(e);if(void 0===this.password&&!("trade_pwd"in a))throw new t(this.id+" withdraw() requires this.password set on the exchange instance or a trade_pwd parameter");if(!("totp_code"in a))throw new t(this.id+" withdraw() requires a totp_code parameter for 2FA authentication");let d={trade_pwd:this.password,coin_symbol:o.id,amount:i,addr:s};return void 0!==r&&(d.address_remark=r),{info:await this.privatePostTransfer({cmd:"transfer/transferOut",body:this.extend(d,a)}),id:void 0}}async fetchFundingFees(e,t={}){await this.loadMarkets();let i={},s={};void 0===e&&(e=Object.keys(this.currencies));for(let r=0;r<e.length;r++){let a=e[r],o=this.currency(a),d=await this.privatePostTransfer({cmd:"transfer/transferOutInfo",body:this.extend({coin_symbol:o.id},t)});s[a]=d,i[a]=d.result.withdraw_fee}return{info:s,withdraw:i,deposit:{}}}sign(e,t="public",i="GET",s={},r,a){let o=this.urls.api+"/"+this.version+"/"+e,d=this.json([s]);return"public"===t?"GET"!==i?a={cmds:d}:Object.keys(s).length&&(o+="?"+this.urlencode(s)):(this.checkRequiredCredentials(),a={cmds:d,apikey:this.apiKey,sign:this.hmac(this.encode(d),this.encode(this.secret),"md5")}),void 0!==a&&(a=this.json(a,{convertArraysToObjects:!0})),{url:o,method:i,body:a,headers:{"Content-Type":"application/json"}}}handleErrors(e,i,s,r,a,o){if(o.length>0&&"{"===o[0]){let e=JSON.parse(o);if("error"in e){if("code"in e.error){let i=this.safeString(e.error,"code"),s=this.id+" "+o;const r=this.exceptions;throw i in r?new r[i](s):new t(s)}throw new t(this.id+': "error" in response: '+o)}if(!("result"in e))throw new t(this.id+" "+o)}}async request(e,t="public",i="GET",s={},r,a){let o=await this.fetch2(e,t,i,s,r,a);return"GET"===i?o:o.result[0]}};
//# sourceMappingURL=bibox.js.map
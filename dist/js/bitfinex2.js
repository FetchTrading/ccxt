"use strict";const e=require("./bitfinex.js"),{ExchangeError:t,NotSupported:s,InsufficientFunds:i}=require("./base/errors");module.exports=class extends e{describe(){return this.deepExtend(super.describe(),{id:"bitfinex2",name:"Bitfinex v2",countries:"VG",version:"v2",has:{CORS:!0,createLimitOrder:!1,createMarketOrder:!1,createOrder:!1,deposit:!1,editOrder:!1,fetchDepositAddress:!1,fetchClosedOrders:!1,fetchFundingFees:!1,fetchMyTrades:!1,fetchOHLCV:!0,fetchOpenOrders:!1,fetchOrder:!0,fetchTickers:!0,fetchTradingFees:!1,withdraw:!0},timeframes:{"1m":"1m","5m":"5m","15m":"15m","30m":"30m","1h":"1h","3h":"3h","6h":"6h","12h":"12h","1d":"1D","1w":"7D","2w":"14D","1M":"1M"},rateLimit:1500,urls:{logo:"https://user-images.githubusercontent.com/1294454/27766244-e328a50c-5ed2-11e7-947b-041416579bb3.jpg",api:"https://api.bitfinex.com",www:"https://www.bitfinex.com",doc:["https://bitfinex.readme.io/v2/docs","https://github.com/bitfinexcom/bitfinex-api-node"],fees:"https://www.bitfinex.com/fees"},api:{v1:{get:["symbols","symbols_details"]},public:{get:["platform/status","tickers","ticker/{symbol}","trades/{symbol}/hist","book/{symbol}/{precision}","book/{symbol}/P0","book/{symbol}/P1","book/{symbol}/P2","book/{symbol}/P3","book/{symbol}/R0","stats1/{key}:{size}:{symbol}/{side}/{section}","stats1/{key}:{size}:{symbol}/long/last","stats1/{key}:{size}:{symbol}/long/hist","stats1/{key}:{size}:{symbol}/short/last","stats1/{key}:{size}:{symbol}/short/hist","candles/trade:{timeframe}:{symbol}/{section}","candles/trade:{timeframe}:{symbol}/last","candles/trade:{timeframe}:{symbol}/hist"],post:["calc/trade/avg"]},private:{post:["auth/r/wallets","auth/r/orders/{symbol}","auth/r/orders/{symbol}/new","auth/r/orders/{symbol}/hist","auth/r/order/{symbol}:{id}/trades","auth/r/trades/{symbol}/hist","auth/r/positions","auth/r/funding/offers/{symbol}","auth/r/funding/offers/{symbol}/hist","auth/r/funding/loans/{symbol}","auth/r/funding/loans/{symbol}/hist","auth/r/funding/credits/{symbol}","auth/r/funding/credits/{symbol}/hist","auth/r/funding/trades/{symbol}/hist","auth/r/info/margin/{key}","auth/r/info/funding/{key}","auth/r/movements/{currency}/hist","auth/r/stats/perf:{timeframe}/hist","auth/r/alerts","auth/w/alert/set","auth/w/alert/{type}:{symbol}:{price}/del","auth/calc/order/avail","auth/r/ledgers/{symbol}/hist"]}},fees:{trading:{maker:.001,taker:.002},funding:{withdraw:{BTC:5e-4,BCH:5e-4,ETH:.01,EOS:.1,LTC:.001,OMG:.1,IOT:0,NEO:0,ETC:.01,XRP:.02,ETP:.01,ZEC:.001,BTG:0,DASH:.01,XMR:.04,QTM:.01,EDO:.5,DAT:1,AVT:.5,SAN:.1,USDT:5,SPK:9.2784,BAT:9.0883,GNT:8.2881,SNT:14.303,QASH:3.2428,YYW:18.055}}}})}isFiat(e){return e in{USD:"USD",EUR:"EUR"}}getCurrencyId(e){return"f"+e}async fetchMarkets(){let e=await this.v1GetSymbolsDetails(),t=[];for(let s=0;s<e.length;s++){let i=e[s],r=i.pair.toUpperCase(),a=r.slice(0,3),o=r.slice(3,6),n=this.commonCurrencyCode(a),h=this.commonCurrencyCode(o),d=n+"/"+h;r="t"+r,a=this.getCurrencyId(a),o=this.getCurrencyId(o);let l={price:i.price_precision,amount:i.price_precision},m={amount:{min:this.safeFloat(i,"minimum_order_size"),max:this.safeFloat(i,"maximum_order_size")},price:{min:Math.pow(10,-l.price),max:Math.pow(10,l.price)}};m.cost={min:m.amount.min*m.price.min,max:void 0},t.push({id:r,symbol:d,base:n,quote:h,baseId:a,quoteId:o,active:!0,precision:l,limits:m,lot:Math.pow(10,-l.amount),info:i})}return t}async fetchBalance(e={}){await this.loadMarkets();let t=await this.privatePostAuthRWallets(),s=this.safeString(e,"type","exchange"),i={info:t};for(let e=0;e<t.length;e++){let r=t[e],a=r[0],o=r[1],n=r[2],h=r[4];if(a===s){let e=o;o in this.currencies_by_id?e=this.currencies_by_id[o].code:"t"===o[0]&&(e=(o=o.slice(1)).toUpperCase(),e=this.commonCurrencyCode(e));let t=this.account();t.total=n,h?(t.free=h,t.used=t.total-t.free):0===h?(t.free=0,t.used=n):t.free=void 0,i[e]=t}}return this.parseBalance(i)}async fetchOrderBook(e,t,s={}){await this.loadMarkets();let i=await this.publicGetBookSymbolPrecision(this.extend({symbol:this.marketId(e),precision:"R0"},s)),r=this.milliseconds(),a={bids:[],asks:[],timestamp:r,datetime:this.iso8601(r),nonce:void 0};for(let e=0;e<i.length;e++){let t=i[e],s=t[1],r=t[2],o=r>0?"bids":"asks";r=Math.abs(r),a[o].push([s,r])}return a.bids=this.sortBy(a.bids,0,!0),a.asks=this.sortBy(a.asks,0),a}parseTicker(e,t){let s=this.milliseconds(),i=void 0;t&&(i=t.symbol);let r=e.length,a=e[r-4];return{symbol:i,timestamp:s,datetime:this.iso8601(s),high:e[r-2],low:e[r-1],bid:e[r-10],bidVolume:void 0,ask:e[r-8],askVolume:void 0,vwap:void 0,open:void 0,close:a,last:a,previousClose:void 0,change:e[r-6],percentage:e[r-5],average:void 0,baseVolume:e[r-3],quoteVolume:void 0,info:e}}async fetchTickers(e,t={}){await this.loadMarkets();let s=await this.publicGetTickers(this.extend({symbols:this.ids.join(",")},t)),i={};for(let e=0;e<s.length;e++){let t=s[e],r=t[0],a=this.markets_by_id[r];i[a.symbol]=this.parseTicker(t,a)}return i}async fetchTicker(e,t={}){await this.loadMarkets();let s=this.markets[e],i=await this.publicGetTickerSymbol(this.extend({symbol:s.id},t));return this.parseTicker(i,s)}parseTrade(e,t){let[s,i,r,a]=e,o=r<0?"sell":"buy";return r<0&&(r=-r),{id:s.toString(),info:e,timestamp:i,datetime:this.iso8601(i),symbol:t.symbol,type:void 0,side:o,price:a,amount:r}}async fetchTrades(e,t,s=120,i={}){await this.loadMarkets();let r=this.market(e),a={symbol:r.id,sort:"-1",limit:s};void 0!==t&&(a.start=t);let o=await this.publicGetTradesSymbolHist(this.extend(a,i)),n=this.sortBy(o,1);return this.parseTrades(n,r,void 0,s)}async fetchOHLCV(e,t="1m",s,i=100,r={}){await this.loadMarkets();let a=this.market(e);void 0===s&&(s=this.milliseconds()-this.parseTimeframe(t)*i*1e3);let o={symbol:a.id,timeframe:this.timeframes[t],sort:1,limit:i,start:s},n=await this.publicGetCandlesTradeTimeframeSymbolHist(this.extend(o,r));return this.parseOHLCVs(n,a,t,s,i)}async createOrder(e,t,i,r,a,o={}){throw new s(this.id+" createOrder not implemented yet")}cancelOrder(e,t,i={}){throw new s(this.id+" cancelOrder not implemented yet")}async fetchOrder(e,t,i={}){throw new s(this.id+" fetchOrder not implemented yet")}async fetchDepositAddress(e,t={}){throw new s(this.id+" fetchDepositAddress() not implemented yet.")}async withdraw(e,t,i,r,a={}){throw new s(this.id+" withdraw not implemented yet")}async fetchMyTrades(e,t,s=25,i={}){await this.loadMarkets();let r={symbol:this.market(e).id,limit:s,end:this.seconds()};return void 0!==t&&(r.start=parseInt(t/1e3)),await this.privatePostAuthRTradesSymbolHist(this.extend(r,i))}nonce(){return this.milliseconds()}sign(e,t="public",s="GET",i={},r,a){let o="/"+this.implodeParams(e,i),n=this.omit(i,this.extractParams(e));o="v1"===t?t+o:this.version+o;let h=this.urls.api+"/"+o;if("public"===t&&Object.keys(n).length&&(h+="?"+this.urlencode(n)),"private"===t){this.checkRequiredCredentials();let e=this.nonce().toString(),t="/api/"+o+e+(a=this.json(n)),s=this.hmac(this.encode(t),this.encode(this.secret),"sha384");r={"bfx-nonce":e,"bfx-apikey":this.apiKey,"bfx-signature":s,"Content-Type":"application/json"}}return{url:h,method:s,body:a,headers:r}}async request(e,s="public",r="GET",a={},o,n){let h=await this.fetch2(e,s,r,a,o,n);if(h){if("message"in h){if(h.message.indexOf("not enough exchange balance")>=0)throw new i(this.id+" "+this.json(h));throw new t(this.id+" "+this.json(h))}return h}if(""===h)throw new t(this.id+" returned empty response");return h}};
//# sourceMappingURL=bitfinex2.js.map
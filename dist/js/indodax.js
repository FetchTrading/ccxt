"use strict";const e=require("./base/Exchange"),{ExchangeError:i,InsufficientFunds:t,InvalidOrder:s,OrderNotFound:r,AuthenticationError:a}=require("./base/errors");module.exports=class extends e{describe(){return this.deepExtend(super.describe(),{id:"indodax",name:"INDODAX",countries:"ID",has:{CORS:!1,createMarketOrder:!1,fetchTickers:!1,fetchOrder:!0,fetchOrders:!1,fetchClosedOrders:!0,fetchOpenOrders:!0,fetchMyTrades:!1,fetchCurrencies:!1,withdraw:!0},version:"1.8",urls:{logo:"https://user-images.githubusercontent.com/1294454/37443283-2fddd0e4-281c-11e8-9741-b4f1419001b5.jpg",api:{public:"https://indodax.com/api",private:"https://indodax.com/tapi"},www:"https://www.indodax.com",doc:"https://indodax.com/downloads/BITCOINCOID-API-DOCUMENTATION.pdf"},api:{public:{get:["{pair}/ticker","{pair}/trades","{pair}/depth"]},private:{post:["getInfo","transHistory","trade","tradeHistory","getOrder","openOrders","cancelOrder","orderHistory","withdrawCoin"]}},markets:{"BTC/IDR":{id:"btc_idr",symbol:"BTC/IDR",base:"BTC",quote:"IDR",baseId:"btc",quoteId:"idr",precision:{amount:8,price:0},limits:{amount:{min:1e-4,max:void 0}}},"BCH/IDR":{id:"bch_idr",symbol:"BCH/IDR",base:"BCH",quote:"IDR",baseId:"bch",quoteId:"idr",precision:{amount:8,price:0},limits:{amount:{min:.001,max:void 0}}},"BTG/IDR":{id:"btg_idr",symbol:"BTG/IDR",base:"BTG",quote:"IDR",baseId:"btg",quoteId:"idr",precision:{amount:8,price:0},limits:{amount:{min:.01,max:void 0}}},"ETH/IDR":{id:"eth_idr",symbol:"ETH/IDR",base:"ETH",quote:"IDR",baseId:"eth",quoteId:"idr",precision:{amount:8,price:0},limits:{amount:{min:.01,max:void 0}}},"ETC/IDR":{id:"etc_idr",symbol:"ETC/IDR",base:"ETC",quote:"IDR",baseId:"etc",quoteId:"idr",precision:{amount:8,price:0},limits:{amount:{min:.1,max:void 0}}},"IGNIS/IDR":{id:"ignis_idr",symbol:"IGNIS/IDR",base:"IGNIS",quote:"IDR",baseId:"ignis",quoteId:"idr",precision:{amount:8,price:0},limits:{amount:{min:1,max:void 0}}},"LTC/IDR":{id:"ltc_idr",symbol:"LTC/IDR",base:"LTC",quote:"IDR",baseId:"ltc",quoteId:"idr",precision:{amount:8,price:0},limits:{amount:{min:.01,max:void 0}}},"NXT/IDR":{id:"nxt_idr",symbol:"NXT/IDR",base:"NXT",quote:"IDR",baseId:"nxt",quoteId:"idr",precision:{amount:8,price:0},limits:{amount:{min:5,max:void 0}}},"TEN/IDR":{id:"ten_idr",symbol:"TEN/IDR",base:"TEN",quote:"IDR",baseId:"ten",quoteId:"idr",precision:{amount:8,price:0},limits:{amount:{min:5,max:void 0}}},"WAVES/IDR":{id:"waves_idr",symbol:"WAVES/IDR",base:"WAVES",quote:"IDR",baseId:"waves",quoteId:"idr",precision:{amount:8,price:0},limits:{amount:{min:.1,max:void 0}}},"XRP/IDR":{id:"xrp_idr",symbol:"XRP/IDR",base:"XRP",quote:"IDR",baseId:"xrp",quoteId:"idr",precision:{amount:8,price:0},limits:{amount:{min:10,max:void 0}}},"XZC/IDR":{id:"xzc_idr",symbol:"XZC/IDR",base:"XZC",quote:"IDR",baseId:"xzc",quoteId:"idr",precision:{amount:8,price:0},limits:{amount:{min:.1,max:void 0}}},"XLM/IDR":{id:"str_idr",symbol:"XLM/IDR",base:"XLM",quote:"IDR",baseId:"str",quoteId:"idr",precision:{amount:8,price:0},limits:{amount:{min:20,max:void 0}}},"BTS/BTC":{id:"bts_btc",symbol:"BTS/BTC",base:"BTS",quote:"BTC",baseId:"bts",quoteId:"btc",precision:{amount:8,price:8},limits:{amount:{min:.01,max:void 0}}},"DASH/BTC":{id:"drk_btc",symbol:"DASH/BTC",base:"DASH",quote:"BTC",baseId:"drk",quoteId:"btc",precision:{amount:8,price:6},limits:{amount:{min:.01,max:void 0}}},"DOGE/BTC":{id:"doge_btc",symbol:"DOGE/BTC",base:"DOGE",quote:"BTC",baseId:"doge",quoteId:"btc",precision:{amount:8,price:8},limits:{amount:{min:1,max:void 0}}},"ETH/BTC":{id:"eth_btc",symbol:"ETH/BTC",base:"ETH",quote:"BTC",baseId:"eth",quoteId:"btc",precision:{amount:8,price:5},limits:{amount:{min:.001,max:void 0}}},"LTC/BTC":{id:"ltc_btc",symbol:"LTC/BTC",base:"LTC",quote:"BTC",baseId:"ltc",quoteId:"btc",precision:{amount:8,price:6},limits:{amount:{min:.01,max:void 0}}},"NXT/BTC":{id:"nxt_btc",symbol:"NXT/BTC",base:"NXT",quote:"BTC",baseId:"nxt",quoteId:"btc",precision:{amount:8,price:8},limits:{amount:{min:.01,max:void 0}}},"TEN/BTC":{id:"ten_btc",symbol:"TEN/BTC",base:"TEN",quote:"BTC",baseId:"ten",quoteId:"btc",precision:{amount:8,price:8},limits:{amount:{min:.01,max:void 0}}},"XLM/BTC":{id:"str_btc",symbol:"XLM/BTC",base:"XLM",quote:"BTC",baseId:"str",quoteId:"btc",precision:{amount:8,price:8},limits:{amount:{min:.01,max:void 0}}},"XEM/BTC":{id:"nem_btc",symbol:"XEM/BTC",base:"XEM",quote:"BTC",baseId:"nem",quoteId:"btc",precision:{amount:8,price:8},limits:{amount:{min:1,max:void 0}}},"XRP/BTC":{id:"xrp_btc",symbol:"XRP/BTC",base:"XRP",quote:"BTC",baseId:"xrp",quoteId:"btc",precision:{amount:8,price:8},limits:{amount:{min:.01,max:void 0}}}},fees:{trading:{tierBased:!1,percentage:!0,maker:0,taker:.003}}})}async fetchBalance(e={}){await this.loadMarkets();let i=(await this.privatePostGetInfo()).return,t={info:i},s=Object.keys(this.currencies);for(let e=0;e<s.length;e++){let r=s[e],a=this.currencies[r].id,o=this.account();o.free=this.safeFloat(i.balance,a,0),o.used=this.safeFloat(i.balance_hold,a,0),o.total=this.sum(o.free,o.used),t[r]=o}return this.parseBalance(t)}async fetchOrderBook(e,i,t={}){await this.loadMarkets();let s=await this.publicGetPairDepth(this.extend({pair:this.marketId(e)},t));return this.parseOrderBook(s,void 0,"buy","sell")}async fetchTicker(e,i={}){await this.loadMarkets();let t=this.market(e),s=(await this.publicGetPairTicker(this.extend({pair:t.id},i))).ticker,r=1e3*this.safeFloat(s,"server_time"),a="vol_"+t.baseId.toLowerCase(),o="vol_"+t.quoteId.toLowerCase(),d=this.safeFloat(s,"last");return{symbol:e,timestamp:r,datetime:this.iso8601(r),high:this.safeFloat(s,"high"),low:this.safeFloat(s,"low"),bid:this.safeFloat(s,"buy"),bidVolume:void 0,ask:this.safeFloat(s,"sell"),askVolume:void 0,vwap:void 0,open:void 0,close:d,last:d,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:parseFloat(s[a]),quoteVolume:parseFloat(s[o]),info:s}}parseTrade(e,i){let t=1e3*parseInt(e.date);return{id:e.tid,info:e,timestamp:t,datetime:this.iso8601(t),symbol:i.symbol,type:void 0,side:e.type,price:this.safeFloat(e,"price"),amount:this.safeFloat(e,"amount")}}async fetchTrades(e,i,t,s={}){await this.loadMarkets();let r=this.market(e),a=await this.publicGetPairTrades(this.extend({pair:r.id},s));return this.parseTrades(a,r,i,t)}parseOrder(e,i){let t=void 0;"type"in e&&(t=e.type);let s=this.safeString(e,"status","open");"filled"===s?s="closed":"calcelled"===s&&(s="canceled");let r=void 0,a=void 0,o=this.safeFloat(e,"price"),d=void 0,n=void 0,m=void 0;if(i){r=i.symbol;let t=i.quoteId,s=i.baseId;if("idr"===i.quoteId&&"order_rp"in e&&(t="rp"),"idr"===i.baseId&&"remain_rp"in e&&(s="rp"),a=this.safeFloat(e,"order_"+t)){d=a/o;let i=this.safeFloat(e,"remain_"+t);void 0!==i&&(m=d-(n=i/o))}else a=o*(d=this.safeFloat(e,"order_"+s)),m=d-(n=this.safeFloat(e,"remain_"+s))}let c=void 0;m&&(c=a/m);let l=parseInt(e.submit_time);return{info:e,id:e.order_id,timestamp:l,datetime:this.iso8601(l),lastTradeTimestamp:void 0,symbol:r,type:"limit",side:t,price:o,cost:a,average:c,amount:d,filled:m,remaining:n,status:s,fee:void 0}}async fetchOrder(e,t,s={}){if(!t)throw new i(this.id+" fetchOrder requires a symbol");await this.loadMarkets();let r=this.market(t),a=await this.privatePostGetOrder(this.extend({pair:r.id,order_id:e},s)),o=a.return,d=this.parseOrder(this.extend({id:e},o.order),r);return this.extend({info:a},d)}async fetchOpenOrders(e,i,t,s={}){await this.loadMarkets();let r=void 0,a={};e&&(r=this.market(e),a.pair=r.id);let o=(await this.privatePostOpenOrders(this.extend(a,s))).return.orders;if(!o)return[];if(void 0!==e)return this.parseOrders(o,r,i,t);let d=Object.keys(o),n=[];for(let e=0;e<d.length;e++){let s=d[e],a=o[s];r=this.markets_by_id[s];let m=this.parseOrders(a,r,i,t);n=this.arrayConcat(n,m)}return n}async fetchClosedOrders(e,t,s,r={}){if(!e)throw new i(this.id+" fetchOrders requires a symbol");await this.loadMarkets();let a={},o=void 0;e&&(o=this.market(e),a.pair=o.id);let d=await this.privatePostOrderHistory(this.extend(a,r)),n=this.parseOrders(d.return.orders,o,t,s);return n=this.filterBy(n,"status","closed"),e?this.filterBySymbol(n,e):n}async createOrder(e,t,s,r,a,o={}){if("limit"!==t)throw new i(this.id+" allows limit orders only");await this.loadMarkets();let d=this.market(e),n={pair:d.id,type:s,price:a},m=d.baseId;"buy"===s?n[d.quoteId]=r*a:n[d.baseId]=r,n[m]=r;let c=await this.privatePostTrade(this.extend(n,o));return{info:c,id:c.return.order_id.toString()}}async cancelOrder(e,t,s={}){if(void 0===t)throw new i(this.id+" cancelOrder requires a symbol argument");if(void 0===this.safeValue(s,"side"))throw new i(this.id+' cancelOrder requires an extra "side" param');await this.loadMarkets();let r=this.market(t);return await this.privatePostCancelOrder(this.extend({order_id:e,pair:r.id,type:s.side},s))}async withdraw(e,i,t,s,r={}){this.checkAddress(t),await this.loadMarkets();let a=this.currency(e),o=this.milliseconds(),d={currency:a.id,withdraw_amount:i,withdraw_address:t,request_id:o.toString()};s&&(d.withdraw_memo=s);let n=await this.privatePostWithdrawCoin(this.extend(d,r)),m=void 0;return"txid"in n&&n.txid.length>0&&(m=n.txid),{info:n,id:m}}sign(e,i="public",t="GET",s={},r,a){let o=this.urls.api[i];return"public"===i?o+="/"+this.implodeParams(e,s):(this.checkRequiredCredentials(),a=this.urlencode(this.extend({method:e,nonce:this.nonce()},s)),r={"Content-Type":"application/x-www-form-urlencoded",Key:this.apiKey,Sign:this.hmac(this.encode(a),this.encode(this.secret),"sha512")}),{url:o,method:t,body:a,headers:r}}handleErrors(e,o,d,n,m,c,l){if("string"!=typeof c)return;if(void 0===l&&("{"!==c[0]&&"["!==c[0]||(l=JSON.parse(c))),Array.isArray(l))return;if(!("success"in l))return;if(1===l.success){if("return"in l)return;throw new i(this.id+": malformed response: "+this.json(l))}let u=l.error,h=this.id+" "+this.json(l);if("Insufficient balance."===u)throw new t(h);if("invalid order."===u)throw new r(h);if(u.indexOf("Minimum price ")>=0)throw new s(h);if(u.indexOf("Minimum order ")>=0)throw new s(h);if("Invalid credentials. API not found or session has expired."===u)throw new a(h);if("Invalid credentials. Bad sign."===u)throw new a(h);throw new i(this.id+": unknown error: "+this.json(l))}};
//# sourceMappingURL=indodax.js.map
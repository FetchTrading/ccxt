"use strict";const e=require("./base/Exchange"),{ExchangeError:t,ExchangeNotAvailable:i,AuthenticationError:s,InvalidNonce:a,InsufficientFunds:o,InvalidOrder:r,OrderNotFound:n,DDoSProtection:d}=require("./base/errors");module.exports=class extends e{describe(){return this.deepExtend(super.describe(),{id:"coinegg",name:"CoinEgg",countries:["CN","UK"],has:{fetchOrder:!0,fetchOrders:!0,fetchOpenOrders:"emulated",fetchMyTrades:!0,fetchTickers:!0},urls:{logo:"https://user-images.githubusercontent.com/1294454/36770310-adfa764e-1c5a-11e8-8e09-449daac3d2fb.jpg",api:{web:"https://www.coinegg.com/coin",rest:"https://api.coinegg.com/api/v1"},www:"https://www.coinegg.com",doc:"https://www.coinegg.com/explain.api.html",fees:"https://www.coinegg.com/fee.html"},api:{web:{get:["{quote}/allcoin","{quote}/trends","{quote}/{base}/order","{quote}/{base}/trades","{quote}/{base}/depth.js"]},public:{get:["ticker/{quote}","depth/{quote}","orders/{quote}"]},private:{post:["balance","trade_add/{quote}","trade_cancel/{quote}","trade_view/{quote}","trade_list/{quote}"]}},fees:{trading:{maker:.001,taker:.001},funding:{withdraw:{BTC:.008,BCH:.002,LTC:.001,ETH:.01,ETC:.01,NEO:0,QTUM:"1%",XRP:"1%",DOGE:"1%",LSK:"1%",XAS:"1%",BTS:"1%",GAME:"1%",GOOC:"1%",NXT:"1%",IFC:"1%",DNC:"1%",BLK:"1%",VRC:"1%",XPM:"1%",VTC:"1%",TFC:"1%",PLC:"1%",EAC:"1%",PPC:"1%",FZ:"1%",ZET:"1%",RSS:"1%",PGC:"1%",SKT:"1%",JBC:"1%",RIO:"1%",LKC:"1%",ZCC:"1%",MCC:"1%",QEC:"1%",MET:"1%",YTC:"1%",HLB:"1%",MRYC:"1%",MTC:"1%",KTC:0}}},exceptions:{103:s,104:s,105:s,106:a,200:o,201:r,202:r,203:n,402:d},errorMessages:{100:"Required parameters can not be empty",101:"Illegal parameter",102:"coin does not exist",103:"Key does not exist",104:"Signature does not match",105:"Insufficient permissions",106:"Request expired(nonce error)",200:"Lack of balance",201:"Too small for the number of trading",202:"Price must be in 0 - 1000000",203:"Order does not exist",204:"Pending order amount must be above 0.001 BTC",205:"Restrict pending order prices",206:"Decimal place error",401:"System error",402:"Requests are too frequent",403:"Non-open API",404:"IP restriction does not request the resource",405:"Currency transactions are temporarily closed"},options:{quoteIds:["btc","eth","usc"]}})}async fetchMarkets(){let e=this.options.quoteIds,t=[];for(let s=0;s<e.length;s++){let a=e[s],o=await this.webGetQuoteAllcoin({quote:a});if(void 0===o)throw new i(this.id+' fetchMarkets() for "'+a+'" returned: "'+this.json(o)+'"');let r=Object.keys(o);if(r.length<1)throw new i(this.id+' fetchMarkets() for "'+a+'" returned: "'+this.json(o)+'"');for(let e=0;e<r.length;e++){let i=r[e],s=o[i],n=i.toUpperCase(),d=a.toUpperCase(),h=i+a,c=(n=this.commonCurrencyCode(n))+"/"+(d=this.commonCurrencyCode(d)),l={amount:8,price:8},u=Math.pow(10,-l.amount);t.push({id:h,symbol:c,base:n,quote:d,baseId:i,quoteId:a,active:!0,lot:u,precision:l,limits:{amount:{min:u,max:Math.pow(10,l.amount)},price:{min:Math.pow(10,-l.price),max:Math.pow(10,l.price)},cost:{min:void 0,max:void 0}},info:s})}}return t}parseTicker(e,t){let i=t.symbol,s=this.milliseconds(),a=this.safeFloat(e,"last");return{symbol:i,timestamp:s,datetime:this.iso8601(s),high:this.safeFloat(e,"high"),low:this.safeFloat(e,"low"),bid:this.safeFloat(e,"buy"),bidVolume:void 0,ask:this.safeFloat(e,"sell"),askVolume:void 0,vwap:void 0,open:void 0,close:a,last:a,previousClose:void 0,change:this.safeFloat(e,"change"),percentage:void 0,average:void 0,baseVolume:this.safeFloat(e,"vol"),quoteVolume:this.safeFloat(e,"quoteVol"),info:e}}async fetchTicker(e,t={}){await this.loadMarkets();let i=this.market(e),s=await this.publicGetTickerQuote(this.extend({coin:i.baseId,quote:i.quoteId},t));return this.parseTicker(s,i)}async fetchTickers(e,i={}){await this.loadMarkets();let s=this.options.quoteIds,a={};for(let e=0;e<s.length;e++){let i=s[e],o=await this.webGetQuoteAllcoin({quote:i}),r=Object.keys(o);if(!r.length)throw new t("fetchTickers failed");for(let e=0;e<r.length;e++){let t=r[e],s=o[t],n=t+i;if(n in this.markets_by_id){let e=this.marketsById[n];a[e.symbol]=this.parseTicker({high:s[4],low:s[5],buy:s[2],sell:s[3],last:s[1],change:s[8],vol:s[6],quoteVol:s[7]},e)}}}return a}async fetchOrderBook(e,t,i={}){await this.loadMarkets();let s=this.market(e),a=await this.publicGetDepthQuote(this.extend({coin:s.baseId,quote:s.quoteId},i));return this.parseOrderBook(a)}parseTrade(e,t){let i=1e3*parseInt(e.date),s=this.safeFloat(e,"price"),a=this.safeFloat(e,"amount"),o=t.symbol,r=this.costToPrecision(o,s*a);return{timestamp:i,datetime:this.iso8601(i),symbol:o,id:this.safeString(e,"tid"),order:void 0,type:"limit",side:e.type,price:s,amount:a,cost:r,fee:void 0,info:e}}async fetchTrades(e,t,i,s={}){await this.loadMarkets();let a=this.market(e),o=await this.publicGetOrdersQuote(this.extend({coin:a.baseId,quote:a.quoteId},s));return this.parseTrades(o,a,t,i)}async fetchBalance(e={}){await this.loadMarkets();let t=await this.privatePostBalance(e),i={},s=this.omit(t.data,"uid"),a=Object.keys(s);for(let e=0;e<a.length;e++){let t=a[e],[o,r]=t.split("_"),n=o;o in this.currencies_by_id&&(n=this.currencies_by_id[o].code),n in i||(i[n]={free:void 0,used:void 0,total:void 0}),r="lock"===r?"used":"free",i[n][r]=parseFloat(s[t])}let o=Object.keys(i);for(let e=0;e<o.length;e++){let t=o[e];i[t].total=this.sum(i[t].free,i[t].used)}return this.parseBalance(this.extend({info:t},i))}parseOrder(e,t){let i=t.symbol,s=this.parse8601(e.datetime),a=this.safeFloat(e,"price"),o=this.safeFloat(e,"amount_original"),r=this.safeFloat(e,"amount_outstanding"),n=o-r,d=this.safeString(e,"status");d="cancelled"===d?"canceled":r?"open":"closed";let h=this.safeValue(e,"info",e);return{id:this.safeString(e,"id"),datetime:this.iso8601(s),timestamp:s,lastTradeTimestamp:void 0,status:d,symbol:i,type:"limit",side:e.type,price:a,cost:void 0,amount:o,filled:n,remaining:r,trades:void 0,fee:void 0,info:h}}async createOrder(e,t,i,s,a,o={}){await this.loadMarkets();let r=this.market(e),n=await this.privatePostTradeAddQuote(this.extend({coin:r.baseId,quote:r.quoteId,type:i,amount:s,price:a},o)),d=n.id.toString(),h=this.parseOrder({id:d,datetime:this.ymdhms(this.milliseconds()),amount_original:s,amount_outstanding:s,price:a,type:i,info:n},r);return this.orders[d]=h,h}async cancelOrder(e,t,i={}){await this.loadMarkets();let s=this.market(t);return await this.privatePostTradeCancelQuote(this.extend({id:e,coin:s.baseId,quote:s.quoteId},i))}async fetchOrder(e,t,i={}){await this.loadMarkets();let s=this.market(t),a=await this.privatePostTradeViewQuote(this.extend({id:e,coin:s.baseId,quote:s.quoteId},i));return this.parseOrder(a.data,s)}async fetchOrders(e,t,i,s={}){await this.loadMarkets();let a=this.market(e),o={coin:a.baseId,quote:a.quoteId};void 0!==t&&(o.since=t/1e3);let r=await this.privatePostTradeListQuote(this.extend(o,s));return this.parseOrders(r.data,a,t,i)}async fetchOpenOrders(e,t,i,s={}){return await this.fetchOrders(e,t,i,this.extend({type:"open"},s))}nonce(){return this.milliseconds()}sign(e,t="public",i="GET",s={},a,o){let r="rest";"web"===t&&(r=t);let n=this.urls.api[r]+"/"+this.implodeParams(e,s),d=this.omit(s,this.extractParams(e));if("public"===t||"web"===t)"web"===t&&(d.t=this.nonce()),Object.keys(d).length&&(n+="?"+this.urlencode(d));else{this.checkRequiredCredentials(),d=this.urlencode(this.extend({key:this.apiKey,nonce:this.nonce()},d));let e=this.hash(this.encode(this.secret));d+="&signature="+this.hmac(this.encode(d),this.encode(e)),"GET"===i?n+="?"+d:(a={"Content-type":"application/x-www-form-urlencoded"},o=d)}return{url:n,method:i,body:o,headers:a}}handleErrors(e,i,s,a,o,r){if("string"!=typeof r)return;if(0===r.length)return;if("{"!==r[0])return;let n=JSON.parse(r),d=this.safeValue(n,"result");if(void 0===d)return;if(!0===d)return;const h=this.safeString(n,"code"),c=this.errorMessages,l=this.safeString(c,h,"Unknown Error");throw h in this.exceptions?new this.exceptions[h](this.id+" "+l):new t(this.id+" "+l)}};
//# sourceMappingURL=coinegg.js.map
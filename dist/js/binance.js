"use strict";const e=require("./base/Exchange"),{ExchangeError:t,ExchangeNotAvailable:i,InsufficientFunds:s,OrderNotFound:r,InvalidOrder:a,DDoSProtection:o,InvalidNonce:n,AuthenticationError:c}=require("./base/errors");module.exports=class extends e{describe(){return this.deepExtend(super.describe(),{id:"binance",name:"Binance",countries:"JP",rateLimit:500,has:{fetchDepositAddress:!0,CORS:!1,fetchBidsAsks:!0,fetchTickers:!0,fetchOHLCV:!0,fetchMyTrades:!0,fetchOrder:!0,fetchOrders:!0,fetchOpenOrders:!0,fetchClosedOrders:!0,withdraw:!0,fetchFundingFees:!0},timeframes:{"1m":"1m","3m":"3m","5m":"5m","15m":"15m","30m":"30m","1h":"1h","2h":"2h","4h":"4h","6h":"6h","8h":"8h","12h":"12h","1d":"1d","3d":"3d","1w":"1w","1M":"1M"},urls:{logo:"https://user-images.githubusercontent.com/1294454/29604020-d5483cdc-87ee-11e7-94c7-d1a8d9169293.jpg",api:{web:"https://www.binance.com",wapi:"https://api.binance.com/wapi/v3",public:"https://api.binance.com/api/v1",private:"https://api.binance.com/api/v3",v3:"https://api.binance.com/api/v3",v1:"https://api.binance.com/api/v1"},www:"https://www.binance.com",referral:"https://www.binance.com/?ref=10205187",doc:"https://github.com/binance-exchange/binance-official-api-docs/blob/master/rest-api.md",fees:["https://binance.zendesk.com/hc/en-us/articles/115000429332","https://support.binance.com/hc/en-us/articles/115000583311"]},api:{web:{get:["exchange/public/product"]},wapi:{post:["withdraw"],get:["depositHistory","withdrawHistory","depositAddress","accountStatus","systemStatus","withdrawFee"]},v3:{get:["ticker/price","ticker/bookTicker"]},public:{get:["exchangeInfo","ping","time","depth","aggTrades","klines","ticker/24hr","ticker/allPrices","ticker/allBookTickers","ticker/price","ticker/bookTicker","exchangeInfo"],put:["userDataStream"],post:["userDataStream"],delete:["userDataStream"]},private:{get:["order","openOrders","allOrders","account","myTrades"],post:["order","order/test"],delete:["order"]}},fees:{trading:{tierBased:!1,percentage:!0,taker:.001,maker:.001},funding:{tierBased:!1,percentage:!1,withdraw:{ADA:1,ADX:4.7,AION:1.9,AMB:11.4,APPC:6.5,ARK:.1,ARN:3.1,AST:10,BAT:18,BCD:1,BCH:.001,BCPT:10.2,BCX:1,BNB:.7,BNT:1.5,BQX:1.6,BRD:6.4,BTC:.001,BTG:.001,BTM:5,BTS:1,CDT:67,CMT:37,CND:47,CTR:5.4,DASH:.002,DGD:.06,DLT:11.7,DNT:51,EDO:2.5,ELF:6.5,ENG:2.1,ENJ:42,EOS:1,ETC:.01,ETF:1,ETH:.01,EVX:2.5,FUEL:45,FUN:85,GAS:0,GTO:20,GVT:.53,GXS:.3,HCC:5e-4,HSR:1e-4,ICN:3.5,ICX:1.3,INS:1.5,IOTA:.5,KMD:.002,KNC:2.6,LEND:54,LINK:12.8,LLT:54,LRC:9.1,LSK:.1,LTC:.01,LUN:.29,MANA:74,MCO:.86,MDA:4.7,MOD:2,MTH:34,MTL:1.9,NAV:.2,NEBL:.01,NEO:0,NULS:2.1,OAX:8.3,OMG:.57,OST:17,POE:88,POWR:8.6,PPT:.25,QSP:21,QTUM:.01,RCN:35,RDN:2.2,REQ:18.1,RLC:4.1,SALT:1.3,SBTC:1,SNGLS:42,SNM:29,SNT:32,STORJ:5.9,STRAT:.1,SUB:7.4,TNB:82,TNT:47,TRIG:6.7,TRX:129,USDT:23,VEN:1.8,VIB:28,VIBE:7.2,WABI:3.5,WAVES:.002,WINGS:9.3,WTC:.5,XLM:.01,XMR:.04,XRP:.25,XVG:.1,XZC:.02,YOYOW:39,ZEC:.005,ZRX:5.7},deposit:{}}},commonCurrencies:{YOYO:"YOYOW",BCC:"BCH",NANO:"XRB"},options:{defaultTimeInForce:"GTC",defaultLimitOrderType:"limit",hasAlreadyAuthenticatedSuccessfully:!1,warnOnFetchOpenOrdersWithoutSymbol:!0,recvWindow:5e3,timeDifference:0,adjustForTimeDifference:!1},exceptions:{"-1000":i,"-1013":a,"-1021":n,"-1100":a,"-2010":s,"-2011":r,"-2013":r,"-2014":c,"-2015":c}})}nonce(){return this.milliseconds()-this.options.timeDifference}async loadTimeDifference(){const e=await this.publicGetTime(),t=this.milliseconds();return this.options.timeDifference=parseInt(t-e.serverTime),this.options.timeDifference}async fetchMarkets(){let e=await this.publicGetExchangeInfo();this.options.adjustForTimeDifference&&await this.loadTimeDifference();let t=e.symbols,i=[];for(let e=0;e<t.length;e++){let s=t[e],r=s.symbol;if("123456"===r)continue;let a=s.baseAsset,o=s.quoteAsset,n=this.commonCurrencyCode(a),c=this.commonCurrencyCode(o),h=n+"/"+c,d=this.indexBy(s.filters,"filterType"),l={base:s.baseAssetPrecision,quote:s.quotePrecision,amount:s.baseAssetPrecision,price:s.quotePrecision},p="TRADING"===s.status,m=-1*Math.log10(l.amount),u={id:r,symbol:h,base:n,quote:c,baseId:a,quoteId:o,info:s,lot:m,active:p,precision:l,limits:{amount:{min:Math.pow(10,-l.amount),max:void 0},price:{min:Math.pow(10,-l.price),max:void 0},cost:{min:m,max:void 0}}};if("PRICE_FILTER"in d){let e=d.PRICE_FILTER;u.precision.price=this.precisionFromString(e.tickSize),u.limits.price={min:this.safeFloat(e,"minPrice"),max:this.safeFloat(e,"maxPrice")}}if("LOT_SIZE"in d){let e=d.LOT_SIZE;u.precision.amount=this.precisionFromString(e.stepSize),u.lot=this.safeFloat(e,"stepSize"),u.limits.amount={min:this.safeFloat(e,"minQty"),max:this.safeFloat(e,"maxQty")}}"MIN_NOTIONAL"in d&&(u.limits.cost.min=parseFloat(d.MIN_NOTIONAL.minNotional)),i.push(u)}return i}calculateFee(e,t,i,s,r,a="taker",o={}){let n=this.markets[e],c="quote",h=n[a],d=parseFloat(this.costToPrecision(e,s*h));return"sell"===i?d*=r:c="base",{type:a,currency:n[c],rate:h,cost:parseFloat(this.feeToPrecision(e,d))}}async fetchBalance(e={}){await this.loadMarkets();let t=await this.privateGetAccount(e),i={info:t},s=t.balances;for(let e=0;e<s.length;e++){let t=s[e],r=t.asset;r in this.currencies_by_id&&(r=this.currencies_by_id[r].code);let a={free:parseFloat(t.free),used:parseFloat(t.locked),total:0};a.total=this.sum(a.free,a.used),i[r]=a}return this.parseBalance(i)}async fetchOrderBook(e,t,i={}){await this.loadMarkets();let s={symbol:this.market(e).id};void 0!==t&&(s.limit=t);let r=await this.publicGetDepth(this.extend(s,i)),a=this.parseOrderBook(r);return a.nonce=this.safeInteger(r,"lastUpdateId"),a}parseTicker(e,t){let i=this.safeInteger(e,"closeTime"),s=void 0===i?void 0:this.iso8601(i),r=this.findSymbol(this.safeString(e,"symbol"),t),a=this.safeFloat(e,"lastPrice");return{symbol:r,timestamp:i,datetime:s,high:this.safeFloat(e,"highPrice"),low:this.safeFloat(e,"lowPrice"),bid:this.safeFloat(e,"bidPrice"),bidVolume:this.safeFloat(e,"bidQty"),ask:this.safeFloat(e,"askPrice"),askVolume:this.safeFloat(e,"askQty"),vwap:this.safeFloat(e,"weightedAvgPrice"),open:this.safeFloat(e,"openPrice"),close:a,last:a,previousClose:this.safeFloat(e,"prevClosePrice"),change:this.safeFloat(e,"priceChange"),percentage:this.safeFloat(e,"priceChangePercent"),average:void 0,baseVolume:this.safeFloat(e,"volume"),quoteVolume:this.safeFloat(e,"quoteVolume"),info:e}}async fetchTicker(e,t={}){await this.loadMarkets();let i=this.market(e),s=await this.publicGetTicker24hr(this.extend({symbol:i.id},t));return this.parseTicker(s,i)}parseTickers(e,t){let i=[];for(let t=0;t<e.length;t++)i.push(this.parseTicker(e[t]));return this.filterByArray(i,"symbol",t)}async fetchBidsAsks(e,t={}){await this.loadMarkets();let i=await this.publicGetTickerBookTicker(t);return this.parseTickers(i,e)}async fetchTickers(e,t={}){await this.loadMarkets();let i=await this.publicGetTicker24hr(t);return this.parseTickers(i,e)}parseOHLCV(e,t,i="1m",s,r){return[e[0],parseFloat(e[1]),parseFloat(e[2]),parseFloat(e[3]),parseFloat(e[4]),parseFloat(e[5])]}async fetchOHLCV(e,t="1m",i,s,r={}){await this.loadMarkets();let a=this.market(e),o={symbol:a.id,interval:this.timeframes[t]};void 0!==i&&(o.startTime=i),void 0!==s&&(o.limit=s);let n=await this.publicGetKlines(this.extend(o,r));return this.parseOHLCVs(n,a,t,i,s)}parseTrade(e,t){let i=e["T"in e?"T":"time"],s=parseFloat(e["p"in e?"p":"price"]),r=parseFloat(e["q"in e?"q":"qty"]),a=e["a"in e?"a":"id"].toString(),o=void 0,n=void 0;"orderId"in e&&(n=e.orderId.toString()),o="m"in e?e.m?"sell":"buy":e.isBuyer?"buy":"sell";let c=void 0;"commission"in e&&(c={cost:this.safeFloat(e,"commission"),currency:this.commonCurrencyCode(e.commissionAsset)});let h=void 0;return"isMaker"in e&&(h=e.isMaker?"maker":"taker"),{info:e,timestamp:i,datetime:this.iso8601(i),symbol:t.symbol,id:a,order:n,type:void 0,takerOrMaker:h,side:o,price:s,cost:s*r,amount:r,fee:c}}async fetchTrades(e,t,i,s={}){await this.loadMarkets();let r=this.market(e),a={symbol:r.id};void 0!==t&&(a.startTime=t,a.endTime=t+36e5),void 0!==i&&(a.limit=i);let o=await this.publicGetAggTrades(this.extend(a,s));return this.parseTrades(o,r,t,i)}parseOrderStatus(e){let t={NEW:"open",PARTIALLY_FILLED:"open",FILLED:"closed",CANCELED:"canceled"};return e in t?t[e]:e.toLowerCase()}parseOrder(e,t){let i=this.safeValue(e,"status");void 0!==i&&(i=this.parseOrderStatus(i));let s=this.findSymbol(this.safeString(e,"symbol"),t),r=void 0;"time"in e?r=e.time:"transactTime"in e&&(r=e.transactTime);let a=void 0;void 0!==r&&(a=this.iso8601(r));let o=this.safeFloat(e,"price"),n=this.safeFloat(e,"origQty"),c=this.safeFloat(e,"executedQty"),h=void 0,d=void 0;void 0!==c&&(void 0!==n&&(h=Math.max(n-c,0)),void 0!==o&&(d=o*c));let l=this.safeString(e,"orderId"),p=this.safeString(e,"type");void 0!==p&&(p=p.toLowerCase());let m=this.safeString(e,"side");return void 0!==m&&(m=m.toLowerCase()),{info:e,id:l,timestamp:r,datetime:a,lastTradeTimestamp:void 0,symbol:s,type:p,side:m,price:o,amount:n,cost:d,filled:c,remaining:h,status:i,fee:void 0}}async createOrder(e,t,i,s,r,o={}){await this.loadMarkets();let n=this.market(e),c="privatePostOrder";this.safeValue(o,"test",!1)&&(c+="Test",o=this.omit(o,"test"));let h=t.toUpperCase(),d={symbol:n.id,quantity:this.amountToString(e,s),type:h,side:i.toUpperCase()},l=!1,p=!1,m=!1;if("LIMIT"===h?(p=!0,l=!0):"STOP_LOSS"===h||"TAKE_PROFIT"===h?m=!0:"STOP_LOSS_LIMIT"===h||"TAKE_PROFIT_LIMIT"===h?(m=!0,p=!0,l=!0):"LIMIT_MAKER"===h&&(p=!0),p){if(void 0===r)throw new a(this.id+" createOrder method requires a price argument for a "+t+" order");d.price=this.priceToPrecision(e,r)}if(l&&(d.timeInForce=this.options.defaultTimeInForce),m){let i=this.safeFloat(o,"stopPrice");if(void 0===i)throw new a(this.id+" createOrder method requires a stopPrice extra param for a "+t+" order");d.stopPrice=this.priceToPrecision(e,i)}let u=await this[c](this.extend(d,o));return this.parseOrder(u)}async fetchOrder(e,i,s={}){if(!i)throw new t(this.id+" fetchOrder requires a symbol param");await this.loadMarkets();let r=this.market(i),a=this.safeValue(s,"origClientOrderId"),o={symbol:r.id};void 0!==a?o.origClientOrderId=a:o.orderId=parseInt(e);let n=await this.privateGetOrder(this.extend(o,s));return this.parseOrder(n,r)}async fetchOrders(e,i,s,r={}){if(!e)throw new t(this.id+" fetchOrders requires a symbol param");await this.loadMarkets();let a=this.market(e),o={symbol:a.id};s&&(o.limit=s);let n=await this.privateGetAllOrders(this.extend(o,r));return this.parseOrders(n,a,i,s)}async fetchOpenOrders(e,i,s,r={}){await this.loadMarkets();let a=void 0,o={};if(void 0!==e)a=this.market(e),o.symbol=a.id;else if(this.options.warnOnFetchOpenOrdersWithoutSymbol){let e=this.symbols.length,i=parseInt(e/2);throw new t(this.id+" fetchOpenOrders WARNING: fetching open orders without specifying a symbol is rate-limited to one call per "+i.toString()+" seconds. Do not call this method frequently to avoid ban. Set "+this.id+'.options["warnOnFetchOpenOrdersWithoutSymbol"] = false to suppress this warning message.')}let n=await this.privateGetOpenOrders(this.extend(o,r));return this.parseOrders(n,a,i,s)}async fetchClosedOrders(e,t,i,s={}){let r=await this.fetchOrders(e,t,i,s);return this.filterBy(r,"status","closed")}async cancelOrder(e,i,s={}){if(!i)throw new t(this.id+" cancelOrder requires a symbol argument");await this.loadMarkets();let r=this.market(i),a=await this.privateDeleteOrder(this.extend({symbol:r.id,orderId:parseInt(e)},s));return this.parseOrder(a)}async fetchMyTrades(e,i,s,r={}){if(!e)throw new t(this.id+" fetchMyTrades requires a symbol argument");await this.loadMarkets();let a=this.market(e),o={symbol:a.id};s&&(o.limit=s);let n=await this.privateGetMyTrades(this.extend(o,r));return this.parseTrades(n,a,i,s)}async fetchDepositAddress(e,t={}){await this.loadMarkets();let i=this.currency(e),s=await this.wapiGetDepositAddress(this.extend({asset:i.id},t));if("success"in s&&s.success){let t=this.safeString(s,"address"),i=this.safeString(s,"addressTag");return{currency:e,address:this.checkAddress(t),tag:i,status:"ok",info:s}}}async fetchFundingFees(e,t={}){await this.loadMarkets();let i={},s={};void 0===e&&(e=Object.keys(this.currencies));for(let t=0;t<e.length;t++){let r=e[t],a=this.currency(r),o=await this.wapiGetWithdrawFee({asset:a.id});i[r]=this.safeFloat(o,"withdrawFee"),s[r]=o}return{withdraw:i,deposit:{},info:s}}async withdraw(e,t,i,s,r={}){this.checkAddress(i),await this.loadMarkets();let a=this.currency(e),o=i.slice(0,20),n={asset:a.id,address:i,amount:parseFloat(t),name:o};s&&(n.addressTag=s);let c=await this.wapiPostWithdraw(this.extend(n,r));return{info:c,id:this.safeString(c,"id")}}sign(e,t="public",i="GET",s={},r,a){let o=this.urls.api[t];if(o+="/"+e,"wapi"===t&&(o+=".html"),"userDataStream"===e)a=this.urlencode(s),r={"X-MBX-APIKEY":this.apiKey,"Content-Type":"application/x-www-form-urlencoded"};else if("private"===t||"wapi"===t){this.checkRequiredCredentials();let e=this.urlencode(this.extend({timestamp:this.nonce(),recvWindow:this.options.recvWindow},s));e+="&signature="+this.hmac(this.encode(e),this.encode(this.secret)),r={"X-MBX-APIKEY":this.apiKey},"GET"===i||"wapi"===t?o+="?"+e:(a=e,r["Content-Type"]="application/x-www-form-urlencoded")}else Object.keys(s).length&&(o+="?"+this.urlencode(s));return{url:o,method:i,body:a,headers:r}}handleErrors(e,i,s,r,n,c){if(418===e||429===e)throw new o(this.id+" "+e.toString()+" "+i+" "+c);if(e>=400){if(c.indexOf("Price * QTY is zero or less")>=0)throw new a(this.id+" order cost = amount * price is zero or less "+c);if(c.indexOf("LOT_SIZE")>=0)throw new a(this.id+" order amount should be evenly divisible by lot size, use this.amountToLots (symbol, amount) "+c);if(c.indexOf("PRICE_FILTER")>=0)throw new a(this.id+" order price exceeds allowed price precision or invalid, use this.priceToPrecision (symbol, amount) "+c)}if(c.length>0&&"{"===c[0]){let e=JSON.parse(c),i=this.safeValue(e,"success",!0);if(!i&&"msg"in e)try{e=JSON.parse(e.msg)}catch(t){e={}}let s=this.safeString(e,"code");if(void 0!==s){const i=this.exceptions;if(s in i){if("-2015"===s&&this.options.hasAlreadyAuthenticatedSuccessfully)throw new o(this.id+" temporary banned: "+c);if("Order would trigger immediately."===this.safeString(e,"msg"))throw new a(this.id+" "+c);throw new i[s](this.id+" "+c)}throw new t(this.id+": unknown error code: "+c+" "+s)}if(!i)throw new t(this.id+": success value false: "+c)}}async request(e,t="public",i="GET",s={},r,a){let o=await this.fetch2(e,t,i,s,r,a);return"private"!==t&&"wapi"!==t||(this.options.hasAlreadyAuthenticatedSuccessfully=!0),o}};
//# sourceMappingURL=binance.js.map
"use strict";const e=require("./base/Exchange"),{NotSupported:t,DDoSProtection:i,AuthenticationError:s,ExchangeError:r,ExchangeNotAvailable:a,InsufficientFunds:o,InvalidOrder:n,OrderNotFound:d,InvalidNonce:c}=require("./base/errors"),{ROUND:l,TRUNCATE:h,SIGNIFICANT_DIGITS:m}=require("./base/functions/number");module.exports=class extends e{describe(){return this.deepExtend(super.describe(),{id:"bitfinex",name:"Bitfinex",countries:"VG",version:"v1",rateLimit:1500,has:{CORS:!1,createDepositAddress:!0,deposit:!0,fetchClosedOrders:!0,fetchDepositAddress:!0,fetchTradingFees:!0,fetchFundingFees:!0,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenOrders:!0,fetchOrder:!0,fetchTickers:!0,withdraw:!0},timeframes:{"1m":"1m","5m":"5m","15m":"15m","30m":"30m","1h":"1h","3h":"3h","6h":"6h","12h":"12h","1d":"1D","1w":"7D","2w":"14D","1M":"1M"},urls:{logo:"https://user-images.githubusercontent.com/1294454/27766244-e328a50c-5ed2-11e7-947b-041416579bb3.jpg",api:"https://api.bitfinex.com",www:"https://www.bitfinex.com",doc:["https://bitfinex.readme.io/v1/docs","https://github.com/bitfinexcom/bitfinex-api-node"]},api:{v2:{get:["candles/trade:{timeframe}:{symbol}/{section}","candles/trade:{timeframe}:{symbol}/last","candles/trade:{timeframe}:{symbol}/hist"]},public:{get:["book/{symbol}","lendbook/{currency}","lends/{currency}","pubticker/{symbol}","stats/{symbol}","symbols","symbols_details","tickers","today","trades/{symbol}"]},private:{post:["account_fees","account_infos","balances","basket_manage","credits","deposit/new","funding/close","history","history/movements","key_info","margin_infos","mytrades","mytrades_funding","offer/cancel","offer/new","offer/status","offers","offers/hist","order/cancel","order/cancel/all","order/cancel/multi","order/cancel/replace","order/new","order/new/multi","order/status","orders","orders/hist","position/claim","position/close","positions","summary","taken_funds","total_taken_funds","transfer","unused_taken_funds","withdraw"]}},fees:{trading:{tierBased:!0,percentage:!0,maker:.001,taker:.002,tiers:{taker:[[0,.002],[5e5,.002],[1e6,.002],[25e5,.002],[5e6,.002],[75e5,.002],[1e7,.0018],[15e6,.0016],[2e7,.14/100],[25e6,.0012],[3e7,.001]],maker:[[0,.001],[5e5,8e-4],[1e6,6e-4],[25e5,4e-4],[5e6,2e-4],[75e5,0],[1e7,0],[15e6,0],[2e7,0],[25e6,0],[3e7,0]]}},funding:{tierBased:!1,percentage:!1,deposit:{BTC:4e-4,IOTA:.5,ETH:.0027,BCH:1e-4,LTC:.001,EOS:.24279,XMR:.04,SAN:.99269,DASH:.01,ETC:.01,XRP:.02,YYW:16.915,NEO:0,ZEC:.001,BTG:0,OMG:.14026,DATA:20.773,QASH:1.9858,ETP:.01,QTUM:.01,EDO:.95001,AVT:1.3045,USDT:0,TRX:28.184,ZRX:1.9947,RCN:10.793,TNB:31.915,SNT:14.976,RLC:1.414,GNT:5.8952,SPK:10.893,REP:.041168,BAT:6.1546,ELF:1.8753,FUN:32.336,SNG:18.622,AID:8.08,MNA:16.617,NEC:1.6504},withdraw:{BTC:4e-4,IOTA:.5,ETH:.0027,BCH:1e-4,LTC:.001,EOS:.24279,XMR:.04,SAN:.99269,DASH:.01,ETC:.01,XRP:.02,YYW:16.915,NEO:0,ZEC:.001,BTG:0,OMG:.14026,DATA:20.773,QASH:1.9858,ETP:.01,QTUM:.01,EDO:.95001,AVT:1.3045,USDT:20,TRX:28.184,ZRX:1.9947,RCN:10.793,TNB:31.915,SNT:14.976,RLC:1.414,GNT:5.8952,SPK:10.893,REP:.041168,BAT:6.1546,ELF:1.8753,FUN:32.336,SNG:18.622,AID:8.08,MNA:16.617,NEC:1.6504}}},commonCurrencies:{BCC:"CST_BCC",BCU:"CST_BCU",DAT:"DATA",DSH:"DASH",IOS:"IOST",IOT:"IOTA",MNA:"MANA",QSH:"QASH",QTM:"QTUM",SNG:"SNGLS",SPK:"SPANK",STJ:"STORJ",YYW:"YOYOW",USD:"USDT"},exceptions:{exact:{temporarily_unavailable:a,"Order could not be cancelled.":d,"No such order found.":d,"Order price must be positive.":n,"Could not find a key matching the given X-BFX-APIKEY.":s,"This API key does not have permission for this action":s,'Key price should be a decimal number, e.g. "123.456"':n,'Key amount should be a decimal number, e.g. "123.456"':n,ERR_RATE_LIMIT:i,"Nonce is too small.":c},broad:{"Invalid order: not enough exchange balance for ":o,"Invalid order: minimum size for ":n,"Invalid order":n,"The available balance is only":o}},precisionMode:m})}async fetchFundingFees(e={}){await this.loadMarkets();const t=await this.privatePostAccountFees(e),i=t.withdraw,s={},r=Object.keys(i);for(let e=0;e<r.length;e++){const t=r[e];let a=t;if(t in this.currencies_by_id){a=this.currencies_by_id[t].code}s[a]=this.safeFloat(i,t)}return{info:t,withdraw:s,deposit:s}}async fetchTradingFees(e={}){await this.loadMarkets();let t=await this.privatePostSummary(e);return{info:t,maker:this.safeFloat(t,"maker_fee"),taker:this.safeFloat(t,"taker_fee")}}async fetchMarkets(){let e=await this.publicGetSymbolsDetails(),t=[];for(let i=0;i<e.length;i++){let s=e[i],r=s.pair.toUpperCase(),a=r.slice(0,3),o=r.slice(3,6),n=this.commonCurrencyCode(a),d=this.commonCurrencyCode(o),c=n+"/"+d,l={price:s.price_precision,amount:s.price_precision},h={amount:{min:this.safeFloat(s,"minimum_order_size"),max:this.safeFloat(s,"maximum_order_size")},price:{min:Math.pow(10,-l.price),max:Math.pow(10,l.price)}};h.cost={min:h.amount.min*h.price.min,max:void 0},t.push({id:r,symbol:c,base:n,quote:d,baseId:a,quoteId:o,active:!0,precision:l,limits:h,info:s})}return t}costToPrecision(e,t){return this.decimalToPrecision(t,l,this.markets[e].precision.price,this.precisionMode)}priceToPrecision(e,t){return this.decimalToPrecision(t,l,this.markets[e].precision.price,this.precisionMode)}amountToPrecision(e,t){return this.decimalToPrecision(t,h,this.markets[e].precision.amount,this.precisionMode)}feeToPrecision(e,t){return this.decimalToPrecision(t,l,this.currencies[e].precision,this.precisionMode)}calculateFee(e,t,i,s,r,a="taker",o={}){let n=this.markets[e],d=n[a],c=s*d,l="quote";return"sell"===i?c*=r:l="base",{type:a,currency:n[l],rate:d,cost:parseFloat(this.feeToPrecision(n[l],c))}}async fetchBalance(e={}){await this.loadMarkets();let t=this.safeString(e,"type","exchange"),i=await this.privatePostBalances(),s={info:i};for(let e=0;e<i.length;e++){let r=i[e];if(r.type===t){let e=r.currency.toUpperCase();e=this.commonCurrencyCode(e);let t=this.account();t.free=parseFloat(r.available),t.total=parseFloat(r.amount),t.used=t.total-t.free,s[e]=t}}return this.parseBalance(s)}async fetchOrderBook(e,t,i={}){await this.loadMarkets();let s={symbol:this.marketId(e)};void 0!==t&&(s.limit_bids=t,s.limit_asks=t);let r=await this.publicGetBookSymbol(this.extend(s,i));return this.parseOrderBook(r,void 0,"bids","asks","price","amount")}async fetchTickers(e,t={}){await this.loadMarkets();let i=await this.publicGetTickers(t),s={};for(let e=0;e<i.length;e++){let t=i[e],r=this.parseTicker(t);s[r.symbol]=r}return s}async fetchTicker(e,t={}){await this.loadMarkets();let i=this.market(e),s=await this.publicGetPubtickerSymbol(this.extend({symbol:i.id},t));return this.parseTicker(s,i)}parseTicker(e,t){let i=1e3*this.safeFloat(e,"timestamp"),s=void 0;if(void 0!==t)s=t.symbol;else if("pair"in e){let i=e.pair;if(i in this.markets_by_id&&(t=this.markets_by_id[i]),void 0!==t)s=t.symbol;else{let e=i.slice(0,3),t=i.slice(3,6);s=this.commonCurrencyCode(e)+"/"+this.commonCurrencyCode(t)}}let r=this.safeFloat(e,"last_price");return{symbol:s,timestamp:i,datetime:this.iso8601(i),high:this.safeFloat(e,"high"),low:this.safeFloat(e,"low"),bid:this.safeFloat(e,"bid"),bidVolume:void 0,ask:this.safeFloat(e,"ask"),askVolume:void 0,vwap:void 0,open:void 0,close:r,last:r,previousClose:void 0,change:void 0,percentage:void 0,average:this.safeFloat(e,"mid"),baseVolume:this.safeFloat(e,"volume"),quoteVolume:void 0,info:e}}parseTrade(e,t){let i=1e3*parseInt(parseFloat(e.timestamp)),s=e.type.toLowerCase(),r=this.safeString(e,"order_id"),a=this.safeFloat(e,"price"),o=this.safeFloat(e,"amount"),n=a*o,d=void 0;if("fee_amount"in e){let t=-this.safeFloat(e,"fee_amount"),i=this.safeString(e,"fee_currency");i in this.currencies_by_id&&(i=this.currencies_by_id[i].code),d={cost:t,currency:i}}return{id:e.tid.toString(),info:e,timestamp:i,datetime:this.iso8601(i),symbol:t.symbol,type:void 0,order:r,side:s,price:a,amount:o,cost:n,fee:d}}async fetchTrades(e,t,i=50,s={}){await this.loadMarkets();let r=this.market(e),a={symbol:r.id,limit_trades:i};void 0!==t&&(a.timestamp=parseInt(t/1e3));let o=await this.publicGetTradesSymbol(this.extend(a,s));return this.parseTrades(o,r,t,i)}async fetchMyTrades(e,t,i,s={}){await this.loadMarkets();let r=this.market(e),a={symbol:r.id};void 0!==i&&(a.limit_trades=i),void 0!==t&&(a.timestamp=parseInt(t/1e3));let o=await this.privatePostMytrades(this.extend(a,s));return this.parseTrades(o,r,t,i)}async createOrder(e,t,i,s,r,a={}){await this.loadMarkets();let o=t;"limit"!==t&&"market"!==t||(o="exchange "+t),s=this.amountToPrecision(e,s);let n={symbol:this.marketId(e),amount:s,side:i,type:o,ocoorder:!1,buy_price_oco:0,sell_price_oco:0};n.price="market"===t?this.nonce().toString():this.priceToPrecision(e,r);let d=await this.privatePostOrderNew(this.extend(n,a));return this.parseOrder(d)}async cancelOrder(e,t,i={}){return await this.loadMarkets(),await this.privatePostOrderCancel({order_id:parseInt(e)})}parseOrder(e,t){let i=e.side,s=e.is_live,r=e.is_cancelled,a=void 0;a=s?"open":r?"canceled":"closed";let o=void 0;if(!t){let i=e.symbol.toUpperCase();i in this.markets_by_id&&(t=this.markets_by_id[i])}t&&(o=t.symbol);let n=e.type;if(n.indexOf("exchange ")>=0){n=e.type.split(" ")[1]}let d=parseInt(1e3*parseFloat(e.timestamp));return{info:e,id:e.id.toString(),timestamp:d,datetime:this.iso8601(d),lastTradeTimestamp:void 0,symbol:o,type:n,side:i,price:this.safeFloat(e,"price"),average:this.safeFloat(e,"avg_execution_price"),amount:this.safeFloat(e,"original_amount"),remaining:this.safeFloat(e,"remaining_amount"),filled:this.safeFloat(e,"executed_amount"),status:a,fee:void 0}}async fetchOpenOrders(e,t,i,s={}){if(await this.loadMarkets(),void 0!==e&&!(e in this.markets))throw new r(this.id+" has no symbol "+e);let a=await this.privatePostOrders(s),o=this.parseOrders(a,void 0,t,i);return e&&(o=this.filterBy(o,"symbol",e)),o}async fetchClosedOrders(e,t,i,s={}){await this.loadMarkets();let r={};void 0!==i&&(r.limit=i);let a=await this.privatePostOrdersHist(this.extend(r,s)),o=this.parseOrders(a,void 0,t,i);return void 0!==e&&(o=this.filterBy(o,"symbol",e)),o=this.filterBy(o,"status","closed")}async fetchOrder(e,t,i={}){await this.loadMarkets();let s=await this.privatePostOrderStatus(this.extend({order_id:parseInt(e)},i));return this.parseOrder(s)}parseOHLCV(e,t,i="1m",s,r){return[e[0],e[1],e[3],e[4],e[2],e[5]]}async fetchOHLCV(e,t="1m",i,s,r={}){await this.loadMarkets(),void 0===s&&(s=100);let a=this.market(e),o={symbol:"t"+a.id,timeframe:this.timeframes[t],sort:1,limit:s};void 0!==i&&(o.start=i);let n=await this.v2GetCandlesTradeTimeframeSymbolHist(this.extend(o,r));return this.parseOHLCVs(n,a,t,i,s)}getCurrencyName(e){const i={AGI:"agi",AID:"aid",AIO:"aio",ANT:"ant",AVT:"aventus",BAT:"bat",BCH:"bcash",BCI:"bci",BFT:"bft",BTC:"bitcoin",BTG:"bgold",CFI:"cfi",DAI:"dai",DADI:"dad",DASH:"dash",DATA:"datacoin",DTH:"dth",EDO:"eidoo",ELF:"elf",EOS:"eos",ETC:"ethereumc",ETH:"ethereum",ETP:"metaverse",FUN:"fun",GNT:"golem",IOST:"ios",IOTA:"iota",LRC:"lrc",LTC:"litecoin",LYM:"lym",MANA:"mna",MIT:"mit",MKR:"mkr",MTN:"mtn",NEO:"neo",ODE:"ode",OMG:"omisego",OMNI:"mastercoin",QASH:"qash",QTUM:"qtum",RCN:"rcn",RDN:"rdn",REP:"rep",REQ:"req",RLC:"rlc",SAN:"santiment",SNGLS:"sng",SNT:"status",SPANK:"spk",STJ:"stj",TNB:"tnb",TRX:"trx",USD:"wire",UTK:"utk",USDT:"tetheruso",VEE:"vee",WAX:"wax",XLM:"xlm",XMR:"monero",XRP:"ripple",XVG:"xvg",YOYOW:"yoyow",ZEC:"zcash",ZRX:"zrx"};if(e in i)return i[e];throw new t(this.id+" "+e+" not supported for withdrawal")}async createDepositAddress(e,t={}){let i=await this.fetchDepositAddress(e,this.extend({renew:1},t)),s=this.safeString(i,"address");return this.checkAddress(s),{currency:e,address:s,status:"ok",info:i.info}}async fetchDepositAddress(e,t={}){let i={method:this.getCurrencyName(e),wallet_name:"exchange",renew:0},s=await this.privatePostDepositNew(this.extend(i,t)),r=s.address,a=void 0;return"address_pool"in s&&(a=r,r=s.address_pool),this.checkAddress(r),{currency:e,address:r,tag:a,status:"ok",info:s}}async withdraw(e,t,i,s,a={}){this.checkAddress(i);let o={withdraw_type:this.getCurrencyName(e),walletselected:"exchange",amount:t.toString(),address:i};s&&(o.payment_id=s);let n=(await this.privatePostWithdraw(this.extend(o,a)))[0],d=n.withdrawal_id,c=n.message,l=this.findBroadlyMatchedKey(this.exceptions.broad,c);if(0===d){if(void 0!==l){throw new(0,this.exceptions.broad[l])(this.id+" "+c)}throw new r(this.id+" withdraw returned an id of zero: "+this.json(n))}return{info:n,id:d}}nonce(){return this.milliseconds()}sign(e,t="public",i="GET",s={},r,a){let o="/"+this.implodeParams(e,s);o="v2"===t?"/"+t+o:"/"+this.version+o;let n=this.omit(s,this.extractParams(e)),d=this.urls.api+o;if(("public"===t||e.indexOf("/hist")>=0)&&Object.keys(n).length){let e="?"+this.urlencode(n);d+=e,o+=e}if("private"===t){this.checkRequiredCredentials();let e=this.nonce();n=this.extend({nonce:e.toString(),request:o},n),n=this.json(n),n=this.encode(n);let t=this.stringToBase64(n),i=this.encode(this.secret),s=this.hmac(t,i,"sha384");r={"X-BFX-APIKEY":this.apiKey,"X-BFX-PAYLOAD":this.decode(t),"X-BFX-SIGNATURE":s}}return{url:d,method:i,body:a,headers:r}}findBroadlyMatchedKey(e,t){const i=Object.keys(e);for(let e=0;e<i.length;e++){const s=i[e];if(t.indexOf(s)>=0)return s}}handleErrors(e,t,i,s,a,o){if(!(o.length<2)&&e>=400&&"{"===o[0]){const e=JSON.parse(o),t=this.id+" "+this.json(e);let i=void 0;if("message"in e)i=e.message;else{if(!("error"in e))throw new r(t);i=e.error}const s=this.exceptions.exact;if(i in s)throw new s[i](t);const a=this.exceptions.broad,n=this.findBroadlyMatchedKey(a,i);if(void 0!==n)throw new a[n](t);throw new r(t)}}};
//# sourceMappingURL=bitfinex.js.map
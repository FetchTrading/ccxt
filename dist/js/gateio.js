"use strict";const e=require("./base/Exchange"),{ExchangeError:t,InvalidAddress:i,OrderNotFound:s,NotSupported:r,DDoSProtection:a,InsufficientFunds:o}=require("./base/errors");module.exports=class extends e{describe(){return this.deepExtend(super.describe(),{id:"gateio",name:"Gate.io",countries:"CN",version:"2",rateLimit:1e3,has:{CORS:!1,createMarketOrder:!1,fetchTickers:!0,withdraw:!0,createDepositAddress:!0,fetchDepositAddress:!0,fetchClosedOrders:!0,fetchOpenOrders:!0,fetchOrders:!0,fetchOrder:!0},urls:{logo:"https://user-images.githubusercontent.com/1294454/31784029-0313c702-b509-11e7-9ccc-bc0da6a0e435.jpg",api:{public:"https://data.gate.io/api",private:"https://data.gate.io/api"},www:"https://gate.io/",doc:"https://gate.io/api2",fees:["https://gate.io/fee","https://support.gate.io/hc/en-us/articles/115003577673"]},api:{public:{get:["pairs","marketinfo","marketlist","tickers","ticker/{id}","orderBook/{id}","trade/{id}","tradeHistory/{id}","tradeHistory/{id}/{tid}"]},private:{post:["balances","depositAddress","newAddress","depositsWithdrawals","buy","sell","cancelOrder","cancelAllOrders","getOrder","openOrders","tradeHistory","withdraw"]}},fees:{trading:{tierBased:!0,percentage:!0,maker:.002,taker:.002}},exceptions:{4:a,7:r,8:r,9:r,15:a,16:s,17:s,21:o},errorCodeNames:{1:"Invalid request",2:"Invalid version",3:"Invalid request",4:"Too many attempts",5:"Invalid sign",6:"Invalid sign",7:"Currency is not supported",8:"Currency is not supported",9:"Currency is not supported",10:"Verified failed",11:"Obtaining address failed",12:"Empty params",13:"Internal error, please report to administrator",14:"Invalid user",15:"Cancel order too fast, please wait 1 min and try again",16:"Invalid order id or order is already closed",17:"Invalid orderid",18:"Invalid amount",19:"Not permitted or trade is disabled",20:"Your order size is too small",21:"You don't have enough fund"},options:{limits:{cost:{min:{BTC:1e-4,ETH:.001,USDT:1}}}}})}async fetchMarkets(){let e=await this.publicGetMarketinfo(),i=this.safeValue(e,"pairs");if(!i)throw new t(this.id+" fetchMarkets got an unrecognized response");let s=[];for(let e=0;e<i.length;e++){let t=i[e],r=Object.keys(t)[0],a=t[r],[o,d]=r.split("_");o=o.toUpperCase(),d=d.toUpperCase();let n=(o=this.commonCurrencyCode(o))+"/"+(d=this.commonCurrencyCode(d)),l={amount:8,price:a.decimal_places},h={min:a.min_amount,max:void 0},c={min:Math.pow(10,-a.decimal_places),max:void 0},p=h.min*c.min,u={amount:h,price:c,cost:{min:this.safeFloat(this.options.limits.cost.min,d,p),max:void 0}};s.push({id:r,symbol:n,base:o,quote:d,info:t,maker:a.fee/100,taker:a.fee/100,precision:l,limits:u})}return s}async fetchBalance(e={}){await this.loadMarkets();let t=await this.privatePostBalances(),i={info:t},s=Object.keys(this.currencies);for(let e=0;e<s.length;e++){let r=s[e],a=this.commonCurrencyCode(r),o=this.account();"available"in t&&r in t.available&&(o.free=parseFloat(t.available[r])),"locked"in t&&r in t.locked&&(o.used=parseFloat(t.locked[r])),o.total=this.sum(o.free,o.used),i[a]=o}return this.parseBalance(i)}async fetchOrderBook(e,t,i={}){await this.loadMarkets();let s=await this.publicGetOrderBookId(this.extend({id:this.marketId(e)},i));return this.parseOrderBook(s)}parseTicker(e,t){let i=this.milliseconds(),s=void 0;t&&(s=t.symbol);let r=this.safeFloat(e,"last");return{symbol:s,timestamp:i,datetime:this.iso8601(i),high:this.safeFloat(e,"high24hr"),low:this.safeFloat(e,"low24hr"),bid:this.safeFloat(e,"highestBid"),bidVolume:void 0,ask:this.safeFloat(e,"lowestAsk"),askVolume:void 0,vwap:void 0,open:void 0,close:r,last:r,previousClose:void 0,change:this.safeFloat(e,"percentChange"),percentage:void 0,average:void 0,baseVolume:this.safeFloat(e,"quoteVolume"),quoteVolume:this.safeFloat(e,"baseVolume"),info:e}}handleErrors(e,t,i,s,r,a){if(a.length<=0)return;if("{"!==a[0])return;let o=JSON.parse(a);if("false"!==this.safeString(o,"result",""))return;let d=this.safeString(o,"code");if(void 0!==d){const e=this.exceptions,t=this.errorCodeNames;if(d in e){let i="";throw i=d in t?t[d]:this.safeString(o,"message","(unknown)"),new e[d](i)}}}async fetchTickers(e,t={}){await this.loadMarkets();let i=await this.publicGetTickers(t),s={},r=Object.keys(i);for(let e=0;e<r.length;e++){let t=r[e],[a,o]=t.split("_"),d=a.toUpperCase(),n=o.toUpperCase(),l=(d=this.commonCurrencyCode(d))+"/"+(n=this.commonCurrencyCode(n)),h=i[t],c=void 0;l in this.markets&&(c=this.markets[l]),t in this.markets_by_id&&(c=this.markets_by_id[t]),s[l]=this.parseTicker(h,c)}return s}async fetchTicker(e,t={}){await this.loadMarkets();let i=this.market(e),s=await this.publicGetTickerId(this.extend({id:i.id},t));return this.parseTicker(s,i)}parseTrade(e,t){let i=this.parse8601(e.date)-288e5;return{id:e.tradeID,info:e,timestamp:i,datetime:this.iso8601(i),symbol:t.symbol,type:void 0,side:e.type,price:this.safeFloat(e,"rate"),amount:this.safeFloat(e,"amount")}}async fetchTrades(e,t,i,s={}){await this.loadMarkets();let r=this.market(e),a=await this.publicGetTradeHistoryId(this.extend({id:r.id},s));return this.parseTrades(a.data,r,t,i)}async fetchOrders(e,t,i,s={}){let r=await this.privatePostOpenOrders(s);return this.parseOrders(r.orders,void 0,t,i)}async fetchOrder(e,t,i={}){await this.loadMarkets();let s=await this.privatePostGetOrder(this.extend({orderNumber:e,currencyPair:this.marketId(t)},i));return this.parseOrder(s.order)}parseOrderStatus(e){let t={cancelled:"canceled"};return e in t?t[e]:e}parseOrder(e,t){let i=this.safeString(e,"orderNumber"),s=void 0,r=this.safeString(e,"currencyPair");r in this.markets_by_id&&(t=this.markets_by_id[r]),void 0!==t&&(s=t.symbol);let a=void 0,o=this.safeInteger(e,"timestamp");void 0!==o&&(o*=1e3,a=this.iso8601(o));let d=this.safeString(e,"status");void 0!==d&&(d=this.parseOrderStatus(d));let n=this.safeString(e,"type"),l=this.safeFloat(e,"filledRate"),h=this.safeFloat(e,"initialAmount"),c=this.safeFloat(e,"filledAmount"),p=this.safeFloat(e,"leftAmount");void 0===p&&(p=this.safeFloat(e,"left"));let u=this.safeFloat(e,"feeValue"),m=this.safeString(e,"feeCurrency");return void 0!==m&&m in this.currencies_by_id&&(m=this.currencies_by_id[m].code),{id:i,datetime:a,timestamp:o,status:d,symbol:s,type:"limit",side:n,price:l,cost:void 0,amount:h,filled:c,remaining:p,trades:void 0,fee:{cost:u,currency:m},info:e}}async createOrder(e,i,s,r,a,o={}){if("market"===i)throw new t(this.id+" allows limit orders only");await this.loadMarkets();let d="privatePost"+this.capitalize(s),n=this.market(e),l={currencyPair:n.id,rate:a,amount:r},h=await this[d](this.extend(l,o));return this.parseOrder(this.extend({status:"open",type:s,initialAmount:r},h),n)}async cancelOrder(e,t,i={}){return await this.loadMarkets(),await this.privatePostCancelOrder({orderNumber:e,currencyPair:this.marketId(t)})}async queryDepositAddress(e,t,s={}){await this.loadMarkets();let r=this.currency(t);e="privatePost"+e+"Address";let a=await this[e](this.extend({currency:r.id},s)),o=this.safeString(a,"addr"),d=void 0;if(void 0!==o&&o.indexOf("address")>=0)throw new i(this.id+" queryDepositAddress "+o);if("XRP"===t){let e=o.split("/",2);o=e[0],d=e[1]}return{currency:r,address:o,tag:d,status:void 0!==o?"ok":"none",info:a}}async createDepositAddress(e,t={}){return await this.queryDepositAddress("New",e,t)}async fetchDepositAddress(e,t={}){return await this.queryDepositAddress("Deposit",e,t)}async fetchOpenOrders(e,t,i,s={}){await this.loadMarkets();let r=void 0;void 0!==e&&(r=this.market(e));let a=await this.privatePostOpenOrders();return this.parseOrders(a.orders,r,t,i)}async fetchMyTrades(e,i,s,r={}){if(void 0===e)throw new t(this.id+" fetchMyTrades requires symbol param");await this.loadMarkets();let a=this.market(e),o=a.id,d=await this.privatePostTradeHistory(this.extend({currencyPair:o},r));return this.parseTrades(d.trades,a,i,s)}async withdraw(e,t,i,s,r={}){return this.checkAddress(i),await this.loadMarkets(),{info:await this.privatePostWithdraw(this.extend({currency:e.toLowerCase(),amount:t,address:i},r)),id:void 0}}sign(e,t="public",i="GET",s={},r,a){let o="private"===t?t+"/":"",d=this.urls.api[t]+this.version+"/1/"+o+this.implodeParams(e,s),n=this.omit(s,this.extractParams(e));if("public"===t)Object.keys(n).length&&(d+="?"+this.urlencode(n));else{this.checkRequiredCredentials();let e={nonce:this.nonce()};a=this.urlencode(this.extend(e,n));let t=this.hmac(this.encode(a),this.encode(this.secret),"sha512");r={Key:this.apiKey,Sign:t,"Content-Type":"application/x-www-form-urlencoded"}}return{url:d,method:i,body:a,headers:r}}async request(e,i="public",s="GET",r={},a,o){let d=await this.fetch2(e,i,s,r,a,o);if("result"in d){let e=d.result,i=this.id+" "+this.json(d);if(void 0===e)throw new t(i);if("string"==typeof e){if("true"!==e)throw new t(i)}else if(!e)throw new t(i)}return d}};
//# sourceMappingURL=gateio.js.map
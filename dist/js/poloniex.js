"use strict";const e=require("./base/Exchange"),{ExchangeError:t,ExchangeNotAvailable:r,RequestTimeout:s,AuthenticationError:i,DDoSProtection:a,InsufficientFunds:o,OrderNotFound:n,OrderNotCached:d,InvalidOrder:h,AccountSuspended:l,CancelPending:c,InvalidNonce:u}=require("./base/errors");module.exports=class extends e{describe(){return this.deepExtend(super.describe(),{id:"poloniex",name:"Poloniex",countries:"US",rateLimit:1e3,has:{createDepositAddress:!0,fetchDepositAddress:!0,CORS:!1,editOrder:!0,createMarketOrder:!1,fetchOHLCV:!0,fetchMyTrades:!0,fetchOrder:"emulated",fetchOrders:"emulated",fetchOpenOrders:!0,fetchClosedOrders:"emulated",fetchTickers:!0,fetchTradingFees:!0,fetchCurrencies:!0,withdraw:!0},timeframes:{"5m":300,"15m":900,"30m":1800,"2h":7200,"4h":14400,"1d":86400},urls:{logo:"https://user-images.githubusercontent.com/1294454/27766817-e9456312-5ee6-11e7-9b3c-b628ca5626a5.jpg",api:{public:"https://poloniex.com/public",private:"https://poloniex.com/tradingApi"},www:"https://poloniex.com",doc:["https://poloniex.com/support/api/","http://pastebin.com/dMX7mZE0"],fees:"https://poloniex.com/fees"},api:{public:{get:["return24hVolume","returnChartData","returnCurrencies","returnLoanOrders","returnOrderBook","returnTicker","returnTradeHistory"]},private:{post:["buy","cancelLoanOffer","cancelOrder","closeMarginPosition","createLoanOffer","generateNewAddress","getMarginPosition","marginBuy","marginSell","moveOrder","returnActiveLoans","returnAvailableAccountBalances","returnBalances","returnCompleteBalances","returnDepositAddresses","returnDepositsWithdrawals","returnFeeInfo","returnLendingHistory","returnMarginAccountSummary","returnOpenLoanOffers","returnOpenOrders","returnOrderTrades","returnTradableBalances","returnTradeHistory","sell","toggleAutoRenew","transferBalance","withdraw"]}},fees:{trading:{maker:.0015,taker:.0025},funding:{}},limits:{amount:{min:1e-8,max:1e9},price:{min:1e-8,max:1e9},cost:{min:0,max:1e9}},precision:{amount:8,price:8},commonCurrencies:{BTM:"Bitmark",STR:"XLM",BCC:"BTCtalkcoin"},options:{limits:{cost:{min:{BTC:1e-4,ETH:1e-4,XMR:1e-4,USDT:1}}}}})}calculateFee(e,t,r,s,i,a="taker",o={}){let n=this.markets[e],d="quote",h=n[a],l=parseFloat(this.costToPrecision(e,s*h));return"sell"===r?l*=i:d="base",{type:a,currency:n[d],rate:h,cost:parseFloat(this.feeToPrecision(e,l))}}parseOHLCV(e,t,r="5m",s,i){return[1e3*e.date,e.open,e.high,e.low,e.close,e.quoteVolume]}async fetchOHLCV(e,t="5m",r,s,i={}){await this.loadMarkets();let a=this.market(e);r||(r=0);let o={currencyPair:a.id,period:this.timeframes[t],start:parseInt(r/1e3)};void 0!==s&&(o.end=this.sum(o.start,s*this.timeframes[t]));let n=await this.publicGetReturnChartData(this.extend(o,i));return this.parseOHLCVs(n,a,t,r,s)}async fetchMarkets(){let e=await this.publicGetReturnTicker(),t=Object.keys(e),r=[];for(let s=0;s<t.length;s++){let i=t[s],a=e[i],[o,n]=i.split("_"),d=(n=this.commonCurrencyCode(n))+"/"+(o=this.commonCurrencyCode(o)),h=this.safeFloat(this.options.limits.cost.min,o,0);r.push(this.extend(this.fees.trading,{id:i,symbol:d,base:n,quote:o,active:!0,precision:{amount:8,price:8},limits:{amount:{min:1e-8,max:1e9},price:{min:1e-8,max:1e9},cost:{min:h,max:1e9}},info:a}))}return r}async fetchBalance(e={}){await this.loadMarkets();let t=await this.privatePostReturnCompleteBalances(this.extend({account:"all"},e)),r={info:t},s=Object.keys(t);for(let e=0;e<s.length;e++){let i=s[e],a=t[i],o=this.commonCurrencyCode(i),n={free:parseFloat(a.available),used:parseFloat(a.onOrders),total:0};n.total=this.sum(n.free,n.used),r[o]=n}return this.parseBalance(r)}async fetchTradingFees(e={}){await this.loadMarkets();let t=await this.privatePostReturnFeeInfo();return{info:t,maker:this.safeFloat(t,"makerFee"),taker:this.safeFloat(t,"takerFee"),withdraw:{},deposit:{}}}async fetchOrderBook(e,t,r={}){await this.loadMarkets();let s={currencyPair:this.marketId(e)};void 0!==t&&(s.depth=t);let i=await this.publicGetReturnOrderBook(this.extend(s,r)),a=this.parseOrderBook(i);return a.nonce=this.safeInteger(i,"sec"),a}parseTicker(e,t){let r=this.milliseconds(),s=void 0;t&&(s=t.symbol);let i=void 0,a=void 0,o=void 0,n=this.safeFloat(e,"last"),d=this.safeFloat(e,"percentChange");return-1!==d&&(a=n-(i=n/this.sum(1,d)),o=this.sum(n,i)/2),{symbol:s,timestamp:r,datetime:this.iso8601(r),high:this.safeFloat(e,"high24hr"),low:this.safeFloat(e,"low24hr"),bid:this.safeFloat(e,"highestBid"),bidVolume:void 0,ask:this.safeFloat(e,"lowestAsk"),askVolume:void 0,vwap:void 0,open:i,close:n,last:n,previousClose:void 0,change:a,percentage:100*d,average:o,baseVolume:this.safeFloat(e,"quoteVolume"),quoteVolume:this.safeFloat(e,"baseVolume"),info:e}}async fetchTickers(e,t={}){await this.loadMarkets();let r=await this.publicGetReturnTicker(t),s=Object.keys(r),i={};for(let e=0;e<s.length;e++){let t=s[e],a=this.markets_by_id[t],o=a.symbol,n=r[t];i[o]=this.parseTicker(n,a)}return i}async fetchCurrencies(e={}){let t=await this.publicGetReturnCurrencies(e),r=Object.keys(t),s={};for(let e=0;e<r.length;e++){let i=r[e],a=t[i],o=8,n=this.commonCurrencyCode(i),d=0===a.delisted,h=a.disabled?"disabled":"ok";"ok"!==h&&(d=!1),s[n]={id:i,code:n,info:a,name:a.name,active:d,status:h,fee:this.safeFloat(a,"txFee"),precision:o,limits:{amount:{min:Math.pow(10,-o),max:Math.pow(10,o)},price:{min:Math.pow(10,-o),max:Math.pow(10,o)},cost:{min:void 0,max:void 0},withdraw:{min:a.txFee,max:Math.pow(10,o)}}}}return s}async fetchTicker(e,t={}){await this.loadMarkets();let r=this.market(e),s=(await this.publicGetReturnTicker(t))[r.id];return this.parseTicker(s,r)}parseTrade(e,t){let r=this.parse8601(e.date),s=void 0,i=void 0,a=void 0;if(!t&&"currencyPair"in e){let r=e.currencyPair;if(r in this.markets_by_id)t=this.markets_by_id[r];else{let e=r.split("_");a=e[0],s=(i=e[1])+"/"+a}}t&&(s=t.symbol,i=t.base,a=t.quote);let o=e.type,n=void 0,d=this.safeFloat(e,"total"),h=this.safeFloat(e,"amount");if("fee"in e){let t=this.safeFloat(e,"fee"),r=void 0,s=void 0;"buy"===o?(s=i,r=h*t):(s=a,void 0!==d&&(r=d*t)),n={type:void 0,rate:t,cost:r,currency:s}}return{info:e,timestamp:r,datetime:this.iso8601(r),symbol:s,id:this.safeString(e,"tradeID"),order:this.safeString(e,"orderNumber"),type:"limit",side:o,price:this.safeFloat(e,"rate"),amount:h,cost:d,fee:n}}async fetchTrades(e,t,r,s={}){await this.loadMarkets();let i=this.market(e),a={currencyPair:i.id};void 0!==t&&(a.start=parseInt(t/1e3),a.end=this.seconds());let o=await this.publicGetReturnTradeHistory(this.extend(a,s));return this.parseTrades(o,i,t,r)}async fetchMyTrades(e,t,r,s={}){await this.loadMarkets();let i=void 0;e&&(i=this.market(e));let a={currencyPair:i?i.id:"all"};void 0!==t&&(a.start=parseInt(t/1e3),a.end=this.seconds()),r&&(a.limit=parseInt(r));let o=await this.privatePostReturnTradeHistory(this.extend(a,s)),n=[];if(i)n=this.parseTrades(o,i);else if(o){let e=Object.keys(o);for(let t=0;t<e.length;t++){let r=e[t],s=void 0;r in this.markets_by_id&&(s=this.markets_by_id[r]);let i=this.parseTrades(o[r],s);for(let e=0;e<i.length;e++)n.push(i[e])}}return this.filterBySinceLimit(n,t,r)}parseOrder(e,t){let r=this.safeInteger(e,"timestamp");r||(r=this.parse8601(e.date));let s=void 0;"resultingTrades"in e&&(s=this.parseTrades(e.resultingTrades,t));let i=void 0;t&&(i=t.symbol);let a=this.safeFloat(e,"price"),o=this.safeFloat(e,"amount"),n=this.safeFloat(e,"startingAmount",o),d=void 0,h=0;if(void 0!==n&&void 0!==o&&(d=n-o,void 0!==a&&(h=d*a)),void 0===d&&void 0!==s){d=0,h=0;for(let e=0;e<s.length;e++){let t=s[e],r=t.amount,i=t.price;d=this.sum(d,r),h+=i*r}}return{info:e,id:e.orderNumber,timestamp:r,datetime:this.iso8601(r),lastTradeTimestamp:void 0,status:e.status,symbol:i,type:e.type,side:e.side,price:a,cost:h,amount:n,filled:d,remaining:o,trades:s,fee:void 0}}parseOpenOrders(e,t,r=[]){for(let s=0;s<e.length;s++){let i=e[s],a=this.extend(i,{status:"open",type:"limit",side:i.type,price:i.rate});r.push(this.parseOrder(a,t))}return r}async fetchOrders(e,t,r,s={}){await this.loadMarkets();let i=void 0;e&&(i=this.market(e));let a=i?i.id:"all",o=await this.privatePostReturnOpenOrders(this.extend({currencyPair:a})),n=[];if(i)n=this.parseOpenOrders(o,i,n);else{let e=Object.keys(o);for(let t=0;t<e.length;t++){let r=e[t],s=o[r],i=this.markets_by_id[r];n=this.parseOpenOrders(s,i,n)}}for(let e=0;e<n.length;e++)this.orders[n[e].id]=n[e];let d=this.indexBy(n,"id"),h=Object.keys(this.orders),l=[];for(let t=0;t<h.length;t++){let r=h[t];if(r in d)this.orders[r]=this.extend(this.orders[r],d[r]);else{let e=this.orders[r];"open"===e.status&&(void 0===(e=this.extend(e,{status:"closed",cost:void 0,filled:e.amount,remaining:0})).cost&&void 0!==e.filled&&(e.cost=e.filled*e.price),this.orders[r]=e)}let s=this.orders[r];i?s.symbol===e&&l.push(s):l.push(s)}return this.filterBySinceLimit(l,t,r)}async fetchOrder(e,t,r={}){let s=this.safeValue(r,"since"),i=this.safeValue(r,"limit"),a=this.omit(r,["since","limit"]),o=await this.fetchOrders(t,s,i,a);for(let t=0;t<o.length;t++)if(o[t].id===e)return o[t];throw new d(this.id+" order id "+e.toString()+' is not in "open" state and not found in cache')}filterOrdersByStatus(e,t){let r=[];for(let s=0;s<e.length;s++)e[s].status===t&&r.push(e[s]);return r}async fetchOpenOrders(e,t,r,s={}){let i=await this.fetchOrders(e,t,r,s);return this.filterOrdersByStatus(i,"open")}async fetchClosedOrders(e,t,r,s={}){let i=await this.fetchOrders(e,t,r,s);return this.filterOrdersByStatus(i,"closed")}async createOrder(e,r,s,i,a,o={}){if("market"===r)throw new t(this.id+" allows limit orders only");await this.loadMarkets();let n="privatePost"+this.capitalize(s),d=this.market(e);a=parseFloat(a),i=parseFloat(i);let h=await this[n](this.extend({currencyPair:d.id,rate:this.priceToPrecision(e,a),amount:this.amountToPrecision(e,i)},o)),l=this.milliseconds(),c=this.parseOrder(this.extend({timestamp:l,status:"open",type:r,side:s,price:a,amount:i},h),d),u=c.id;return this.orders[u]=c,this.extend({info:h},c)}async editOrder(e,t,r,s,i,a,o={}){await this.loadMarkets(),a=parseFloat(a);let n={orderNumber:e,rate:this.priceToPrecision(t,a)};void 0!==i&&(i=parseFloat(i),n.amount=this.amountToPrecision(t,i));let d=await this.privatePostMoveOrder(this.extend(n,o)),h=void 0;if(e in this.orders){this.orders[e].status="canceled";let t=d.orderNumber;this.orders[t]=this.extend(this.orders[e],{id:t,price:a,status:"open"}),void 0!==i&&(this.orders[t].amount=i),h=this.extend(this.orders[t],{info:d})}else{let e=void 0;t&&(e=this.market(t)),h=this.parseOrder(d,e),this.orders[h.id]=h}return h}async cancelOrder(e,t,r={}){await this.loadMarkets();let s=void 0;try{s=await this.privatePostCancelOrder(this.extend({orderNumber:e},r))}catch(t){throw t instanceof c&&e in this.orders&&(this.orders[e].status="canceled"),t}return e in this.orders&&(this.orders[e].status="canceled"),s}async fetchOrderStatus(e,t){await this.loadMarkets();let r=await this.fetchOpenOrders(t);return e in this.indexBy(r,"id")?"open":"closed"}async fetchOrderTrades(e,t,r={}){await this.loadMarkets();let s=await this.privatePostReturnOrderTrades(this.extend({orderNumber:e},r));return this.parseTrades(s)}async createDepositAddress(e,t={}){let r=this.currency(e),s=await this.privatePostGenerateNewAddress({currency:r.id}),i=void 0;return 1===s.success&&(i=this.safeString(s,"response")),this.checkAddress(i),{currency:e,address:i,status:"ok",info:s}}async fetchDepositAddress(e,t={}){let r=this.currency(e),s=await this.privatePostReturnDepositAddresses(),i=r.id,a=this.safeString(s,i);return this.checkAddress(a),{currency:e,address:a,status:a?"ok":"none",info:s}}async withdraw(e,t,r,s,i={}){this.checkAddress(r),await this.loadMarkets();let a={currency:this.currency(e).id,amount:t,address:r};s&&(a.paymentId=s);let o=await this.privatePostWithdraw(this.extend(a,i));return{info:o,id:o.response}}nonce(){return this.milliseconds()}sign(e,t="public",r="GET",s={},i,a){let o=this.urls.api[t],n=this.extend({command:e},s);return"public"===t?o+="?"+this.urlencode(n):(this.checkRequiredCredentials(),n.nonce=this.nonce(),a=this.urlencode(n),i={"Content-Type":"application/x-www-form-urlencoded",Key:this.apiKey,Sign:this.hmac(this.encode(a),this.encode(this.secret),"sha512")}),{url:o,method:r,body:a,headers:i}}handleErrors(e,d,p,m,f,y){let w=void 0;try{w=JSON.parse(y)}catch(e){return}if("error"in w){const e=w.error,d=this.id+" "+this.json(w);throw"Invalid order number, or you are not the person who placed the order."===e?new n(d):"Connection timed out. Please try again."===e?new s(d):"Internal error. Please try again."===e?new r(d):"Order not found, or you are not the person who placed it."===e?new n(d):"Invalid API key/secret pair."===e?new i(d):"Please do not make more than 8 API calls per second."===e?new a(d):e.indexOf("Total must be at least")>=0?new h(d):e.indexOf("This account is frozen.")>=0?new l(d):e.indexOf("Not enough")>=0?new o(d):e.indexOf("Nonce must be greater")>=0?new u(d):e.indexOf("You have already called cancelOrder or moveOrder on this order.")>=0?new c(d):new t(this.id+": unknown error: "+this.json(w))}}};
//# sourceMappingURL=poloniex.js.map
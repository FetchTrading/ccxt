"use strict";const e=require("./base/Exchange"),{InvalidNonce:t,OrderNotFound:s,InvalidOrder:i,InsufficientFunds:r,AuthenticationError:a}=require("./base/errors");module.exports=class extends e{describe(){return this.deepExtend(super.describe(),{id:"qryptos",name:"QRYPTOS",countries:["CN","TW"],version:"2",rateLimit:1e3,has:{CORS:!1,fetchTickers:!0,fetchOrder:!0,fetchOrders:!0,fetchOpenOrders:!0,fetchClosedOrders:!0,fetchMyTrades:!0},urls:{logo:"https://user-images.githubusercontent.com/1294454/30953915-b1611dc0-a436-11e7-8947-c95bd5a42086.jpg",api:"https://api.qryptos.com",www:"https://www.qryptos.com",doc:["https://developers.quoine.com","https://developers.quoine.com/v2"],fees:"https://qryptos.zendesk.com/hc/en-us/articles/115007858167-Fees"},api:{public:{get:["products","products/{id}","products/{id}/price_levels","executions","ir_ladders/{currency}"]},private:{get:["accounts/balance","accounts/main_asset","crypto_accounts","executions/me","fiat_accounts","loan_bids","loans","orders","orders/{id}","orders/{id}/trades","orders/{id}/executions","trades","trades/{id}/loans","trading_accounts","trading_accounts/{id}"],post:["fiat_accounts","loan_bids","orders"],put:["loan_bids/{id}/close","loans/{id}","orders/{id}","orders/{id}/cancel","trades/{id}","trades/{id}/close","trades/close_all","trading_accounts/{id}"]}},skipJsonOnStatusCodes:[401],exceptions:{messages:{"API Authentication failed":a,"Nonce is too small":t,"Order not found":s,user:{not_enough_free_balance:r},price:{must_be_positive:i},quantity:{less_than_order_size:i}}}})}async fetchMarkets(){let e=await this.publicGetProducts(),t=[];for(let s=0;s<e.length;s++){let i=e[s],r=i.id.toString(),a=i.base_currency,o=i.quoted_currency,d=a+"/"+o,n=this.safeFloat(i,"maker_fee"),c=this.safeFloat(i,"taker_fee"),l=!i.disabled,h=void 0,u=void 0;"BTC"===a?h=.001:"ETH"===a&&(h=.01),"BTC"===o?u=1e-8:"ETH"!==o&&"USD"!==o&&"JPY"!==o||(u=1e-5);let p={amount:{min:h},price:{min:u},cost:{min:void 0}};void 0!==u&&void 0!==h&&(p.cost.min=u*h);let m={amount:void 0,price:void 0};void 0!==h&&(m.amount=-Math.log10(h)),void 0!==u&&(m.price=-Math.log10(u)),t.push({id:r,symbol:d,base:a,quote:o,maker:n,taker:c,limits:p,precision:m,active:l,info:i})}return t}async fetchBalance(e={}){await this.loadMarkets();let t=await this.privateGetAccountsBalance(e),s={info:t};for(let e=0;e<t.length;e++){let i=t[e],r=i.currency,a=parseFloat(i.balance),o={free:a,used:0,total:a};s[r]=o}return this.parseBalance(s)}async fetchOrderBook(e,t,s={}){await this.loadMarkets();let i=await this.publicGetProductsIdPriceLevels(this.extend({id:this.marketId(e)},s));return this.parseOrderBook(i,void 0,"buy_price_levels","sell_price_levels")}parseTicker(e,t){let s=this.milliseconds(),i=void 0;if("last_traded_price"in e&&e.last_traded_price){e.last_traded_price.length>0&&(i=this.safeFloat(e,"last_traded_price"))}let r=void 0;return t&&(r=t.symbol),{symbol:r,timestamp:s,datetime:this.iso8601(s),high:this.safeFloat(e,"high_market_ask"),low:this.safeFloat(e,"low_market_bid"),bid:this.safeFloat(e,"market_bid"),bidVolume:void 0,ask:this.safeFloat(e,"market_ask"),askVolume:void 0,vwap:void 0,open:void 0,close:i,last:i,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeFloat(e,"volume_24h"),quoteVolume:void 0,info:e}}async fetchTickers(e,t={}){await this.loadMarkets();let s=await this.publicGetProducts(t),i={};for(let e=0;e<s.length;e++){let t=s[e],r=t.base_currency+"/"+t.quoted_currency,a=this.markets[r];i[r]=this.parseTicker(t,a)}return i}async fetchTicker(e,t={}){await this.loadMarkets();let s=this.market(e),i=await this.publicGetProductsId(this.extend({id:s.id},t));return this.parseTicker(i,s)}parseTrade(e,t){let s=1e3*e.created_at,i=this.safeString(e,"taker_side"),r=this.safeString(e,"my_side"),a=void 0!==r?r:i,o=void 0;return void 0!==r&&(o=i===r?"taker":"maker"),{info:e,id:e.id.toString(),order:void 0,timestamp:s,datetime:this.iso8601(s),symbol:t.symbol,type:void 0,side:a,takerOrMaker:o,price:this.safeFloat(e,"price"),amount:this.safeFloat(e,"quantity")}}async fetchTrades(e,t,s,i={}){await this.loadMarkets();let r=this.market(e),a={product_id:r.id};void 0!==s&&(a.limit=s);let o=await this.publicGetExecutions(this.extend(a,i));return this.parseTrades(o.models,r,t,s)}async fetchMyTrades(e,t,s,i={}){await this.loadMarkets();let r=this.market(e),a={product_id:r.id};void 0!==s&&(a.limit=s);let o=await this.privateGetExecutionsMe(this.extend(a,i));return this.parseTrades(o.models,r,t,s)}async createOrder(e,t,s,i,r,a={}){await this.loadMarkets();let o={order_type:t,product_id:this.marketId(e),side:s,quantity:i};"limit"===t&&(o.price=r);let d=await this.privatePostOrders(this.extend(o,a));return this.parseOrder(d)}async cancelOrder(e,t,i={}){await this.loadMarkets();let r=await this.privatePutOrdersIdCancel(this.extend({id:e},i)),a=this.parseOrder(r);if("closed"===a.status)throw new s(this.id+" "+this.json(a));return a}parseOrder(e,t){let s=1e3*e.created_at,i=this.safeString(e,"product_id");void 0!==i&&i in this.markets_by_id&&(t=this.markets_by_id[i]);let r=void 0;"status"in e&&("live"===e.status?r="open":"filled"===e.status?r="closed":"cancelled"===e.status&&(r="canceled"));let a=this.safeFloat(e,"quantity"),o=this.safeFloat(e,"filled_quantity"),d=this.safeFloat(e,"price"),n=void 0;return t&&(n=t.symbol),{id:e.id.toString(),timestamp:s,datetime:this.iso8601(s),lastTradeTimestamp:void 0,type:e.order_type,status:r,symbol:n,side:e.side,price:d,amount:a,filled:o,remaining:a-o,trades:void 0,fee:{currency:void 0,cost:this.safeFloat(e,"order_fee")},info:e}}async fetchOrder(e,t,s={}){await this.loadMarkets();let i=await this.privateGetOrdersId(this.extend({id:e},s));return this.parseOrder(i)}async fetchOrders(e,t,s,i={}){await this.loadMarkets();let r=void 0,a={};e&&(r=this.market(e),a.product_id=r.id);let o=this.safeValue(i,"status");o&&(i=this.omit(i,"status"),"open"===o?a.status="live":"closed"===o?a.status="filled":"canceled"===o&&(a.status="cancelled")),void 0!==s&&(a.limit=s);let d=(await this.privateGetOrders(this.extend(a,i))).models;return this.parseOrders(d,r,t,s)}fetchOpenOrders(e,t,s,i={}){return this.fetchOrders(e,t,s,this.extend({status:"open"},i))}fetchClosedOrders(e,t,s,i={}){return this.fetchOrders(e,t,s,this.extend({status:"closed"},i))}nonce(){return this.milliseconds()}sign(e,t="public",s="GET",i={},r,a){let o="/"+this.implodeParams(e,i),d=this.omit(i,this.extractParams(e));if(r={"X-Quoine-API-Version":this.version,"Content-Type":"application/json"},"public"===t)Object.keys(d).length&&(o+="?"+this.urlencode(d));else{this.checkRequiredCredentials(),"GET"===s?Object.keys(d).length&&(o+="?"+this.urlencode(d)):Object.keys(d).length&&(a=this.json(d));let e=this.nonce(),t={path:o,nonce:e,token_id:this.apiKey,iat:Math.floor(e/1e3)};r["X-Quoine-Auth"]=this.jwt(t,this.secret)}return{url:o=this.urls.api+o,method:s,body:a,headers:r}}handleErrors(e,t,s,i,r,a,o){if(e>=200&&e<=299)return;const d=this.exceptions.messages;if(401===e){if(a in d)throw new d[a](this.id+" "+a);return}if(void 0===o){if("{"!==a[0]&&"["!==a[0])return;o=JSON.parse(a)}const n=this.id+" "+this.json(o);if(404===e){const e=this.safeString(o,"message");if(e in d)throw new d[e](n)}else if(422===e&&"errors"in o){const e=o.errors,t=["user","quantity","price"];for(let s=0;s<t.length;s++){const i=t[s];if(i in e){const t=e[i];for(let e=0;e<t.length;e++){const s=t[e];if(s in d[i])throw new d[i][s](n)}}}}}};
//# sourceMappingURL=qryptos.js.map
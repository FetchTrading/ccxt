"use strict";const e=require("./base/Exchange"),{ExchangeError:t,NotSupported:s}=require("./base/errors");module.exports=class extends e{describe(){return this.deepExtend(super.describe(),{id:"bitstamp1",name:"Bitstamp v1",countries:"GB",rateLimit:1e3,version:"v1",has:{CORS:!0},urls:{logo:"https://user-images.githubusercontent.com/1294454/27786377-8c8ab57e-5fe9-11e7-8ea4-2b05b6bcceec.jpg",api:"https://www.bitstamp.net/api",www:"https://www.bitstamp.net",doc:"https://www.bitstamp.net/api"},requiredCredentials:{apiKey:!0,secret:!0,uid:!0},api:{public:{get:["ticker","ticker_hour","order_book","transactions","eur_usd"]},private:{post:["balance","user_transactions","open_orders","order_status","cancel_order","cancel_all_orders","buy","sell","bitcoin_deposit_address","unconfirmed_btc","ripple_withdrawal","ripple_address","withdrawal_requests","bitcoin_withdrawal"]}},markets:{"BTC/USD":{id:"btcusd",symbol:"BTC/USD",base:"BTC",quote:"USD",maker:.0025,taker:.0025},"BTC/EUR":{id:"btceur",symbol:"BTC/EUR",base:"BTC",quote:"EUR",maker:.0025,taker:.0025},"EUR/USD":{id:"eurusd",symbol:"EUR/USD",base:"EUR",quote:"USD",maker:.0025,taker:.0025},"XRP/USD":{id:"xrpusd",symbol:"XRP/USD",base:"XRP",quote:"USD",maker:.0025,taker:.0025},"XRP/EUR":{id:"xrpeur",symbol:"XRP/EUR",base:"XRP",quote:"EUR",maker:.0025,taker:.0025},"XRP/BTC":{id:"xrpbtc",symbol:"XRP/BTC",base:"XRP",quote:"BTC",maker:.0025,taker:.0025},"LTC/USD":{id:"ltcusd",symbol:"LTC/USD",base:"LTC",quote:"USD",maker:.0025,taker:.0025},"LTC/EUR":{id:"ltceur",symbol:"LTC/EUR",base:"LTC",quote:"EUR",maker:.0025,taker:.0025},"LTC/BTC":{id:"ltcbtc",symbol:"LTC/BTC",base:"LTC",quote:"BTC",maker:.0025,taker:.0025},"ETH/USD":{id:"ethusd",symbol:"ETH/USD",base:"ETH",quote:"USD",maker:.0025,taker:.0025},"ETH/EUR":{id:"etheur",symbol:"ETH/EUR",base:"ETH",quote:"EUR",maker:.0025,taker:.0025},"ETH/BTC":{id:"ethbtc",symbol:"ETH/BTC",base:"ETH",quote:"BTC",maker:.0025,taker:.0025}}})}async fetchOrderBook(e,s,i={}){if("BTC/USD"!==e)throw new t(this.id+" "+this.version+" fetchOrderBook doesn't support "+e+", use it for BTC/USD only");let r=await this.publicGetOrderBook(i),a=1e3*parseInt(r.timestamp);return this.parseOrderBook(r,a)}async fetchTicker(e,s={}){if("BTC/USD"!==e)throw new t(this.id+" "+this.version+" fetchTicker doesn't support "+e+", use it for BTC/USD only");let i=await this.publicGetTicker(s),r=1e3*parseInt(i.timestamp),a=this.safeFloat(i,"vwap"),o=this.safeFloat(i,"volume"),d=o*a,n=this.safeFloat(i,"last");return{symbol:e,timestamp:r,datetime:this.iso8601(r),high:this.safeFloat(i,"high"),low:this.safeFloat(i,"low"),bid:this.safeFloat(i,"bid"),bidVolume:void 0,ask:this.safeFloat(i,"ask"),askVolume:void 0,vwap:a,open:this.safeFloat(i,"open"),close:n,last:n,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:o,quoteVolume:d,info:i}}parseTrade(e,t){let s=void 0;"date"in e?s=1e3*parseInt(e.date):"datetime"in e&&(s=1e3*parseInt(e.datetime));let i=0===e.type?"buy":"sell",r=void 0;return"order_id"in e&&(r=e.order_id.toString()),"currency_pair"in e&&e.currency_pair in this.markets_by_id&&(t=this.markets_by_id[e.currency_pair]),{id:e.tid.toString(),info:e,timestamp:s,datetime:this.iso8601(s),symbol:t.symbol,order:r,type:void 0,side:i,price:this.safeFloat(e,"price"),amount:this.safeFloat(e,"amount")}}async fetchTrades(e,s,i,r={}){if("BTC/USD"!==e)throw new t(this.id+" "+this.version+" fetchTrades doesn't support "+e+", use it for BTC/USD only");let a=this.market(e),o=await this.publicGetTransactions(this.extend({time:"minute"},r));return this.parseTrades(o,a,s,i)}async fetchBalance(e={}){let t=await this.privatePostBalance(),s={info:t},i=Object.keys(this.currencies);for(let e=0;e<i.length;e++){let r=i[e],a=r.toLowerCase(),o=a+"_balance",d=a+"_available",n=a+"_reserved",h=this.account();h.free=this.safeFloat(t,d,0),h.used=this.safeFloat(t,n,0),h.total=this.safeFloat(t,o,0),s[r]=h}return this.parseBalance(s)}async createOrder(e,s,i,r,a,o={}){if("limit"!==s)throw new t(this.id+" "+this.version+" accepts limit orders only");if("BTC/USD"!==e)throw new t(this.id+" v1 supports BTC/USD orders only");let d="privatePost"+this.capitalize(i),n={amount:r,price:a},h=await this[d](this.extend(n,o));return{info:h,id:h.id}}async cancelOrder(e,t,s={}){return await this.privatePostCancelOrder({id:e})}parseOrderStatus(e){return"Queue"===e.status||"Open"===e.status?"open":"Finished"===e.status?"closed":e.status}async fetchOrderStatus(e,t){await this.loadMarkets();let s=await this.privatePostOrderStatus({id:e});return this.parseOrderStatus(s)}async fetchMyTrades(e,t,s,i={}){await this.loadMarkets();let r=void 0;e&&(r=this.market(e));let a=r?r.id:"all",o=this.extend({id:a},i),d=await this.privatePostOpenOrdersId(o);return this.parseTrades(d,r,t,s)}async fetchOrder(e,t,i={}){throw new s(this.id+" fetchOrder is not implemented yet")}sign(e,t="public",s="GET",i={},r,a){let o=this.urls.api+"/"+this.implodeParams(e,i),d=this.omit(i,this.extractParams(e));if("public"===t)Object.keys(d).length&&(o+="?"+this.urlencode(d));else{this.checkRequiredCredentials();let e=this.nonce().toString(),t=e+this.uid+this.apiKey,s=this.encode(this.hmac(this.encode(t),this.encode(this.secret)));d=this.extend({key:this.apiKey,signature:s.toUpperCase(),nonce:e},d),a=this.urlencode(d),r={"Content-Type":"application/x-www-form-urlencoded"}}return{url:o,method:s,body:a,headers:r}}async request(e,s="public",i="GET",r={},a,o){let d=await this.fetch2(e,s,i,r,a,o);if("status"in d&&"error"===d.status)throw new t(this.id+" "+this.json(d));return d}};
//# sourceMappingURL=bitstamp1.js.map
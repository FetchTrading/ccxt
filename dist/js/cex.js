"use strict";const e=require("./base/Exchange"),{ExchangeError:t,NullResponse:i,InvalidOrder:s,NotSupported:r}=require("./base/errors");module.exports=class extends e{describe(){return this.deepExtend(super.describe(),{id:"cex",name:"CEX.IO",countries:["GB","EU","CY","RU"],rateLimit:1500,has:{CORS:!0,fetchTickers:!0,fetchOHLCV:!0,fetchOrder:!0,fetchOpenOrders:!0,fetchClosedOrders:!0,fetchDepositAddress:!0},timeframes:{"1m":"1m"},urls:{logo:"https://user-images.githubusercontent.com/1294454/27766442-8ddc33b0-5ed8-11e7-8b98-f786aef0f3c9.jpg",api:"https://cex.io/api",www:"https://cex.io",doc:"https://cex.io/cex-api",fees:["https://cex.io/fee-schedule","https://cex.io/limits-commissions"]},requiredCredentials:{apiKey:!0,secret:!0,uid:!0},api:{public:{get:["currency_limits/","last_price/{pair}/","last_prices/{currencies}/","ohlcv/hd/{yyyymmdd}/{pair}","order_book/{pair}/","ticker/{pair}/","tickers/{currencies}/","trade_history/{pair}/"],post:["convert/{pair}","price_stats/{pair}"]},private:{post:["active_orders_status/","archived_orders/{pair}/","balance/","cancel_order/","cancel_orders/{pair}/","cancel_replace_order/{pair}/","close_position/{pair}/","get_address/","get_myfee/","get_order/","get_order_tx/","open_orders/{pair}/","open_orders/","open_position/{pair}/","open_positions/{pair}/","place_order/{pair}/"]}},fees:{trading:{maker:.0016,taker:.0025},funding:{withdraw:{BTC:.001,ETH:.01,BCH:.001,DASH:.01,BTG:.001,ZEC:.001,XRP:.02},deposit:{BTC:0,ETH:0,BCH:0,DASH:0,BTG:0,ZEC:0,XRP:0,XLM:0}}},options:{fetchOHLCVWarning:!0}})}async fetchMarkets(){let e=await this.publicGetCurrencyLimits(),t=[];for(let i=0;i<e.data.pairs.length;i++){let s=e.data.pairs[i],r=s.symbol1+"/"+s.symbol2,a=r,[o,n]=a.split("/");t.push({id:r,info:s,symbol:a,base:o,quote:n,lot:s.minLotSize,precision:{price:this.precisionFromString(s.minPrice),amount:-1*Math.log10(s.minLotSize)},limits:{amount:{min:s.minLotSize,max:s.maxLotSize},price:{min:this.safeFloat(s,"minPrice"),max:this.safeFloat(s,"maxPrice")},cost:{min:s.minLotSizeS2,max:void 0}}})}return t}async fetchBalance(e={}){await this.loadMarkets();let t=await this.privatePostBalance(),i={info:t},s=this.omit(t,["username","timestamp"]),r=Object.keys(s);for(let e=0;e<r.length;e++){let t=r[e];if(t in s){let e={free:this.safeFloat(s[t],"available",0),used:this.safeFloat(s[t],"orders",0),total:0};e.total=this.sum(e.free,e.used),i[t]=e}}return this.parseBalance(i)}async fetchOrderBook(e,t,i={}){await this.loadMarkets();let s={pair:this.marketId(e)};void 0!==t&&(s.depth=t);let r=await this.publicGetOrderBookPair(this.extend(s,i)),a=1e3*r.timestamp;return this.parseOrderBook(r,a)}parseOHLCV(e,t,i="1m",s,r){return[1e3*e[0],e[1],e[2],e[3],e[4],e[5]]}async fetchOHLCV(e,s="1m",r,a,o={}){await this.loadMarkets();let n=this.market(e);if(r){if(this.options.fetchOHLCVWarning)throw new t(this.id+" fetchOHLCV warning: CEX can return historical candles for a certain date only, this might produce an empty or null response. Set exchange.options['fetchOHLCVWarning'] = false or add ({ 'options': { 'fetchOHLCVWarning': false }}) to constructor params to suppress this warning message.")}else r=this.milliseconds()-864e5;let d=this.ymd(r);d=(d=d.split("-")).join("");let c={pair:n.id,yyyymmdd:d};try{let e=await this.publicGetOhlcvHdYyyymmddPair(this.extend(c,o)),t="data"+this.timeframes[s],d=JSON.parse(e[t]);return this.parseOHLCVs(d,n,s,r,a)}catch(e){if(e instanceof i)return[]}}parseTicker(e,t){let i=void 0,s=void 0;"timestamp"in e&&(i=1e3*parseInt(e.timestamp),s=this.iso8601(i));let r=this.safeFloat(e,"volume"),a=this.safeFloat(e,"high"),o=this.safeFloat(e,"low"),n=this.safeFloat(e,"bid"),d=this.safeFloat(e,"ask"),c=this.safeFloat(e,"last"),h=void 0;return t&&(h=t.symbol),{symbol:h,timestamp:i,datetime:s,high:a,low:o,bid:n,bidVolume:void 0,ask:d,askVolume:void 0,vwap:void 0,open:void 0,close:c,last:c,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:r,quoteVolume:void 0,info:e}}async fetchTickers(e,t={}){await this.loadMarkets();let i=Object.keys(this.currencies),s=(await this.publicGetTickersCurrencies(this.extend({currencies:i.join("/")},t))).data,r={};for(let e=0;e<s.length;e++){let t=s[e],i=t.pair.replace(":","/"),a=this.markets[i];r[i]=this.parseTicker(t,a)}return r}async fetchTicker(e,t={}){await this.loadMarkets();let i=this.market(e),s=await this.publicGetTickerPair(this.extend({pair:i.id},t));return this.parseTicker(s,i)}parseTrade(e,t){let i=1e3*parseInt(e.date);return{info:e,id:e.tid,timestamp:i,datetime:this.iso8601(i),symbol:t.symbol,type:void 0,side:e.type,price:this.safeFloat(e,"price"),amount:this.safeFloat(e,"amount")}}async fetchTrades(e,t,i,s={}){await this.loadMarkets();let r=this.market(e),a=await this.publicGetTradeHistoryPair(this.extend({pair:r.id},s));return this.parseTrades(a,r,t,i)}async createOrder(e,t,i,r,a,o={}){await this.loadMarkets();let n={pair:this.marketId(e),type:i,amount:r};if("limit"===t)n.price=a;else{if("buy"===i){if(!a)throw new s("For market buy orders "+this.id+" requires the amount of quote currency to spend, to calculate proper costs call createOrder (symbol, 'market', 'buy', amount, price)");n.amount=r*a}n.order_type=t}let d=await this.privatePostPlaceOrderPair(this.extend(n,o));return{info:d,id:d.id}}async cancelOrder(e,t,i={}){return await this.loadMarkets(),await this.privatePostCancelOrder({id:e})}parseOrder(e,t){let i=e.time;i="string"==typeof e.time&&e.time.indexOf("T")>=0?this.parse8601(i):parseInt(i);let s=void 0;if(!t){let i=e.symbol1+"/"+e.symbol2;i in this.markets&&(t=this.market(i))}let r=e.status;"a"===r?r="open":"cd"===r?r="canceled":"c"===r?r="canceled":"d"===r&&(r="closed");let a=this.safeFloat(e,"price"),o=this.safeFloat(e,"amount"),n=this.safeFloat(e,"pending");n||(n=this.safeFloat(e,"remains"));let d=o-n,c=void 0,h=void 0;if(t){s=t.symbol,void 0===(h=this.safeFloat(e,"ta:"+t.quote))&&(h=this.safeFloat(e,"tta:"+t.quote));let i="fa:"+t.base,r="tfa:"+t.base,a="fa:"+t.quote,o="tfa:"+t.quote,n=this.safeFloat(e,"tradingFeeMaker");if(n||(n=this.safeFloat(e,"tradingFeeTaker",n)),n&&(n/=100),i in e||r in e){let s=this.safeFloat(e,i);void 0===s&&(s=this.safeFloat(e,r)),c={currency:t.base,rate:n,cost:s}}else if(a in e||o in e){let i=this.safeFloat(e,a);void 0===i&&(i=this.safeFloat(e,o)),c={currency:t.quote,rate:n,cost:i}}}return h||(h=a*d),{id:e.id,datetime:this.iso8601(i),timestamp:i,lastTradeTimestamp:void 0,status:r,symbol:s,type:void 0,side:e.type,price:a,cost:h,amount:o,filled:d,remaining:n,trades:void 0,fee:c,info:e}}async fetchOpenOrders(e,t,i,s={}){await this.loadMarkets();let r={},a="privatePostOpenOrders",o=void 0;e&&(o=this.market(e),r.pair=o.id,a+="Pair");let n=await this[a](this.extend(r,s));for(let e=0;e<n.length;e++)n[e]=this.extend(n[e],{status:"open"});return this.parseOrders(n,o,t,i)}async fetchClosedOrders(e,t,i,s={}){await this.loadMarkets();if(void 0===e)throw new r(this.id+" fetchClosedOrders requires a symbol argument");let a=this.market(e),o={pair:a.id},n=await this.privatePostArchivedOrdersPair(this.extend(o,s));return this.parseOrders(n,a,t,i)}async fetchOrder(e,t,i={}){await this.loadMarkets();let s=await this.privatePostGetOrder(this.extend({id:e.toString()},i));return this.parseOrder(s)}nonce(){return this.milliseconds()}sign(e,t="public",i="GET",s={},r,a){let o=this.urls.api+"/"+this.implodeParams(e,s),n=this.omit(s,this.extractParams(e));if("public"===t)Object.keys(n).length&&(o+="?"+this.urlencode(n));else{this.checkRequiredCredentials();let e=this.nonce().toString(),t=e+this.uid+this.apiKey,i=this.hmac(this.encode(t),this.encode(this.secret));a=this.urlencode(this.extend({key:this.apiKey,signature:i.toUpperCase(),nonce:e},n)),r={"Content-Type":"application/x-www-form-urlencoded"}}return{url:o,method:i,body:a,headers:r}}async request(e,s="public",r="GET",a={},o,n){let d=await this.fetch2(e,s,r,a,o,n);if(!d)throw new i(this.id+" returned "+this.json(d));if(!0===d)return d;if("e"in d){if("ok"in d&&"ok"===d.ok)return d;throw new t(this.id+" "+this.json(d))}if("error"in d&&d.error)throw new t(this.id+" "+this.json(d));return d}async fetchDepositAddress(e,t={}){if("XRP"===e)throw new r(this.id+" fetchDepositAddress does not support XRP addresses yet (awaiting docs from CEX.io)");await this.loadMarkets();let i={currency:this.currency(e).id},s=await this.privatePostGetAddress(this.extend(i,t)),a=this.safeString(s,"data");return this.checkAddress(a),{currency:e,address:a,tag:void 0,status:"ok",info:s}}};
//# sourceMappingURL=cex.js.map
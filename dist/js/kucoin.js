"use strict";const e=require("./base/Exchange"),{ExchangeError:t,InvalidNonce:i,InvalidOrder:s,AuthenticationError:a,InsufficientFunds:r,OrderNotFound:o}=require("./base/errors");module.exports=class extends e{describe(){return this.deepExtend(super.describe(),{id:"kucoin",name:"Kucoin",countries:"HK",version:"v1",rateLimit:2e3,userAgent:this.userAgents.chrome,has:{CORS:!1,cancelOrders:!0,createMarketOrder:!1,fetchDepositAddress:!0,fetchTickers:!0,fetchOHLCV:!0,fetchOrder:!0,fetchOrders:!1,fetchClosedOrders:!0,fetchOpenOrders:!0,fetchMyTrades:"emulated",fetchCurrencies:!0,withdraw:!0},timeframes:{"1m":1,"5m":5,"15m":15,"30m":30,"1h":60,"8h":480,"1d":"D","1w":"W"},urls:{logo:"https://user-images.githubusercontent.com/1294454/33795655-b3c46e48-dcf6-11e7-8abe-dc4588ba7901.jpg",api:{public:"https://api.kucoin.com",private:"https://api.kucoin.com",kitchen:"https://kitchen.kucoin.com","kitchen-2":"https://kitchen-2.kucoin.com"},www:"https://www.kucoin.com",referral:"https://www.kucoin.com/?r=E5wkqe",doc:"https://kucoinapidocs.docs.apiary.io",fees:"https://news.kucoin.com/en/fee"},api:{kitchen:{get:["open/chart/history"]},public:{get:["open/chart/config","open/chart/history","open/chart/symbol","open/currencies","open/deal-orders","open/kline","open/lang-list","open/orders","open/orders-buy","open/orders-sell","open/tick","market/open/coin-info","market/open/coins","market/open/coins-trending","market/open/symbols"]},private:{get:["account/balance","account/{coin}/wallet/address","account/{coin}/wallet/records","account/{coin}/balance","account/promotion/info","account/promotion/sum","deal-orders","order/active","order/active-map","order/dealt","order/detail","referrer/descendant/count","user/info"],post:["account/{coin}/withdraw/apply","account/{coin}/withdraw/cancel","account/promotion/draw","cancel-order","order","order/cancel-all","user/change-lang"]}},fees:{trading:{maker:.001,taker:.001},funding:{tierBased:!1,percentage:!1,withdraw:{KCS:2,BTC:5e-4,USDT:10,ETH:.01,LTC:.001,NEO:0,GAS:0,KNC:.5,BTM:5,QTUM:.1,EOS:.5,CVC:3,OMG:.1,PAY:.5,SNT:20,BHC:1,HSR:.01,WTC:.1,VEN:2,MTH:10,RPX:1,REQ:20,EVX:.5,MOD:.5,NEBL:.1,DGB:.5,CAG:2,CFD:.5,RDN:.5,UKG:5,BCPT:5,PPT:.1,BCH:5e-4,STX:2,NULS:1,GVT:.1,HST:2,PURA:.5,SUB:2,QSP:5,POWR:1,FLIXX:10,LEND:20,AMB:3,RHOC:2,R:2,DENT:50,DRGN:1,ACT:.1},deposit:{}}},options:{fetchOrderBookWarning:!0,timeDifference:0,adjustForTimeDifference:!1}})}nonce(){return this.milliseconds()-this.options.timeDifference}async loadTimeDifference(){const e=await this.publicGetOpenTick(),t=this.milliseconds();return this.options.timeDifference=parseInt(t-e.timestamp),this.options.timeDifference}async fetchMarkets(){let e=await this.publicGetMarketOpenSymbols();this.options.adjustForTimeDifference&&await this.loadTimeDifference();let t=e.data,i=[];for(let e=0;e<t.length;e++){let s=t[e],a=s.symbol,r=s.coinType,o=s.coinTypePair,n=(r=this.commonCurrencyCode(r))+"/"+(o=this.commonCurrencyCode(o)),d={amount:8,price:8},c=s.trading;i.push({id:a,symbol:n,base:r,quote:o,active:c,taker:this.safeFloat(s,"feeRate"),maker:this.safeFloat(s,"feeRate"),info:s,lot:Math.pow(10,-d.amount),precision:d,limits:{amount:{min:Math.pow(10,-d.amount),max:void 0},price:{min:void 0,max:void 0}}})}return i}async fetchDepositAddress(e,t={}){await this.loadMarkets();let i=this.currency(e),s=await this.privateGetAccountCoinWalletAddress(this.extend({coin:i.id},t)),a=s.data,r=this.safeString(a,"address");return this.checkAddress(r),{currency:e,address:r,tag:this.safeString(a,"userOid"),status:"ok",info:s}}async fetchCurrencies(e={}){let t=(await this.publicGetMarketOpenCoins(e)).data,i={};for(let e=0;e<t.length;e++){let s=t[e],a=s.coin,r=this.commonCurrencyCode(a),o=s.tradePrecision,n=s.enableDeposit,d=s.enableWithdraw,c=n&&d;i[r]={id:a,code:r,info:s,name:s.name,active:c,status:"ok",fee:s.withdrawMinFee,precision:o,limits:{amount:{min:Math.pow(10,-o),max:Math.pow(10,o)},price:{min:Math.pow(10,-o),max:Math.pow(10,o)},cost:{min:void 0,max:void 0},withdraw:{min:s.withdrawMinAmount,max:Math.pow(10,o)}}}}return i}async fetchBalance(e={}){await this.loadMarkets();let t=(await this.privateGetAccountBalance(this.extend({},e))).data,i={info:t},s=this.indexBy(t,"coinType"),a=Object.keys(s);for(let e=0;e<a.length;e++){let t=a[e],r=this.commonCurrencyCode(t),o=this.account(),n=s[t],d=parseFloat(n.freezeBalance),c=parseFloat(n.balance),h=this.sum(c,d);o.free=c,o.used=d,o.total=h,i[r]=o}return this.parseBalance(i)}async fetchOrderBook(e,i,s={}){await this.loadMarkets();let a={symbol:this.market(e).id};void 0!==i&&(a.limit=i);let r=await this.publicGetOpenOrders(this.extend(a,s)),o=void 0,n=void 0;if("data"in r&&r.data)o=r.data,n=this.safeInteger(r,"timestamp"),n=this.safeInteger(r.data,"timestamp",n);else{if(this.options.fetchOrderBookWarning)throw new t(this.id+" fetchOrderBook returned an null response. Set exchange.options['fetchOrderBookWarning'] = false to silence this warning");o={BUY:[],SELL:[]}}return this.parseOrderBook(o,n,"BUY","SELL")}parseOrder(e,t){let i=this.safeValue(e,"direction");void 0===i&&(i=e.type),void 0!==i&&(i=i.toLowerCase());let s=this.safeString(e,"orderOid");void 0===s&&(s=this.safeString(e,"oid"));let a=void 0;if("dealOrders"in e&&(a=this.safeValue(e.dealOrders,"datas")),void 0!==a){a=this.parseTrades(a,t);for(let e=0;e<a.length;e++)a[e].side=i,a[e].order=s}let r=void 0;r=void 0!==t?t.symbol:e.coinType+"/"+e.coinTypePair;let o=this.safeValue(e,"createdAt"),n=this.safeFloat(e,"pendingAmount"),d=this.safeValue(e,"status"),c=this.safeFloat(e,"dealAmount"),h=this.safeFloat(e,"amount"),l=this.safeFloat(e,"dealValue");if(void 0===l&&(l=this.safeFloat(e,"dealValueTotal")),void 0===d&&void 0!==n&&(d=n>0?"open":"closed"),void 0===c)void 0!==d&&"closed"===d&&(c=this.safeFloat(e,"amount"));else if(0===c&&void 0!==a){l=0;for(let e=0;e<a.length;e++)c+=a[e].amount,l+=a[e].cost}let p=void 0;void 0!==c&&(c>0?(void 0===(p=this.safeFloat(e,"price"))&&(p=this.safeFloat(e,"dealPrice")),void 0===p&&(p=this.safeFloat(e,"dealPriceAverage"))):void 0===(p=this.safeFloat(e,"orderPrice"))&&(p=this.safeFloat(e,"price")),void 0!==p&&void 0===l&&(l=p*c),void 0===h?void 0!==n&&(h=this.sum(c,n)):void 0===n&&(n=h-c)),"open"===d&&(void 0!==l&&0!==l||void 0!==p&&void 0!==h&&(l=h*p));let m=void 0;if(void 0!==t)m="sell"===i?t.quote:t.base;else{let t="sell"===i?"coinTypePair":"coinType",s=this.safeString(e,t);void 0!==s&&s in this.currencies_by_id&&(s=this.currencies_by_id[s].code)}let f=this.safeFloat(e,"fee"),u={cost:this.safeFloat(e,"feeTotal",f),rate:this.safeFloat(e,"feeRate"),currency:m};return{info:e,id:s,timestamp:o,datetime:this.iso8601(o),lastTradeTimestamp:void 0,symbol:r,type:"limit",side:i,price:p,amount:h,cost:l,filled:c,remaining:n,status:d,fee:u,trades:a}}async fetchOrder(e,i,s={}){if(void 0===i)throw new t(this.id+" fetchOrder requires a symbol argument");let a=this.safeValue(s,"type");if(void 0===a)throw new t(this.id+' fetchOrder requires a type parameter ("BUY" or "SELL")');await this.loadMarkets();let r=this.market(i),n={symbol:r.id,type:a,orderOid:e},d=await this.privateGetOrderDetail(this.extend(n,s));if(!d.data)throw new o(this.id+" "+this.json(d));return this.parseOrder(d.data,r)}parseOrdersByStatus(e,t,i,s,a){let r=[];for(let i=0;i<e.length;i++){let s=this.parseOrder(this.extend(e[i],{status:a}),t);r.push(s)}let o=void 0!==t?t.symbol:void 0;return this.filterBySymbolSinceLimit(r,o,i,s)}async fetchOpenOrders(e,i,s,a={}){if(!e)throw new t(this.id+" fetchOpenOrders requires a symbol");await this.loadMarkets();let r=this.market(e),o={symbol:r.id},n=await this.privateGetOrderActiveMap(this.extend(o,a)),d=this.safeValue(n.data,"SELL");void 0===d&&(d=[]);let c=this.safeValue(n.data,"BUY");void 0===c&&(c=[]);let h=this.arrayConcat(d,c);return this.parseOrdersByStatus(h,r,i,s,"open")}async fetchClosedOrders(e,t,i=20,s={}){let a={};await this.loadMarkets();let r=void 0;void 0!==e&&(r=this.market(e),a.symbol=r.id),void 0!==t&&(a.since=t),void 0!==i&&(a.limit=i);let o=(await this.privateGetOrderDealt(this.extend(a,s))).data.datas;return this.parseOrdersByStatus(o,r,t,i,"closed")}async createOrder(e,i,s,a,r,o={}){if("limit"!==i)throw new t(this.id+" allows limit orders only");await this.loadMarkets();let n=this.market(e),d=n.quote,c=n.base,h={symbol:n.id,type:s.toUpperCase(),price:this.truncate(r,this.currencies[d].precision),amount:this.truncate(a,this.currencies[c].precision)},l=(r=parseFloat(r))*(a=parseFloat(a)),p=await this.privatePostOrder(this.extend(h,o)),m=this.safeString(p.data,"orderOid"),f=this.safeInteger(p,"timestamp"),u=void 0;void 0!==f&&(u=this.iso8601(f));let w={info:p,id:m,timestamp:f,datetime:u,lastTradeTimestamp:void 0,symbol:n.symbol,type:i,side:s,amount:a,filled:void 0,remaining:void 0,price:r,cost:l,status:"open",fee:void 0,trades:void 0};return this.orders[m]=w,w}async cancelOrders(e,t={}){let i={};if(e){await this.loadMarkets();let t=this.market(e);i.symbol=t.id}return"type"in t&&(i.type=t.type.toUpperCase(),t=this.omit(t,"type")),await this.privatePostOrderCancelAll(this.extend(i,t))}async cancelOrder(e,i,s={}){if(void 0===i)throw new t(this.id+" cancelOrder requires a symbol");await this.loadMarkets();let a={symbol:this.market(i).id,orderOid:e};if(!("type"in s))throw new t(this.id+' cancelOrder requires parameter type=["BUY"|"SELL"]');return a.type=s.type.toUpperCase(),s=this.omit(s,"type"),await this.privatePostCancelOrder(this.extend(a,s))}parseTicker(e,t){let i=e.datetime,s=void 0;s=t?t.symbol:e.coinType+"/"+e.coinTypePair;let a=this.safeFloat(e,"change"),r=this.safeFloat(e,"lastDealPrice"),o=void 0;void 0!==r&&void 0!==a&&(o=r-a);let n=this.safeFloat(e,"changeRate");return{symbol:s,timestamp:i,datetime:this.iso8601(i),high:this.safeFloat(e,"high"),low:this.safeFloat(e,"low"),bid:this.safeFloat(e,"buy"),bidVolume:void 0,ask:this.safeFloat(e,"sell"),askVolume:void 0,vwap:void 0,open:o,close:r,last:r,previousClose:void 0,change:a,percentage:n,average:void 0,baseVolume:this.safeFloat(e,"vol"),quoteVolume:this.safeFloat(e,"volValue"),info:e}}async fetchTickers(e,t={}){let i=(await this.publicGetMarketOpenSymbols(t)).data,s={};for(let e=0;e<i.length;e++){let t=this.parseTicker(i[e]);s[t.symbol]=t}return s}async fetchTicker(e,t={}){await this.loadMarkets();let i=this.market(e),s=(await this.publicGetOpenTick(this.extend({symbol:i.id},t))).data;return this.parseTicker(s,i)}parseTrade(e,t){let i=void 0,s=void 0,a=e,r=void 0,o=void 0,n=void 0,d=void 0,c=void 0,h=void 0,l=void 0;if(Array.isArray(e))r=e[0],o="limit","BUY"===e[1]?n="buy":"SELL"===e[1]&&(n="sell"),d=e[2],h=e[3];else{r=this.safeValue(e,"createdAt"),s=this.safeString(e,"orderOid"),i=this.safeString(e,"oid"),void 0!==(n=this.safeString(e,"direction"))&&(n=n.toLowerCase()),d=this.safeFloat(e,"dealPrice"),h=this.safeFloat(e,"amount"),c=this.safeFloat(e,"dealValue");let a=void 0;if(void 0!==t)a="sell"===n?t.quote:t.base;else{let e="sell"===n?"coinTypePair":"coinType",t=this.safeString(s,e);void 0!==t&&t in this.currencies_by_id&&(t=this.currencies_by_id[t].code)}l={cost:this.safeFloat(e,"fee"),currency:a}}let p=void 0;return void 0!==t&&(p=t.symbol),{id:i,order:s,info:a,timestamp:r,datetime:this.iso8601(r),symbol:p,type:o,side:n,price:d,cost:c,amount:h,fee:l}}async fetchTrades(e,t,i,s={}){await this.loadMarkets();let a=this.market(e),r=await this.publicGetOpenDealOrders(this.extend({symbol:a.id,limit:i},s));return this.parseTrades(r.data,a,t,i)}async fetchMyTrades(e,i,s,a={}){if(!e)throw new t(this.id+" fetchMyTrades is deprecated and requires a symbol argument");await this.loadMarkets();let r=this.market(e),o={symbol:r.id};s&&(o.limit=s);let n=await this.privateGetDealOrders(this.extend(o,a));return this.parseTrades(n.data.datas,r,i,s)}parseTradingViewOHLCV(e,t,i="1m",s,a){let r=this.convertTradingViewToOHLCV(e);return this.parseOHLCVs(r,t,i,s,a)}async fetchOHLCV(e,t="1m",i,s,a={}){await this.loadMarkets();let r=this.market(e),o=this.seconds(),n=this.timeframes[t],d=n;"D"===d?(void 0===s&&(s=30),d=1440):"W"===d?(void 0===s&&(s=52),d=10080):void 0===s&&(s=1440);let c=o-s*d*60;void 0!==i&&(c=parseInt(i/1e3),o=Math.min(o,this.sum(c,s*d*60)));let h={symbol:r.id,resolution:n,from:c,to:o},l=await this.publicGetOpenChartHistory(this.extend(h,a));return this.parseTradingViewOHLCV(l,r,t,i,s)}async withdraw(e,t,i,s,a={}){this.checkAddress(i),await this.loadMarkets();let r=this.currency(e);return this.checkAddress(i),{info:await this.privatePostAccountCoinWithdrawApply(this.extend({coin:r.id,amount:t,address:i},a)),id:void 0}}sign(e,t="public",i="GET",s={},a,r){let o="/"+this.version+"/"+this.implodeParams(e,s),n=this.urls.api[t]+o,d=this.omit(s,this.extractParams(e));if("private"===t){this.checkRequiredCredentials();let e=this.nonce(),t="";e=e.toString(),Object.keys(d).length&&(n+="?"+(t=this.rawencode(this.keysort(d))),"GET"!==i&&(r=t));let s=o+"/"+e+"/"+t,c=this.stringToBase64(this.encode(s)),h=this.hmac(c,this.encode(this.secret),"sha256");a={"KC-API-KEY":this.apiKey,"KC-API-NONCE":e,"KC-API-SIGNATURE":h}}else Object.keys(d).length&&(n+="?"+this.urlencode(d));return{url:n,method:i,body:r,headers:a}}throwExceptionOnError(e){if(!("success"in e))return;if(!0===e.success)return;if(!("code"in e&&"msg"in e))throw new t(this.id+": malformed response: "+this.json(e));const o=this.safeString(e,"code"),n=this.safeString(e,"msg"),d=this.id+" "+this.json(e);if("UNAUTH"===o){if("Invalid nonce"===n)throw new i(d);throw new a(d)}if("ERROR"===o){if(n.indexOf("The precision of amount")>=0)throw new s(d);if(n.indexOf("Min amount each order")>=0)throw new s(d);if(n.indexOf("Min price:")>=0)throw new s(d);if(n.indexOf("Max price:")>=0)throw new s(d);if(n.indexOf("The precision of price")>=0)throw new s(d)}else if("NO_BALANCE"===o&&n.indexOf("Insufficient balance")>=0)throw new r(d);throw new t(this.id+": unknown response: "+this.json(e))}handleErrors(e,t,i,s,a,r,o){void 0!==o?this.throwExceptionOnError(o):r&&"{"===r[0]&&this.throwExceptionOnError(JSON.parse(r))}};
//# sourceMappingURL=kucoin.js.map
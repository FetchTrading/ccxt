"use strict";const e=require("./base/Exchange"),{ExchangeError:t,AuthenticationError:i,NotSupported:a,InvalidOrder:s,OrderNotFound:r,ExchangeNotAvailable:n,DDoSProtection:o,InsufficientFunds:c}=require("./base/errors");module.exports=class extends e{describe(){return this.deepExtend(super.describe(),{id:"livecoin",name:"LiveCoin",countries:["US","UK","RU"],rateLimit:1e3,userAgent:this.userAgents.chrome,has:{fetchDepositAddress:!0,CORS:!1,fetchTickers:!0,fetchCurrencies:!0,fetchTradingFees:!0,fetchOrders:!0,fetchOrder:!0,fetchOpenOrders:!0,fetchClosedOrders:!0,withdraw:!0},urls:{logo:"https://user-images.githubusercontent.com/1294454/27980768-f22fc424-638a-11e7-89c9-6010a54ff9be.jpg",api:"https://api.livecoin.net",www:"https://www.livecoin.net",doc:"https://www.livecoin.net/api?lang=en"},api:{public:{get:["exchange/all/order_book","exchange/last_trades","exchange/maxbid_minask","exchange/order_book","exchange/restrictions","exchange/ticker","info/coinInfo"]},private:{get:["exchange/client_orders","exchange/order","exchange/trades","exchange/commission","exchange/commissionCommonInfo","payment/balances","payment/balance","payment/get/address","payment/history/size","payment/history/transactions"],post:["exchange/buylimit","exchange/buymarket","exchange/cancellimit","exchange/selllimit","exchange/sellmarket","payment/out/capitalist","payment/out/card","payment/out/coin","payment/out/okpay","payment/out/payeer","payment/out/perfectmoney","payment/voucher/amount","payment/voucher/make","payment/voucher/redeem"]}},fees:{trading:{tierBased:!1,percentage:!0,maker:.0018,taker:.0018}},commonCurrencies:{CPC:"Capricoin",CRC:"CryCash",ORE:"Orectic",RUR:"RUB",TPI:"ThaneCoin",XBT:"Bricktox"},exceptions:{1:t,10:i,100:t,101:i,102:i,103:s,104:s,105:s,11:i,12:i,2:i,20:i,30:i,31:a,32:t,429:o,503:n}})}async fetchMarkets(){let e=await this.publicGetExchangeTicker(),t=await this.publicGetExchangeRestrictions(),i=this.indexBy(t.restrictions,"currencyPair"),a=[];for(let t=0;t<e.length;t++){let s=e[t],r=s.symbol,n=r,[o,c]=n.split("/"),d=this.commonCurrencyCode(o),h=this.commonCurrencyCode(c),l=this.safeValue(i,n),m={price:5,amount:8,cost:8},u={amount:{min:Math.pow(10,-m.amount),max:Math.pow(10,m.amount)}};l&&(m.price=this.safeInteger(l,"priceScale",5),u.amount.min=this.safeFloat(l,"minLimitQuantity",u.amount.min)),u.price={min:Math.pow(10,-m.price),max:Math.pow(10,m.price)},a.push({id:r,symbol:n,base:d,quote:h,baseId:o,quoteId:c,active:!0,precision:m,limits:u,info:s})}return a}async fetchCurrencies(e={}){let t=(await this.publicGetInfoCoinInfo(e)).info,i={};for(let e=0;e<t.length;e++){let a=t[e],s=a.symbol,r=this.commonCurrencyCode(s),n=8,o="normal"===a.walletStatus;i[r]={id:s,code:r,info:a,name:a.name,active:o,status:"ok",fee:a.withdrawFee,precision:n,limits:{amount:{min:a.minOrderAmount,max:Math.pow(10,n)},price:{min:Math.pow(10,-n),max:Math.pow(10,n)},cost:{min:a.minOrderAmount,max:void 0},withdraw:{min:a.minWithdrawAmount,max:Math.pow(10,n)},deposit:{min:a.minDepositAmount,max:void 0}}}}return i=this.appendFiatCurrencies(i)}appendFiatCurrencies(e=[]){let t={info:void 0,active:!0,status:"ok",fee:void 0,precision:8,limits:{withdraw:{min:void 0,max:void 0},deposit:{min:void 0,max:void 0},amount:{min:void 0,max:void 0},cost:{min:void 0,max:void 0},price:{min:Math.pow(10,-8),max:Math.pow(10,8)}}},i=[{id:"USD",code:"USD",name:"US Dollar"},{id:"EUR",code:"EUR",name:"Euro"}];i.push({id:"RUR",code:this.commonCurrencyCode("RUR"),name:"Russian ruble"});for(let a=0;a<i.length;a++){let s=i[a];e[s.code]=this.extend(t,s)}return e}async fetchBalance(e={}){await this.loadMarkets();let t=await this.privateGetPaymentBalances(),i={info:t};for(let e=0;e<t.length;e++){let a=t[e],s=a.currency,r=void 0;r=s in i?i[s]:this.account(),"total"===a.type&&(r.total=parseFloat(a.value)),"available"===a.type&&(r.free=parseFloat(a.value)),"trade"===a.type&&(r.used=parseFloat(a.value)),i[s]=r}return this.parseBalance(i)}async fetchTradingFees(e={}){await this.loadMarkets();let t=await this.privateGetExchangeCommissionCommonInfo(e);const i=this.safeFloat(t,"commission");return{info:t,maker:i,taker:i}}async fetchOrderBook(e,t,i={}){await this.loadMarkets();let a={currencyPair:this.marketId(e),groupByPrice:"false"};void 0!==t&&(a.depth=t);let s=await this.publicGetExchangeOrderBook(this.extend(a,i)),r=s.timestamp;return this.parseOrderBook(s,r)}parseTicker(e,t){let i=this.milliseconds(),a=void 0;t&&(a=t.symbol);let s=this.safeFloat(e,"vwap"),r=this.safeFloat(e,"volume"),n=r*s,o=this.safeFloat(e,"last");return{symbol:a,timestamp:i,datetime:this.iso8601(i),high:this.safeFloat(e,"high"),low:this.safeFloat(e,"low"),bid:this.safeFloat(e,"best_bid"),bidVolume:void 0,ask:this.safeFloat(e,"best_ask"),askVolume:void 0,vwap:this.safeFloat(e,"vwap"),open:void 0,close:o,last:o,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:r,quoteVolume:n,info:e}}async fetchTickers(e,t={}){await this.loadMarkets();let i=await this.publicGetExchangeTicker(t),a=this.indexBy(i,"symbol"),s=Object.keys(a),r={};for(let e=0;e<s.length;e++){let t=s[e],i=this.markets_by_id[t],n=i.symbol,o=a[t];r[n]=this.parseTicker(o,i)}return r}async fetchTicker(e,t={}){await this.loadMarkets();let i=this.market(e),a=await this.publicGetExchangeTicker(this.extend({currencyPair:i.id},t));return this.parseTicker(a,i)}parseTrade(e,t){let i=1e3*e.time;return{info:e,timestamp:i,datetime:this.iso8601(i),symbol:t.symbol,id:e.id.toString(),order:void 0,type:void 0,side:e.type.toLowerCase(),price:e.price,amount:e.quantity}}async fetchTrades(e,t,i,a={}){await this.loadMarkets();let s=this.market(e),r=await this.publicGetExchangeLastTrades(this.extend({currencyPair:s.id},a));return this.parseTrades(r,s,t,i)}async fetchOrder(e,t,i={}){await this.loadMarkets();let a={orderId:e},s=await this.privateGetExchangeOrder(this.extend(a,i));return this.parseOrder(s)}parseOrderStatus(e){const t={OPEN:"open",PARTIALLY_FILLED:"open",EXECUTED:"closed",PARTIALLY_FILLED_AND_CANCELLED:"canceled"};return e in t?t[e]:e}parseOrder(e,t){let i=void 0,a=void 0;"lastModificationTime"in e&&void 0!==(i=this.safeString(e,"lastModificationTime"))&&(i=i.indexOf("T")>=0?this.parse8601(i):this.safeInteger(e,"lastModificationTime")),i&&(a=this.iso8601(i));let s=this.safeString(e,"status");s=this.safeString(e,"orderStatus",s),s=this.parseOrderStatus(s);let r=void 0;if(void 0===t){let i=this.safeString(e,"currencyPair");(i=this.safeString(e,"symbol",i))in this.markets_by_id&&(t=this.markets_by_id[i])}let n=void 0,o=void 0;if("type"in e){let t=e.type.toLowerCase().split("_");n=t[0],o=t[1]}let c=this.safeFloat(e,"price"),d=this.safeFloat(e,"remainingQuantity");d=this.safeFloat(e,"remaining_quantity",d);let h=this.safeFloat(e,"quantity",d),l=void 0;void 0!==d&&(l=h-d);let m=void 0;void 0!==l&&void 0!==c&&(m=l*c);const u=this.safeFloat(e,"commission_rate");let p=void 0;void 0!==m&&(p=m*u);let f=void 0;return void 0!==t&&(r=t.symbol,f=t.quote),{info:e,id:e.id,timestamp:i,datetime:a,lastTradeTimestamp:void 0,status:s,symbol:r,type:n,side:o,price:c,amount:h,cost:m,filled:l,remaining:d,trades:void 0,fee:{cost:p,currency:f,rate:u}}}async fetchOrders(e,t,i,a={}){await this.loadMarkets();let s=void 0,r={};void 0!==e&&(s=this.market(e),r.currencyPair=s.id),void 0!==t&&(r.issuedFrom=parseInt(t)),void 0!==i&&(r.endRow=i-1);let n=await this.privateGetExchangeClientOrders(this.extend(r,a)),o=[],c=[];n.data&&(c=n.data);for(let e=0;e<c.length;e++){let t=c[e];o.push(this.parseOrder(t,s))}return o}async fetchOpenOrders(e,t,i,a={}){return await this.fetchOrders(e,t,i,this.extend({openClosed:"OPEN"},a))}async fetchClosedOrders(e,t,i,a={}){return await this.fetchOrders(e,t,i,this.extend({openClosed:"CLOSED"},a))}async createOrder(e,t,i,a,s,r={}){await this.loadMarkets();let n="privatePostExchange"+this.capitalize(i)+t,o=this.market(e),c={quantity:this.amountToPrecision(e,a),currencyPair:o.id};"limit"===t&&(c.price=this.priceToPrecision(e,s));let d=await this[n](this.extend(c,r));const h={info:d,id:d.orderId.toString()};return this.safeValue(d,"success")&&(h.status="open"),h}async cancelOrder(e,i,a={}){if(!i)throw new t(this.id+" cancelOrder requires a symbol argument");await this.loadMarkets();let n=this.market(i).id,o=await this.privatePostExchangeCancellimit(this.extend({orderId:e,currencyPair:n},a)),c=this.safeString(o,"message",this.json(o));if("success"in o){if(!o.success)throw new s(c);if("cancelled"in o){if(o.cancelled)return{status:"canceled",info:o};throw new r(c)}}throw new t(this.id+" cancelOrder() failed: "+this.json(o))}async withdraw(e,t,i,a,s={}){await this.loadMarkets(),this.checkAddress(i);let r=i;void 0!==a&&(r+="::"+a);let n={amount:this.truncate(t,this.currencies[e].precision),currency:this.commonCurrencyCode(e),wallet:r},o=await this.privatePostPaymentOutCoin(this.extend(n,s)),d=this.safeInteger(o,"id");if(void 0===d)throw new c(this.id+" insufficient funds to cover requested withdrawal amount post fees "+this.json(o));return{info:o,id:d}}async fetchDepositAddress(e,t={}){let i={currency:e},a=await this.privateGetPaymentGetAddress(this.extend(i,t)),s=this.safeString(a,"wallet"),r=void 0;if(s.indexOf(":")>=0){let e=s.split(":");s=e[0],r=e[2]}return this.checkAddress(s),{currency:e,address:s,tag:r,status:"ok",info:a}}sign(e,t="public",i="GET",a={},s,r){let n=this.urls.api+"/"+e,o=this.urlencode(this.keysort(a));if("GET"===i&&Object.keys(a).length&&(n+="?"+o),"private"===t){this.checkRequiredCredentials(),"POST"===i&&(r=o);let e=this.hmac(this.encode(o),this.encode(this.secret),"sha256");s={"Api-Key":this.apiKey,Sign:e.toUpperCase(),"Content-Type":"application/x-www-form-urlencoded"}}return{url:n,method:i,body:r,headers:s}}handleErrors(e,i,a,s,n,o){if("string"==typeof o&&"{"===o[0]){let i=JSON.parse(o);if(e>=300){let e=this.safeString(i,"errorCode");if(e in this.exceptions){throw new(0,this.exceptions[e])(this.id+" "+o)}throw new t(this.id+" "+o)}if(!this.safeValue(i,"success",!0)){if(this.safeString(i,"message","").indexOf("Cannot find order")>=0)throw new r(this.id+" "+o);throw new t(this.id+" "+o)}}}};
//# sourceMappingURL=livecoin.js.map
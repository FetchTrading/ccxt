"use strict";const e=require("./base/Exchange"),{ExchangeError:t,ExchangeNotAvailable:i,InsufficientFunds:s,OrderNotFound:r,DDoSProtection:a,InvalidOrder:o,AuthenticationError:n}=require("./base/errors");module.exports=class extends e{describe(){return this.deepExtend(super.describe(),{id:"liqui",name:"Liqui",countries:"UA",rateLimit:3e3,version:"3",userAgent:this.userAgents.chrome,has:{CORS:!1,createMarketOrder:!1,fetchOrderBooks:!0,fetchOrder:!0,fetchOrders:"emulated",fetchOpenOrders:!0,fetchClosedOrders:"emulated",fetchTickers:!0,fetchMyTrades:!0,withdraw:!0},urls:{logo:"https://user-images.githubusercontent.com/1294454/27982022-75aea828-63a0-11e7-9511-ca584a8edd74.jpg",api:{public:"https://api.liqui.io/api",private:"https://api.liqui.io/tapi"},www:"https://liqui.io",doc:"https://liqui.io/api",fees:"https://liqui.io/fee"},api:{public:{get:["info","ticker/{pair}","depth/{pair}","trades/{pair}"]},private:{post:["getInfo","Trade","ActiveOrders","OrderInfo","CancelOrder","TradeHistory","CoinDepositAddress","WithdrawCoin","CreateCoupon","RedeemCoupon"]}},fees:{trading:{maker:.001,taker:.0025},funding:{tierBased:!1,percentage:!1,withdraw:{},deposit:{}}},commonCurrencies:{DSH:"DASH"},exceptions:{803:o,804:o,805:o,806:o,807:o,831:s,832:s,833:r}})}calculateFee(e,t,i,s,r,a="taker",o={}){let n=this.markets[e],d="quote",h=n[a],l=parseFloat(this.costToPrecision(e,s*h));return"sell"===i?l*=r:d="base",{type:a,currency:n[d],rate:h,cost:l}}getBaseQuoteFromMarketId(e){let t=e.toUpperCase(),[i,s]=t.split("_");return[i=this.commonCurrencyCode(i),s=this.commonCurrencyCode(s)]}async fetchMarkets(){let e=(await this.publicGetInfo()).pairs,t=Object.keys(e),i=[];for(let s=0;s<t.length;s++){let r=t[s],a=e[r],[o,n]=this.getBaseQuoteFromMarketId(r),d=o+"/"+n,h={amount:this.safeInteger(a,"decimal_places"),price:this.safeInteger(a,"decimal_places")},l={amount:{min:this.safeFloat(a,"min_amount"),max:this.safeFloat(a,"max_amount")},price:{min:this.safeFloat(a,"min_price"),max:this.safeFloat(a,"max_price")},cost:{min:this.safeFloat(a,"min_total")}},c=0===this.safeInteger(a,"hidden");i.push({id:r,symbol:d,base:o,quote:n,active:c,taker:a.fee/100,precision:h,limits:l,info:a})}return i}async fetchBalance(e={}){await this.loadMarkets();let t=(await this.privatePostGetInfo()).return,i={info:t},s=t.funds,r=Object.keys(s);for(let e=0;e<r.length;e++){let a=r[e],o=a.toUpperCase();o=this.commonCurrencyCode(o);let n=void 0,d=void 0;0===t.open_orders&&(n=s[a],d=0);let h={free:s[a],used:d,total:n};i[o]=h}return this.parseBalance(i)}async fetchOrderBook(e,i,s={}){await this.loadMarkets();let r=this.market(e),a={pair:r.id};void 0!==i&&(a.limit=i);let o=await this.publicGetDepthPair(this.extend(a,s));if(!(r.id in o))throw new t(this.id+" "+r.symbol+" order book is empty or not available");let n=o[r.id];return this.parseOrderBook(n)}async fetchOrderBooks(e,i={}){await this.loadMarkets();let s=void 0;if(e)s=(s=this.marketIds(e)).join("-");else if((s=this.ids.join("-")).length>2048){let e=this.ids.length;throw new t(this.id+" has "+e.toString()+" symbols exceeding max URL length, you are required to specify a list of symbols in the first argument to fetchOrderBooks")}let r=await this.publicGetDepthPair(this.extend({pair:s},i)),a={};s=Object.keys(r);for(let e=0;e<s.length;e++){let t=s[e],i=t;if(t in this.markets_by_id){i=this.markets_by_id[t].symbol}a[i]=this.parseOrderBook(r[t])}return a}parseTicker(e,t){let i=1e3*e.updated,s=void 0;t&&(s=t.symbol);let r=this.safeFloat(e,"last");return{symbol:s,timestamp:i,datetime:this.iso8601(i),high:this.safeFloat(e,"high"),low:this.safeFloat(e,"low"),bid:this.safeFloat(e,"buy"),bidVolume:void 0,ask:this.safeFloat(e,"sell"),askVolume:void 0,vwap:void 0,open:void 0,close:r,last:r,previousClose:void 0,change:void 0,percentage:void 0,average:this.safeFloat(e,"avg"),baseVolume:this.safeFloat(e,"vol_cur"),quoteVolume:this.safeFloat(e,"vol"),info:e}}async fetchTickers(e,i={}){await this.loadMarkets();let s=void 0;if(e)s=(s=this.marketIds(e)).join("-");else if((s=this.ids.join("-")).length>2048){let e=this.ids.length;throw new t(this.id+" has "+e.toString()+" symbols exceeding max URL length, you are required to specify a list of symbols in the first argument to fetchTickers")}let r=await this.publicGetTickerPair(this.extend({pair:s},i)),a={},o=Object.keys(r);for(let e=0;e<o.length;e++){let t=o[e],i=r[t],s=t,n=void 0;t in this.markets_by_id&&(s=(n=this.markets_by_id[t]).symbol),a[s]=this.parseTicker(i,n)}return a}async fetchTicker(e,t={}){return(await this.fetchTickers([e],t))[e]}parseTrade(e,t){let i=1e3*parseInt(e.timestamp),s=e.type;"ask"===s&&(s="sell"),"bid"===s&&(s="buy");let r=this.safeFloat(e,"price");"rate"in e&&(r=this.safeFloat(e,"rate"));let a=this.safeString(e,"tid");"trade_id"in e&&(a=this.safeString(e,"trade_id"));let o=this.safeString(e,this.getOrderIdKey());if("pair"in e){let i=e.pair;t=this.markets_by_id[i]}let n=void 0;t&&(n=t.symbol);let d=e.amount,h=this.safeValue(e,"is_your_order"),l="taker";void 0!==h&&h&&(l="maker");let c=this.calculateFee(n,"limit",s,d,r,l);return{id:a,order:o,timestamp:i,datetime:this.iso8601(i),symbol:n,type:"limit",side:s,price:r,amount:d,fee:c,info:e}}async fetchTrades(e,t,i,s={}){await this.loadMarkets();let r=this.market(e),a={pair:r.id};void 0!==i&&(a.limit=i);let o=await this.publicGetTradesPair(this.extend(a,s));return this.parseTrades(o[r.id],r,t,i)}async createOrder(e,i,s,r,a,o={}){if("market"===i)throw new t(this.id+" allows limit orders only");await this.loadMarkets();let n={pair:this.market(e).id,type:s,amount:this.amountToPrecision(e,r),rate:this.priceToPrecision(e,a)};a=parseFloat(a),r=parseFloat(r);let d=await this.privatePostTrade(this.extend(n,o)),h=void 0,l="open",c=0,u=r;"return"in d&&("0"===(h=this.safeString(d.return,this.getOrderIdKey()))&&(h=this.safeString(d.return,"init_order_id"),l="closed"),c=this.safeFloat(d.return,"received",0),u=this.safeFloat(d.return,"remains",r));let p=this.milliseconds(),m={id:h,timestamp:p,datetime:this.iso8601(p),lastTradeTimestamp:void 0,status:l,symbol:e,type:i,side:s,price:a,cost:a*c,amount:r,remaining:u,filled:c,fee:void 0};return this.orders[h]=m,this.extend({info:d},m)}getOrderIdKey(){return"order_id"}async cancelOrder(e,t,i={}){await this.loadMarkets();let s=void 0,r={};return r[this.getOrderIdKey()]=e,s=await this.privatePostCancelOrder(this.extend(r,i)),e in this.orders&&(this.orders[e].status="canceled"),s}parseOrderStatus(e){let t={0:"open",1:"closed",2:"canceled",3:"canceled"};return e in t?t[e]:e}parseOrder(e,t){let i=e.id.toString(),s=this.safeString(e,"status");"undefined"!==s&&(s=this.parseOrderStatus(s));let r=1e3*parseInt(e.timestamp_created),a=void 0;t||(t=this.markets_by_id[e.pair]),t&&(a=t.symbol);let o=void 0,n=void 0,d=this.safeFloat(e,"rate"),h=void 0,l=void 0;"start_amount"in e?(n=this.safeFloat(e,"start_amount"),o=this.safeFloat(e,"amount")):(o=this.safeFloat(e,"amount"),i in this.orders&&(n=this.orders[i].amount)),void 0!==n&&void 0!==o&&(l=d*(h=n-o));return{info:e,id:i,symbol:a,timestamp:r,datetime:this.iso8601(r),lastTradeTimestamp:void 0,type:"limit",side:e.type,price:d,cost:l,amount:n,remaining:o,filled:h,status:s,fee:void 0}}parseOrders(e,t,i,s){let r=Object.keys(e),a=[];for(let i=0;i<r.length;i++){let s=r[i],o=e[s],n=this.extend(o,{id:s});a.push(this.parseOrder(n,t))}return this.filterBySinceLimit(a,i,s)}async fetchOrder(e,t,i={}){await this.loadMarkets();let s=await this.privatePostOrderInfo(this.extend({order_id:parseInt(e)},i));e=e.toString();let r=this.parseOrder(this.extend({id:e},s.return[e])),a=e in this.orders?this.orders[e]:{};return this.orders[e]=this.extend(a,r),this.orders[e]}updateCachedOrders(e,t){for(let t=0;t<e.length;t++){const i=e[t].id;this.orders[i]=e[t]}let i=this.indexBy(e,"id"),s=Object.keys(this.orders);for(let e=0;e<s.length;e++){let r=s[e],a=this.orders[r];if(!(r in i)){if(void 0!==t&&t!==a.symbol)continue;"open"===a.status&&(void 0===(a=this.extend(a,{status:"closed",cost:void 0,filled:a.amount,remaining:0})).cost&&void 0!==a.filled&&(a.cost=a.filled*a.price),this.orders[r]=a)}}return this.toArray(this.orders)}async fetchOrders(e,i,s,r={}){if("fetchOrdersRequiresSymbol"in this.options&&this.options.fetchOrdersRequiresSymbol&&void 0===e)throw new t(this.id+" fetchOrders requires a symbol argument");await this.loadMarkets();let a={};if(void 0!==e){let t=this.market(e);a.pair=t.id}let o=await this.privatePostActiveOrders(this.extend(a,r)),n=[];"return"in o&&(n=this.parseOrders(o.return,void 0));let d=this.updateCachedOrders(n,e),h=this.filterBySymbol(d,e);return this.filterBySinceLimit(h,i,s)}async fetchOpenOrders(e,t,i,s={}){let r=await this.fetchOrders(e,t,i,s);return this.filterBy(r,"status","open")}async fetchClosedOrders(e,t,i,s={}){let r=await this.fetchOrders(e,t,i,s);return this.filterBy(r,"status","closed")}async fetchMyTrades(e,t,i,s={}){await this.loadMarkets();let r=void 0,a={};void 0!==e&&(r=this.market(e),a.pair=r.id),void 0!==i&&(a.count=parseInt(i)),void 0!==t&&(a.since=parseInt(t/1e3));let o=await this.privatePostTradeHistory(this.extend(a,s)),n=[];return"return"in o&&(n=o.return),this.parseTrades(n,r,t,i)}async withdraw(e,t,i,s,r={}){this.checkAddress(i),await this.loadMarkets();let a=await this.privatePostWithdrawCoin(this.extend({coinName:e,amount:parseFloat(t),address:i},r));return{info:a,id:a.return.tId}}signBodyWithSecret(e){return this.hmac(this.encode(e),this.encode(this.secret),"sha512")}getVersionString(){return"/"+this.version}sign(e,t="public",i="GET",s={},r,a){let o=this.urls.api[t],n=this.omit(s,this.extractParams(e));if("private"===t){this.checkRequiredCredentials();let t=this.nonce();a=this.urlencode(this.extend({nonce:t,method:e},n));let i=this.signBodyWithSecret(a);r={"Content-Type":"application/x-www-form-urlencoded",Key:this.apiKey,Sign:i}}else"public"===t?(o+=this.getVersionString()+"/"+this.implodeParams(e,s),Object.keys(n).length&&(o+="?"+this.urlencode(n))):(o+="/"+this.implodeParams(e,s),"GET"===i?Object.keys(n).length&&(o+="?"+this.urlencode(n)):Object.keys(n).length&&(a=this.json(n),r={"Content-Type":"application/json"}));return{url:o,method:i,body:a,headers:r}}handleErrors(e,s,r,d,h,l){if("string"==typeof l&&!(l.length<2||"{"!==l[0]&&"["!==l[0])){let e=JSON.parse(l);if("success"in e){let s=this.safeValue(e,"success",!1);if("string"==typeof s&&(s="true"===s||"1"===s),!s){const s=this.safeString(e,"code"),r=this.safeString(e,"error"),d=this.id+" "+this.json(e),h=this.exceptions;if(s in h)throw new h[s](d);throw"invalid api key"===r?new n(d):"invalid sign"===r?new n(d):"api key dont have trade permission"===r?new n(d):r.indexOf("invalid parameter")>=0?new o(d):"invalid order"===r?new o(d):"Requests too often"===r?new a(d):"not available"===r?new i(d):"data unavailable"===r?new i(d):"external service unavailable"===r?new i(d):new t(this.id+' unknown "error" value: '+this.json(e))}}}}};
//# sourceMappingURL=liqui.js.map
"use strict";const e=require("./base/Exchange"),{ExchangeError:t}=require("./base/errors");module.exports=class extends e{describe(){return this.deepExtend(super.describe(),{id:"mercado",name:"Mercado Bitcoin",countries:"BR",rateLimit:1e3,version:"v3",has:{CORS:!0,createMarketOrder:!1,fetchOrder:!0,withdraw:!0},urls:{logo:"https://user-images.githubusercontent.com/1294454/27837060-e7c58714-60ea-11e7-9192-f05e86adb83f.jpg",api:{public:"https://www.mercadobitcoin.net/api",private:"https://www.mercadobitcoin.net/tapi"},www:"https://www.mercadobitcoin.com.br",doc:["https://www.mercadobitcoin.com.br/api-doc","https://www.mercadobitcoin.com.br/trade-api"]},api:{public:{get:["{coin}/orderbook/","{coin}/ticker/","{coin}/trades/","{coin}/trades/{from}/","{coin}/trades/{from}/{to}","{coin}/day-summary/{year}/{month}/{day}/"]},private:{post:["cancel_order","get_account_info","get_order","get_withdrawal","list_system_messages","list_orders","list_orderbook","place_buy_order","place_sell_order","withdraw_coin"]}},markets:{"BTC/BRL":{id:"BRLBTC",symbol:"BTC/BRL",base:"BTC",quote:"BRL",suffix:"Bitcoin"},"LTC/BRL":{id:"BRLLTC",symbol:"LTC/BRL",base:"LTC",quote:"BRL",suffix:"Litecoin"},"BCH/BRL":{id:"BRLBCH",symbol:"BCH/BRL",base:"BCH",quote:"BRL",suffix:"BCash"}},fees:{trading:{maker:.003,taker:.7/100}}})}async fetchOrderBook(e,t,i={}){let r=this.market(e),a=await this.publicGetCoinOrderbook(this.extend({coin:r.base},i));return this.parseOrderBook(a)}async fetchTicker(e,t={}){let i=this.market(e),r=(await this.publicGetCoinTicker(this.extend({coin:i.base},t))).ticker,a=1e3*parseInt(r.date),s=this.safeFloat(r,"last");return{symbol:e,timestamp:a,datetime:this.iso8601(a),high:this.safeFloat(r,"high"),low:this.safeFloat(r,"low"),bid:this.safeFloat(r,"buy"),bidVolume:void 0,ask:this.safeFloat(r,"sell"),askVolume:void 0,vwap:void 0,open:void 0,close:s,last:s,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeFloat(r,"vol"),quoteVolume:void 0,info:r}}parseTrade(e,t){let i=1e3*e.date;return{info:e,timestamp:i,datetime:this.iso8601(i),symbol:t.symbol,id:e.tid.toString(),order:void 0,type:void 0,side:e.type,price:e.price,amount:e.amount}}async fetchTrades(e,t,i,r={}){let a=this.market(e),s="publicGetCoinTrades",o={coin:a.base};void 0!==t&&(s+="From",o.from=parseInt(t/1e3)),void 0!==this.safeInteger(r,"to")&&(s+="To");let d=await this[s](this.extend(o,r));return this.parseTrades(d,a,t,i)}async fetchBalance(e={}){let t=await this.privatePostGetAccountInfo(),i=t.response_data.balance,r={info:t},a=Object.keys(this.currencies);for(let e=0;e<a.length;e++){let t=a[e],s=t.toLowerCase(),o=this.account();s in i&&(o.free=parseFloat(i[s].available),o.total=parseFloat(i[s].total),o.used=o.total-o.free),r[t]=o}return this.parseBalance(r)}async createOrder(e,i,r,a,s,o={}){if("market"===i)throw new t(this.id+" allows limit orders only");let d="privatePostPlace"+this.capitalize(r)+"Order",n={coin_pair:this.marketId(e),quantity:a,limit_price:s},c=await this[d](this.extend(n,o));return{info:c,id:c.response_data.order.order_id.toString()}}async cancelOrder(e,i,r={}){if(!i)throw new t(this.id+" cancelOrder() requires a symbol argument");await this.loadMarkets();let a=this.market(i);return await this.privatePostCancelOrder(this.extend({coin_pair:a.id,order_id:e},r))}parseOrder(e,t){let i=void 0;"order_type"in e&&(i=1===e.order_type?"buy":"sell");let r=e.status,a=void 0;t||"coin_pair"in e&&e.coin_pair in this.markets_by_id&&(t=this.markets_by_id[e.coin_pair]),t&&(a=t.symbol);let s=void 0;"created_timestamp"in e&&(s=1e3*parseInt(e.created_timestamp)),"updated_timestamp"in e&&(s=1e3*parseInt(e.updated_timestamp));let o={cost:this.safeFloat(e,"fee"),currency:t.quote},d=this.safeFloat(e,"limit_price"),n=this.safeFloat(e,"executed_price_avg"),c=this.safeFloat(e,"quantity"),h=this.safeFloat(e,"executed_quantity"),l=c-h,p=c*n;return{info:e,id:e.order_id.toString(),timestamp:s,datetime:this.iso8601(s),lastTradeTimestamp:void 0,symbol:a,type:"limit",side:i,price:d,cost:p,average:n,amount:c,filled:h,remaining:l,status:r,fee:o}}async fetchOrder(e,i,r={}){if(!i)throw new t(this.id+" cancelOrder() requires a symbol argument");await this.loadMarkets();let a=this.market(i),s=void 0;return s=await this.privatePostGetOrder(this.extend({coin_pair:a.id,order_id:parseInt(e)},r)),this.parseOrder(s.response_data.order)}async withdraw(e,i,r,a,s={}){this.checkAddress(r),await this.loadMarkets();let o={coin:e,quantity:i.toFixed(10),address:r};if("BRL"===e){if(!("account_ref"in s))throw new t(this.id+" requires account_ref parameter to withdraw "+e)}else if("LTC"!==e){if(!("tx_fee"in s))throw new t(this.id+" requires tx_fee parameter to withdraw "+e)}let d=await this.privatePostWithdrawCoin(this.extend(o,s));return{info:d,id:d.response_data.withdrawal.id}}sign(e,t="public",i="GET",r={},a,s){let o=this.urls.api[t]+"/",d=this.omit(r,this.extractParams(e));if("public"===t)o+=this.implodeParams(e,r),Object.keys(d).length&&(o+="?"+this.urlencode(d));else{this.checkRequiredCredentials(),o+=this.version+"/";let t=this.nonce();s=this.urlencode(this.extend({tapi_method:e,tapi_nonce:t},r));let i="/tapi/"+this.version+"/?"+s;a={"Content-Type":"application/x-www-form-urlencoded","TAPI-ID":this.apiKey,"TAPI-MAC":this.hmac(this.encode(i),this.encode(this.secret),"sha512")}}return{url:o,method:i,body:s,headers:a}}async request(e,i="public",r="GET",a={},s,o){let d=await this.fetch2(e,i,r,a,s,o);if("error_message"in d)throw new t(this.id+" "+this.json(d));return d}};
//# sourceMappingURL=mercado.js.map
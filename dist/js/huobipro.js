"use strict";const e=require("./base/Exchange"),{ExchangeError:t,ExchangeNotAvailable:i,InvalidOrder:r,OrderNotFound:s,InsufficientFunds:a}=require("./base/errors");module.exports=class extends e{describe(){return this.deepExtend(super.describe(),{id:"huobipro",name:"Huobi Pro",countries:"CN",rateLimit:2e3,userAgent:this.userAgents.chrome39,version:"v1",accounts:void 0,accountsById:void 0,hostname:"api.huobipro.com",has:{CORS:!1,fetchDepositAddress:!0,fetchOHCLV:!0,fetchOpenOrders:!0,fetchClosedOrders:!0,fetchOrder:!0,fetchOrders:!1,fetchTradingLimits:!0,withdraw:!0,fetchCurrencies:!0},timeframes:{"1m":"1min","5m":"5min","15m":"15min","30m":"30min","1h":"60min","1d":"1day","1w":"1week","1M":"1mon","1y":"1year"},urls:{logo:"https://user-images.githubusercontent.com/1294454/27766569-15aa7b9a-5edd-11e7-9e7f-44791f4ee49c.jpg",api:"https://api.huobipro.com",www:"https://www.huobipro.com",referral:"https://www.huobi.br.com/en-us/topic/invited/?invite_code=rwrd3",doc:"https://github.com/huobiapi/API_Docs/wiki/REST_api_reference",fees:"https://www.huobipro.com/about/fee/"},api:{market:{get:["history/kline","detail/merged","depth","trade","history/trade","detail"]},public:{get:["common/symbols","common/currencys","common/timestamp","common/exchange","settings/currencys"]},private:{get:["account/accounts","account/accounts/{id}/balance","order/orders/{id}","order/orders/{id}/matchresults","order/orders","order/matchresults","dw/withdraw-virtual/addresses","dw/deposit-virtual/addresses","query/deposit-withdraw","margin/loan-orders","margin/accounts/balance"],post:["order/orders/place","order/orders","order/orders/{id}/place","order/orders/{id}/submitcancel","order/orders/batchcancel","dw/balance/transfer","dw/withdraw/api/create","dw/withdraw-virtual/create","dw/withdraw-virtual/{id}/place","dw/withdraw-virtual/{id}/cancel","dw/transfer-in/margin","dw/transfer-out/margin","margin/orders","margin/orders/{id}/repay"]}},fees:{trading:{tierBased:!1,percentage:!0,maker:.002,taker:.002}},exceptions:{"account-frozen-balance-insufficient-error":a,"order-limitorder-amount-min-error":r,"order-orderstate-error":s,"order-queryorder-invalid":s,"order-update-error":i},options:{createMarketBuyOrderRequiresPrice:!0,fetchMarketsMethod:"publicGetCommonSymbols",fetchBalanceMethod:"privateGetAccountAccountsIdBalance",createOrderMethod:"privatePostOrderOrdersPlace",language:"en-US"}})}async fetchTradingLimits(e,t={}){await this.loadMarkets();let i={},r={};void 0===e&&(e=this.symbols);for(let t=0;t<e.length;t++){let s=e[t],a=this.market(s),o=await this.publicGetCommonExchange(this.extend({symbol:a.id})),n=this.parseTradingLimits(o);i[s]=o,r[s]=n}return{limits:r,info:i}}parseTradingLimits(e,t,i={}){let r=e.data;if(void 0!==r)return{amount:{min:r["limit-order-must-greater-than"],max:r["limit-order-must-less-than"]}}}async fetchMarkets(){let e=this.options.fetchMarketsMethod,i=(await this[e]()).data;if(i.length<1)throw new t(this.id+" publicGetCommonSymbols returned empty response: "+this.json(i));let r=[];for(let e=0;e<i.length;e++){let t=i[e],s=t["base-currency"],a=t["quote-currency"],o=s.toUpperCase(),n=a.toUpperCase(),d=s+a,c=(o=this.commonCurrencyCode(o))+"/"+(n=this.commonCurrencyCode(n)),h={amount:t["amount-precision"],price:t["price-precision"]},l=Math.pow(10,-h.amount),m="OMG"===o?0:.002,u="OMG"===o?0:.002;r.push({id:d,symbol:c,base:o,quote:n,lot:l,active:!0,precision:h,taker:u,maker:m,limits:{amount:{min:l,max:Math.pow(10,h.amount)},price:{min:Math.pow(10,-h.price),max:void 0},cost:{min:0,max:void 0}},info:t})}return r}parseTicker(e,t){let i=void 0;t&&(i=t.symbol);let r=this.milliseconds();"ts"in e&&(r=e.ts);let s=void 0,a=void 0,o=void 0,n=void 0;"bid"in e&&Array.isArray(e.bid)&&(s=this.safeFloat(e.bid,0),o=this.safeFloat(e.bid,1)),"ask"in e&&Array.isArray(e.ask)&&(a=this.safeFloat(e.ask,0),n=this.safeFloat(e.ask,1));let d=this.safeFloat(e,"open"),c=this.safeFloat(e,"close"),h=void 0,l=void 0,m=void 0;void 0!==d&&void 0!==c&&(h=c-d,m=this.sum(d,c)/2,void 0!==c&&c>0&&(l=h/d*100));let u=this.safeFloat(e,"amount"),p=this.safeFloat(e,"vol"),f=void 0;return void 0!==u&&void 0!==p&&u>0&&(f=p/u),{symbol:i,timestamp:r,datetime:this.iso8601(r),high:e.high,low:e.low,bid:s,bidVolume:o,ask:a,askVolume:n,vwap:f,open:d,close:c,last:c,previousClose:void 0,change:h,percentage:l,average:m,baseVolume:u,quoteVolume:p,info:e}}async fetchOrderBook(e,i,r={}){await this.loadMarkets();let s=this.market(e),a=await this.marketGetDepth(this.extend({symbol:s.id,type:"step0"},r));if("tick"in a){if(!a.tick)throw new t(this.id+" fetchOrderBook() returned empty response: "+this.json(a));let e=a.tick,i=e.ts;return e.nonce=e.version,this.parseOrderBook(e,i)}throw new t(this.id+" fetchOrderBook() returned unrecognized response: "+this.json(a))}async fetchTicker(e,t={}){await this.loadMarkets();let i=this.market(e),r=await this.marketGetDetailMerged(this.extend({symbol:i.id},t));return this.parseTicker(r.tick,i)}parseTrade(e,t){let i=e.ts;return{info:e,id:e.id.toString(),order:void 0,timestamp:i,datetime:this.iso8601(i),symbol:t.symbol,type:void 0,side:e.direction,price:e.price,amount:e.amount}}async fetchTrades(e,t,i=1e3,r={}){await this.loadMarkets();let s=this.market(e),a={symbol:s.id};void 0!==i&&(a.size=i);let o=(await this.marketGetHistoryTrade(this.extend(a,r))).data,n=[];for(let e=0;e<o.length;e++){let t=o[e].data;for(let e=0;e<t.length;e++){let i=this.parseTrade(t[e],s);n.push(i)}}return n=this.sortBy(n,"timestamp"),this.filterBySymbolSinceLimit(n,e,t,i)}parseOHLCV(e,t,i="1m",r,s){return[1e3*e.id,e.open,e.high,e.low,e.close,e.amount]}async fetchOHLCV(e,t="1m",i,r=1e3,s={}){await this.loadMarkets();let a=this.market(e),o={symbol:a.id,period:this.timeframes[t]};void 0!==r&&(o.size=r);let n=await this.marketGetHistoryKline(this.extend(o,s));return this.parseOHLCVs(n.data,a,t,i,r)}async loadAccounts(e=!1){if(e)this.accounts=await this.fetchAccounts();else{if(this.accounts)return this.accounts;this.accounts=await this.fetchAccounts(),this.accountsById=this.indexBy(this.accounts,"id")}return this.accounts}async fetchAccounts(){return await this.loadMarkets(),(await this.privateGetAccountAccounts()).data}async fetchCurrencies(e={}){let t=(await this.publicGetSettingsCurrencys(this.extend({language:this.options.language},e))).data,i={};for(let e=0;e<t.length;e++){let r=t[e],s=this.safeValue(r,"name"),a=this.safeInteger(r,"withdraw-precision"),o=this.commonCurrencyCode(s.toUpperCase()),n=r.visible&&r["deposit-enabled"]&&r["withdraw-enabled"];i[o]={id:s,code:o,type:"crypto",name:r["display-name"],active:n,status:n?"ok":"disabled",fee:void 0,precision:a,limits:{amount:{min:Math.pow(10,-a),max:Math.pow(10,a)},price:{min:Math.pow(10,-a),max:Math.pow(10,a)},cost:{min:void 0,max:void 0},deposit:{min:this.safeFloat(r,"deposit-min-amount"),max:Math.pow(10,a)},withdraw:{min:this.safeFloat(r,"withdraw-min-amount"),max:Math.pow(10,a)}},info:r}}return i}async fetchBalance(e={}){await this.loadMarkets(),await this.loadAccounts();let t=this.options.fetchBalanceMethod,i=await this[t](this.extend({id:this.accounts[0].id},e)),r=i.data.list,s={info:i};for(let e=0;e<r.length;e++){let t=r[e],i=t.currency.toUpperCase(),a=this.commonCurrencyCode(i),o=void 0;o=a in s?s[a]:this.account(),"trade"===t.type&&(o.free=parseFloat(t.balance)),"frozen"===t.type&&(o.used=parseFloat(t.balance)),o.total=this.sum(o.free,o.used),s[a]=o}return this.parseBalance(s)}async fetchOrdersByStates(e,i,r,s,a={}){if(!i)throw new t(this.id+" fetchOrders() requires a symbol parameter");await this.loadMarkets();let o=this.market(i),n=await this.privateGetOrderOrders(this.extend({symbol:o.id,states:e},a));return this.parseOrders(n.data,o,r,s)}async fetchOrders(e,t,i,r={}){return await this.fetchOrdersByStates("pre-submitted,submitted,partial-filled,filled,partial-canceled,canceled",e,t,i,r)}async fetchOpenOrders(e,t,i,r={}){return await this.fetchOrdersByStates("pre-submitted,submitted,partial-filled",e,t,i,r)}async fetchClosedOrders(e,t,i,r={}){return await this.fetchOrdersByStates("filled,partial-canceled,canceled",e,t,i,r)}async fetchOrder(e,t,i={}){await this.loadMarkets();let r=await this.privateGetOrderOrdersId(this.extend({id:e},i));return this.parseOrder(r.data)}parseOrderStatus(e){return"partial-filled"===e?"open":"partial-canceled"===e?"canceled":"filled"===e?"closed":"canceled"===e?"canceled":"submitted"===e?"open":e}parseOrder(e,t){let i=void 0,r=void 0,s=void 0;if("type"in e){let t=e.type.split("-");i=t[0],r=t[1],s=this.parseOrderStatus(e.state)}let a=void 0;if(!t&&"symbol"in e&&e.symbol in this.markets_by_id){let i=e.symbol;t=this.markets_by_id[i]}t&&(a=t.symbol);let o=e["created-at"],n=this.safeFloat(e,"amount"),d=parseFloat(e["field-amount"]),c=n-d,h=this.safeFloat(e,"price"),l=parseFloat(e["field-cash-amount"]),m=0;return d&&(m=parseFloat(l/d)),{info:e,id:e.id.toString(),timestamp:o,datetime:this.iso8601(o),lastTradeTimestamp:void 0,symbol:a,type:r,side:i,price:h,average:m,cost:l,amount:n,filled:d,remaining:c,status:s,fee:void 0}}async createOrder(e,t,i,s,a,o={}){await this.loadMarkets(),await this.loadAccounts();let n=this.market(e),d={"account-id":this.accounts[0].id,amount:this.amountToPrecision(e,s),symbol:n.id,type:i+"-"+t};if(this.options.createMarketBuyOrderRequiresPrice&&"market"===t&&"buy"===i){if(void 0===a)throw new r(this.id+" market buy order requires price argument to calculate cost (total amount of quote currency to spend for buying, amount * price). To switch off this warning exception and specify cost in the amount argument, set .options['createMarketBuyOrderRequiresPrice'] = false. Make sure you know what you're doing.");d.amount=this.priceToPrecision(e,parseFloat(s)*parseFloat(a))}"limit"===t&&(d.price=this.priceToPrecision(e,a));let c=this.options.createOrderMethod,h=await this[c](this.extend(d,o)),l=this.milliseconds();return{info:h,id:h.data,timestamp:l,datetime:this.iso8601(l),lastTradeTimestamp:void 0,status:void 0,symbol:e,type:t,side:i,price:a,amount:s,filled:void 0,remaining:void 0,cost:void 0,trades:void 0,fee:void 0}}async cancelOrder(e,t,i={}){return await this.privatePostOrderOrdersIdSubmitcancel({id:e})}async fetchDepositAddress(e,t={}){await this.loadMarkets();let i=this.currency(e),r=await this.privateGetDwDepositVirtualAddresses(this.extend({currency:i.id.toLowerCase()},t)),s=this.safeString(r,"data");return this.checkAddress(s),{currency:e,status:"ok",address:s,info:r}}feeToPrecision(e,t){return parseFloat(this.decimalToPrecision(t,0,this.currencies[e].precision))}calculateFee(e,t,i,r,s,a="taker",o={}){let n=this.markets[e],d=n[a],c=r*d,h="quote";return"sell"===i?c*=s:h="base",{type:a,currency:n[h],rate:d,cost:parseFloat(this.feeToPrecision(n[h],c))}}async withdraw(e,t,i,r,s={}){await this.loadMarkets(),this.checkAddress(i);let a={address:i,amount:t,currency:this.currency(e).id.toLowerCase()};void 0!==r&&(a["addr-tag"]=r);let o=await this.privatePostDwWithdrawApiCreate(this.extend(a,s)),n=void 0;return"data"in o&&(n=o.data),{info:o,id:n}}sign(e,t="public",i="GET",r={},s,a){let o="/";o+="market"===t?t:this.version,o+="/"+this.implodeParams(e,r);let n=this.omit(r,this.extractParams(e));if("private"===t){this.checkRequiredCredentials();let e=this.ymdhms(this.milliseconds(),"T"),t=this.keysort(this.extend({SignatureMethod:"HmacSHA256",SignatureVersion:"2",AccessKeyId:this.apiKey,Timestamp:e},n)),r=this.urlencode(t),d=[i,this.hostname,o,r].join("\n"),c=this.hmac(this.encode(d),this.encode(this.secret),"sha256","base64");o+="?"+(r+="&"+this.urlencode({Signature:c})),"POST"===i?(a=this.json(n),s={"Content-Type":"application/json"}):s={"Content-Type":"application/x-www-form-urlencoded"}}else Object.keys(r).length&&(o+="?"+this.urlencode(r));return{url:o=this.urls.api+o,method:i,body:a,headers:s}}handleErrors(e,i,r,s,a,o){if("string"==typeof o&&!(o.length<2||"{"!==o[0]&&"["!==o[0])){let e=JSON.parse(o);if("status"in e){if("error"===this.safeString(e,"status")){const i=this.safeString(e,"err-code"),r=this.id+" "+this.json(e),s=this.exceptions;if(i in s)throw new s[i](r);throw new t(r)}}}}};
//# sourceMappingURL=huobipro.js.map
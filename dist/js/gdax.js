"use strict";const e=require("./base/Exchange"),{InsufficientFunds:t,ExchangeError:i,InvalidOrder:s,AuthenticationError:a,NotSupported:r,OrderNotFound:d}=require("./base/errors");module.exports=class extends e{describe(){return this.deepExtend(super.describe(),{id:"gdax",name:"GDAX",countries:"US",rateLimit:1e3,userAgent:this.userAgents.chrome,has:{CORS:!0,fetchOHLCV:!0,deposit:!0,withdraw:!0,fetchOrder:!0,fetchOrders:!0,fetchOpenOrders:!0,fetchClosedOrders:!0,fetchMyTrades:!0},timeframes:{"1m":60,"5m":300,"15m":900,"1h":3600,"6h":21600,"1d":86400},urls:{test:"https://api-public.sandbox.gdax.com",logo:"https://user-images.githubusercontent.com/1294454/27766527-b1be41c6-5edb-11e7-95f6-5b496c469e2c.jpg",api:"https://api.gdax.com",www:"https://www.gdax.com",doc:"https://docs.gdax.com",fees:["https://www.gdax.com/fees","https://support.gdax.com/customer/en/portal/topics/939402-depositing-and-withdrawing-funds/articles"]},requiredCredentials:{apiKey:!0,secret:!0,password:!0},api:{public:{get:["currencies","products","products/{id}/book","products/{id}/candles","products/{id}/stats","products/{id}/ticker","products/{id}/trades","time"]},private:{get:["accounts","accounts/{id}","accounts/{id}/holds","accounts/{id}/ledger","accounts/{id}/transfers","coinbase-accounts","fills","funding","orders","orders/{id}","payment-methods","position","reports/{id}","users/self/trailing-volume"],post:["deposits/coinbase-account","deposits/payment-method","coinbase-accounts/{id}/addresses","funding/repay","orders","position/close","profiles/margin-transfer","reports","withdrawals/coinbase","withdrawals/crypto","withdrawals/payment-method"],delete:["orders","orders/{id}"]}},fees:{trading:{tierBased:!0,percentage:!0,maker:0,taker:.003},funding:{tierBased:!1,percentage:!1,withdraw:{BCH:0,BTC:0,LTC:0,ETH:0,EUR:.15,USD:25},deposit:{BCH:0,BTC:0,LTC:0,ETH:0,EUR:.15,USD:10}}}})}async fetchMarkets(){let e=await this.publicGetProducts(),t=[];for(let i=0;i<e.length;i++){let s=e[i],a=s.id,r=s.base_currency,d=s.quote_currency,o=r+"/"+d,n={min:this.safeFloat(s,"quote_increment"),max:void 0},h={amount:8,price:this.precisionFromString(this.safeString(s,"quote_increment"))},c=this.fees.trading.taker;"ETH"!==r&&"LTC"!==r||(c=.003);let l="online"===s.status;t.push(this.extend(this.fees.trading,{id:a,symbol:o,base:r,quote:d,precision:h,limits:{amount:{min:this.safeFloat(s,"base_min_size"),max:this.safeFloat(s,"base_max_size")},price:n,cost:{min:this.safeFloat(s,"min_market_funds"),max:this.safeFloat(s,"max_market_funds")}},taker:c,active:l,info:s}))}return t}async fetchBalance(e={}){await this.loadMarkets();let t=await this.privateGetAccounts(),i={info:t};for(let e=0;e<t.length;e++){let s=t[e],a=s.currency,r={free:this.safeFloat(s,"available"),used:this.safeFloat(s,"hold"),total:this.safeFloat(s,"balance")};i[a]=r}return this.parseBalance(i)}async fetchOrderBook(e,t,i={}){await this.loadMarkets();let s=await this.publicGetProductsIdBook(this.extend({id:this.marketId(e),level:2},i));return this.parseOrderBook(s)}async fetchTicker(e,t={}){await this.loadMarkets();let i=this.market(e),s=this.extend({id:i.id},t),a=await this.publicGetProductsIdTicker(s),r=this.parse8601(a.time),d=void 0,o=void 0;"bid"in a&&(d=this.safeFloat(a,"bid")),"ask"in a&&(o=this.safeFloat(a,"ask"));let n=this.safeFloat(a,"price");return{symbol:e,timestamp:r,datetime:this.iso8601(r),high:void 0,low:void 0,bid:d,bidVolume:void 0,ask:o,askVolume:void 0,vwap:void 0,open:void 0,close:n,last:n,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeFloat(a,"volume"),quoteVolume:void 0,info:a}}parseTrade(e,t){let i=void 0;"time"in e?i=this.parse8601(e.time):"created_at"in e&&(i=this.parse8601(e.created_at));let s=void 0;void 0!==i&&(s=this.iso8601(i));let a=void 0;if(!t&&"product_id"in e){let i=e.product_id;i in this.markets_by_id&&(t=this.markets_by_id[i])}t&&(a=t.symbol);let r=void 0,d=void 0;if(t&&(d=t.quote,"liquidity"in e)){r=t["T"===e.liquidity?"taker":"maker"]}let o=this.safeFloat(e,"fill_fees");void 0===o&&(o=this.safeFloat(e,"fee"));let n={cost:o,currency:d,rate:r},h=this.safeString(e,"trade_id"),c="buy"===e.side?"sell":"buy",l=this.safeString(e,"order_id");return void 0!==l&&(c="buy"===e.side?"buy":"sell"),{id:h,order:l,info:e,timestamp:i,datetime:s,symbol:a,type:void 0,side:c,price:this.safeFloat(e,"price"),amount:this.safeFloat(e,"size"),fee:n}}async fetchMyTrades(e,t,i,s={}){await this.loadMarkets();let a=void 0,r={};void 0!==e&&(a=this.market(e),r.product_id=a.id),void 0!==i&&(r.limit=i);let d=await this.privateGetFills(this.extend(r,s));return this.parseTrades(d,a,t,i)}async fetchTrades(e,t,i,s={}){await this.loadMarkets();let a=this.market(e),r=await this.publicGetProductsIdTrades(this.extend({id:a.id},s));return this.parseTrades(r,a,t,i)}parseOHLCV(e,t,i="1m",s,a){return[1e3*e[0],e[3],e[2],e[1],e[4],e[5]]}async fetchOHLCV(e,t="1m",i,s,a={}){await this.loadMarkets();let r=this.market(e),d=this.timeframes[t],o={id:r.id,granularity:d};void 0!==i&&(o.start=this.ymdhms(i),void 0===s&&(s=300),o.end=this.ymdhms(this.sum(s*d*1e3,i)));let n=await this.publicGetProductsIdCandles(this.extend(o,a));return this.parseOHLCVs(n,r,t,i,s)}async fetchTime(){let e=await this.publicGetTime();return this.parse8601(e.iso)}parseOrderStatus(e){return this.safeString({pending:"open",active:"open",open:"open",done:"closed",canceled:"canceled"},e,e)}parseOrder(e,t){let i=this.parse8601(e.created_at),s=void 0;t||e.product_id in this.markets_by_id&&(t=this.markets_by_id[e.product_id]);let a=this.parseOrderStatus(e.status),r=this.safeFloat(e,"price"),d=this.safeFloat(e,"size");void 0===d&&(d=this.safeFloat(e,"funds")),void 0===d&&(d=this.safeFloat(e,"specified_funds"));let o=this.safeFloat(e,"filled_size"),n=void 0;void 0!==d&&void 0!==o&&(n=d-o);let h=this.safeFloat(e,"executed_value"),c={cost:this.safeFloat(e,"fill_fees"),currency:void 0,rate:void 0};return t&&(s=t.symbol),{id:e.id,info:e,timestamp:i,datetime:this.iso8601(i),lastTradeTimestamp:void 0,status:a,symbol:s,type:e.type,side:e.side,price:r,cost:h,amount:d,filled:o,remaining:n,fee:c}}async fetchOrder(e,t,i={}){await this.loadMarkets();let s=await this.privateGetOrdersId(this.extend({id:e},i));return this.parseOrder(s)}async fetchOrders(e,t,i,s={}){await this.loadMarkets();let a={status:"all"},r=void 0;e&&(r=this.market(e),a.product_id=r.id);let d=await this.privateGetOrders(this.extend(a,s));return this.parseOrders(d,r,t,i)}async fetchOpenOrders(e,t,i,s={}){await this.loadMarkets();let a={},r=void 0;e&&(r=this.market(e),a.product_id=r.id);let d=await this.privateGetOrders(this.extend(a,s));return this.parseOrders(d,r,t,i)}async fetchClosedOrders(e,t,i,s={}){await this.loadMarkets();let a={status:"done"},r=void 0;e&&(r=this.market(e),a.product_id=r.id);let d=await this.privateGetOrders(this.extend(a,s));return this.parseOrders(d,r,t,i)}async createOrder(e,t,i,s,a,r={}){await this.loadMarkets();let d={product_id:this.marketId(e),side:i,size:s,type:t};"limit"===t&&(d.price=a);let o=await this.privatePostOrders(this.extend(d,r));return this.parseOrder(o)}async cancelOrder(e,t,i={}){return await this.loadMarkets(),await this.privateDeleteOrdersId({id:e})}feeToPrecision(e,t){return parseFloat(t).toFixed(this.currencies[e].precision)}calculateFee(e,t,i,s,a,r="taker",d={}){let o=this.markets[e],n=o[r],h=s*a,c=o.quote;return{type:r,currency:c,rate:n,cost:parseFloat(this.feeToPrecision(c,n*h))}}async getPaymentMethods(){return await this.privateGetPaymentMethods()}async deposit(e,t,s,a={}){await this.loadMarkets();let d={currency:e,amount:t},o="privatePostDeposits";if("payment_method_id"in a)o+="PaymentMethod";else{if(!("coinbase_account_id"in a))throw new r(this.id+" deposit() requires one of `coinbase_account_id` or `payment_method_id` extra params");o+="CoinbaseAccount"}let n=await this[o](this.extend(d,a));if(!n)throw new i(this.id+" deposit() error: "+this.json(n));return{info:n,id:n.id}}async withdraw(e,t,s,a,r={}){this.checkAddress(s),await this.loadMarkets();let d={currency:e,amount:t},o="privatePostWithdrawals";"payment_method_id"in r?o+="PaymentMethod":"coinbase_account_id"in r?o+="CoinbaseAccount":(o+="Crypto",d.crypto_address=s);let n=await this[o](this.extend(d,r));if(!n)throw new i(this.id+" withdraw() error: "+this.json(n));return{info:n,id:n.id}}sign(e,t="public",i="GET",s={},a,r){let d="/"+this.implodeParams(e,s),o=this.omit(s,this.extractParams(e));"GET"===i&&Object.keys(o).length&&(d+="?"+this.urlencode(o));let n=this.urls.api+d;if("private"===t){this.checkRequiredCredentials();let e=this.nonce().toString(),t="";"GET"!==i&&Object.keys(o).length&&(t=r=this.json(o));let s=e+i+d+t,n=this.base64ToBinary(this.secret),h=this.hmac(this.encode(s),n,"sha256","base64");a={"CB-ACCESS-KEY":this.apiKey,"CB-ACCESS-SIGN":this.decode(h),"CB-ACCESS-TIMESTAMP":e,"CB-ACCESS-PASSPHRASE":this.password,"Content-Type":"application/json"}}return{url:n,method:i,body:r,headers:a}}handleErrors(e,r,o,n,h,c){if(400===e||404===e){if("{"===c[0]){let e=JSON.parse(c).message,r=this.id+" "+e;if(e.indexOf("price too small")>=0)throw new s(r);if(e.indexOf("price too precise")>=0)throw new s(r);if("Insufficient funds"===e)throw new t(r);if("NotFound"===e)throw new d(r);if("Invalid API Key"===e)throw new a(r);throw new i(this.id+" "+e)}throw new i(this.id+" "+c)}}async request(e,t="public",s="GET",a={},r,d){let o=await this.fetch2(e,t,s,a,r,d);if("message"in o)throw new i(this.id+" "+this.json(o));return o}};
//# sourceMappingURL=gdax.js.map
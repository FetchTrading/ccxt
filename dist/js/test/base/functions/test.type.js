"use strict";const{safeFloat:x,safeInteger:o,safeValue:e}=require("../../../../ccxt"),{strictEqual:a,deepEqual:s}=require("assert");it("safeFloat/safeInteger is robust",async()=>{const e={},s={safeFloat:x,safeInteger:o};for(const x of["safeFloat","safeInteger"])a(s[x]({x:!1},"x",e),e),a(s[x]({x:!0},"x",e),e),a(s[x]({x:[]},"x",e),e),a(s[x]({x:[0]},"x",e),e),a(s[x]({x:[1]},"x",e),e),a(s[x]({x:{}},"x",e),e),a(s[x]({x:Number.NaN},"x"),void 0),a(s[x]({x:Number.POSITIVE_INFINITY},"x"),void 0),a(s[x]({x:null},"x",void 0),void 0),a(s[x]({x:null},"x",e),e),a(s[x]({x:"1.0"},"x"),1),a(s[x]({x:"-1.0"},"x"),-1),a(s[x]({x:1},"x"),1),a(s[x]({x:0},"x"),0),a(s[x]({x:void 0},"x",e),e),a(s[x]({x:""},"x"),void 0),a(s[x]({x:""},"x",0),0),a(s[x]({},"x"),void 0),a(s[x]({},"x",0),0);a(x({x:1.59999999},"x"),1.59999999),a(o({x:1.59999999},"x"),1)}),it("safeValue works",()=>{a(e({},"foo"),void 0),a(e({},"foo","bar"),"bar"),a(e({foo:"bar"},"foo"),"bar"),a(e({foo:""},"foo"),""),a(e({foo:0},"foo"),0)});
//# sourceMappingURL=test.type.js.map
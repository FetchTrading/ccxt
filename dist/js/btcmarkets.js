"use strict";const e=require("./base/Exchange"),{ExchangeError:t,OrderNotFound:r,NotSupported:i,InvalidOrder:s,DDoSProtection:a}=require("./base/errors");module.exports=class extends e{describe(){return this.deepExtend(super.describe(),{id:"btcmarkets",name:"BTC Markets",countries:"AU",rateLimit:1e3,has:{CORS:!1,fetchOHLCV:!0,fetchOrder:!0,fetchOrders:!0,fetchClosedOrders:"emulated",fetchOpenOrders:!0,fetchMyTrades:!0,cancelOrders:!0},urls:{logo:"https://user-images.githubusercontent.com/1294454/29142911-0e1acfc2-7d5c-11e7-98c4-07d9532b29d7.jpg",api:{public:"https://api.btcmarkets.net",private:"https://api.btcmarkets.net",web:"https://btcmarkets.net/data"},www:"https://btcmarkets.net/",doc:"https://github.com/BTCMarkets/API"},api:{public:{get:["market/{id}/tick","market/{id}/orderbook","market/{id}/trades"]},private:{get:["account/balance","account/{id}/tradingfee"],post:["fundtransfer/withdrawCrypto","fundtransfer/withdrawEFT","order/create","order/cancel","order/history","order/open","order/trade/history","order/createBatch","order/detail"]},web:{get:["market/BTCMarkets/{id}/tickByTime"]}},markets:{"BTC/AUD":{id:"BTC/AUD",symbol:"BTC/AUD",base:"BTC",quote:"AUD",maker:.0085,taker:.0085,limits:{amount:{min:.001,max:void 0}},precision:{price:2}},"LTC/AUD":{id:"LTC/AUD",symbol:"LTC/AUD",base:"LTC",quote:"AUD",maker:.0085,taker:.0085,limits:{amount:{min:.001,max:void 0}},precision:{price:2}},"ETH/AUD":{id:"ETH/AUD",symbol:"ETH/AUD",base:"ETH",quote:"AUD",maker:.0085,taker:.0085,limits:{amount:{min:.001,max:void 0}},precision:{price:2}},"ETC/AUD":{id:"ETC/AUD",symbol:"ETC/AUD",base:"ETC",quote:"AUD",maker:.0085,taker:.0085,limits:{amount:{min:.001,max:void 0}},precision:{price:2}},"XRP/AUD":{id:"XRP/AUD",symbol:"XRP/AUD",base:"XRP",quote:"AUD",maker:.0085,taker:.0085,limits:{amount:{min:.001,max:void 0}},precision:{price:2}},"BCH/AUD":{id:"BCH/AUD",symbol:"BCH/AUD",base:"BCH",quote:"AUD",maker:.0085,taker:.0085,limits:{amount:{min:.001,max:void 0}},precision:{price:2}},"LTC/BTC":{id:"LTC/BTC",symbol:"LTC/BTC",base:"LTC",quote:"BTC",maker:.0022,taker:.0022,limits:{amount:{min:.001,max:void 0}}},"ETH/BTC":{id:"ETH/BTC",symbol:"ETH/BTC",base:"ETH",quote:"BTC",maker:.0022,taker:.0022,limits:{amount:{min:.001,max:void 0}}},"ETC/BTC":{id:"ETC/BTC",symbol:"ETC/BTC",base:"ETC",quote:"BTC",maker:.0022,taker:.0022,limits:{amount:{min:.001,max:void 0}}},"XRP/BTC":{id:"XRP/BTC",symbol:"XRP/BTC",base:"XRP",quote:"BTC",maker:.0022,taker:.0022,limits:{amount:{min:.001,max:void 0}}},"BCH/BTC":{id:"BCH/BTC",symbol:"BCH/BTC",base:"BCH",quote:"BTC",maker:.0022,taker:.0022,limits:{amount:{min:.001,max:void 0}}}},timeframes:{"1m":"minute","1h":"hour","1d":"day"},exceptions:{3:s,6:a}})}async fetchBalance(e={}){await this.loadMarkets();let t=await this.privateGetAccountBalance(),r={info:t};for(let e=0;e<t.length;e++){let i=t[e],s=i.currency,a=1e8,o=parseFloat(i.balance/a),d=parseFloat(i.pendingFunds/a),n={free:o-d,used:d,total:o};r[s]=n}return this.parseBalance(r)}parseOHLCV(e,t,r="1m",i,s){return[e[0],parseFloat(e[1])/1e8,parseFloat(e[2])/1e8,parseFloat(e[3])/1e8,parseFloat(e[4])/1e8,parseFloat(e[5])/1e8]}async fetchOHLCV(e,t="1m",r,i,s={}){await this.load_markets();let a=this.market(e),o={id:a.id,timeWindow:this.timeframes[t]};void 0!==r&&(o.since=r);let d=await this.webGetMarketBTCMarketsIdTickByTime(this.extend(o,s));return this.parseOHLCVs(d.ticks,a,t,r,i)}async fetchOrderBook(e,t,r={}){await this.loadMarkets();let i=this.market(e),s=await this.publicGetMarketIdOrderbook(this.extend({id:i.id},r)),a=1e3*s.timestamp;return this.parseOrderBook(s,a)}parseTicker(e,t){let r=1e3*e.timestamp,i=void 0;t&&(i=t.symbol);let s=this.safeFloat(e,"lastPrice");return{symbol:i,timestamp:r,datetime:this.iso8601(r),high:void 0,low:void 0,bid:this.safeFloat(e,"bestBid"),bidVolume:void 0,ask:this.safeFloat(e,"bestAsk"),askVolume:void 0,vwap:void 0,open:void 0,close:s,last:s,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeFloat(e,"volume24h"),quoteVolume:void 0,info:e}}async fetchTicker(e,t={}){await this.loadMarkets();let r=this.market(e),i=await this.publicGetMarketIdTick(this.extend({id:r.id},t));return this.parseTicker(i,r)}parseTrade(e,t){let r=1e3*e.date;return{info:e,id:e.tid.toString(),order:void 0,timestamp:r,datetime:this.iso8601(r),symbol:t.symbol,type:void 0,side:void 0,price:e.price,amount:e.amount}}async fetchTrades(e,t,r,i={}){await this.loadMarkets();let s=this.market(e),a=await this.publicGetMarketIdTrades(this.extend({id:s.id},i));return this.parseTrades(a,s,t,r)}async createOrder(e,t,r,i,s,a={}){await this.loadMarkets();let o=this.market(e),d="buy"===r?"Bid":"Ask",n=this.ordered({currency:o.quote});n.currency=o.quote,n.instrument=o.base,n.price=parseInt(1e8*s),n.volume=parseInt(1e8*i),n.orderSide=d,n.ordertype=this.capitalize(t),n.clientRequestId=this.nonce().toString();let l=await this.privatePostOrderCreate(n);return{info:l,id:l.id.toString()}}async cancelOrders(e){await this.loadMarkets();for(let t=0;t<e.length;t++)e[t]=parseInt(e[t]);return await this.privatePostOrderCancel({orderIds:e})}async cancelOrder(e,t,r={}){return await this.loadMarkets(),await this.cancelOrders([e])}parseMyTrade(e,t){let r=e.creationTime,i="Bid"===e.side?"buy":"sell",s="AUD"===t.quote?t.quote:t.base;return{info:e,id:e.id.toString(),timestamp:r,datetime:this.iso8601(r),symbol:t.symbol,type:void 0,side:i,price:e.price/1e8,fee:{currency:s,cost:e.fee/1e8},amount:e.volume/1e8,order:this.safeString(e,"orderId")}}parseMyTrades(e,t,r,i){let s=[];for(let r=0;r<e.length;r++){let i=this.parseMyTrade(e[r],t);s.push(i)}return s}parseOrder(e,t){let r="Bid"===e.orderSide?"buy":"sell",i="Limit"===e.ordertype?"limit":"market",s=e.creationTime;t||(t=this.market(e.instrument+"/"+e.currency));let a="open";"Failed"===e.status||"Cancelled"===e.status||"Partially Cancelled"===e.status||"Error"===e.status?a="canceled":"Fully Matched"!==e.status&&"Partially Matched"!==e.status||(a="closed");let o=this.safeFloat(e,"price")/1e8,d=this.safeFloat(e,"volume")/1e8,n=this.safeFloat(e,"openVolume",0)/1e8,l=d-n,c=o*d,m=this.parseMyTrades(e.trades,t);return{info:e,id:e.id.toString(),timestamp:s,datetime:this.iso8601(s),lastTradeTimestamp:void 0,symbol:t.symbol,type:i,side:r,price:o,cost:c,amount:d,filled:l,remaining:n,status:a,trades:m,fee:void 0}}async fetchOrder(e,t,i={}){await this.loadMarkets();let s=[parseInt(e)],a=await this.privatePostOrderDetail(this.extend({orderIds:s},i));if(a.orders.length<1)throw new r(this.id+" No matching order found: "+e);let o=a.orders[0];return this.parseOrder(o)}prepareHistoryRequest(e,t,r){let i=this.ordered({currency:e.quote,instrument:e.base});return i.limit=void 0!==r?r:100,i.since=void 0!==t?t:0,i}async fetchOrders(e,t,r,s={}){if(!e)throw new i(this.id+": fetchOrders requires a `symbol` parameter.");await this.loadMarkets();let a=this.market(e),o=this.prepareHistoryRequest(a,t,r),d=await this.privatePostOrderHistory(this.extend(o,s));return this.parseOrders(d.orders,a)}async fetchOpenOrders(e,t,r,s={}){if(!e)throw new i(this.id+": fetchOpenOrders requires a `symbol` parameter.");await this.loadMarkets();let a=this.market(e),o=this.prepareHistoryRequest(a,t,r),d=await this.privatePostOrderOpen(this.extend(o,s));return this.parseOrders(d.orders,a)}async fetchClosedOrders(e,t,r,i={}){let s=await this.fetchOrders(e,t,r,i);return this.filterBy(s,"status","closed")}async fetchMyTrades(e,t,r,s={}){if(!e)throw new i(this.id+": fetchMyTrades requires a `symbol` parameter.");await this.loadMarkets();let a=this.market(e),o=this.prepareHistoryRequest(a,t,r),d=await this.privatePostOrderTradeHistory(this.extend(o,s));return this.parseMyTrades(d.trades,a)}nonce(){return this.milliseconds()}sign(e,t="public",r="GET",i={},s,a){let o="/"+this.implodeParams(e,i),d=this.urls.api[t]+o;if("private"===t){this.checkRequiredCredentials();let e=this.nonce().toString(),t=o+"\n"+e+"\n";s={"Content-Type":"application/json",apikey:this.apiKey,timestamp:e},"POST"===r&&(t+=a=this.json(i));let d=this.base64ToBinary(this.secret),n=this.hmac(this.encode(t),d,"sha512","base64");s.signature=this.decode(n)}else Object.keys(i).length&&(d+="?"+this.urlencode(i));return{url:d,method:r,body:a,headers:s}}handleErrors(e,r,i,s,a,o){if(!(o.length<2)&&"{"===o[0]){let e=JSON.parse(o);if("success"in e&&!e.success){let r=this.safeString(e,"errorCode"),i=this.id+" "+this.json(e);if(r in this.exceptions){throw new(0,this.exceptions[r])(i)}throw new t(i)}}}async request(e,t="public",r="GET",i={},s,a){return await this.fetch2(e,t,r,i,s,a)}};
//# sourceMappingURL=btcmarkets.js.map
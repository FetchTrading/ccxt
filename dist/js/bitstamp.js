"use strict";const t=require("./base/Exchange"),{AuthenticationError:e,ExchangeError:i,NotSupported:s}=require("./base/errors");module.exports=class extends t{describe(){return this.deepExtend(super.describe(),{id:"bitstamp",name:"Bitstamp",countries:"GB",rateLimit:1e3,version:"v2",has:{CORS:!0,fetchDepositAddress:!0,fetchOrder:!0,fetchOpenOrders:!0,fetchMyTrades:!0,withdraw:!0},urls:{logo:"https://user-images.githubusercontent.com/1294454/27786377-8c8ab57e-5fe9-11e7-8ea4-2b05b6bcceec.jpg",api:"https://www.bitstamp.net/api",www:"https://www.bitstamp.net",doc:"https://www.bitstamp.net/api"},requiredCredentials:{apiKey:!0,secret:!0,uid:!0},api:{public:{get:["order_book/{pair}/","ticker_hour/{pair}/","ticker/{pair}/","transactions/{pair}/","trading-pairs-info/"]},private:{post:["balance/","balance/{pair}/","bch_withdrawal/","bch_address/","user_transactions/","user_transactions/{pair}/","open_orders/all/","open_orders/{pair}/","order_status/","cancel_order/","buy/{pair}/","buy/market/{pair}/","sell/{pair}/","sell/market/{pair}/","ltc_withdrawal/","ltc_address/","eth_withdrawal/","eth_address/","xrp_withdrawal/","xrp_address/","transfer-to-main/","transfer-from-main/","withdrawal-requests/","withdrawal/open/","withdrawal/status/","withdrawal/cancel/","liquidation_address/new/","liquidation_address/info/"]},v1:{post:["bitcoin_deposit_address/","unconfirmed_btc/","bitcoin_withdrawal/","ripple_withdrawal/","ripple_address/"]}},fees:{trading:{tierBased:!0,percentage:!0,taker:.0025,maker:.0025,tiers:{taker:[[0,.0025],[2e4,.0024],[1e5,.0022],[4e5,.002],[6e5,.0015],[1e6,.14/100],[2e6,.0013],[4e6,.0012],[2e7,.0011],[20000001,.001]],maker:[[0,.0025],[2e4,.0024],[1e5,.0022],[4e5,.002],[6e5,.0015],[1e6,.14/100],[2e6,.0013],[4e6,.0012],[2e7,.0011],[20000001,.001]]}},funding:{tierBased:!1,percentage:!1,withdraw:{BTC:0,BCH:0,LTC:0,ETH:0,XRP:0,USD:25,EUR:.9},deposit:{BTC:0,BCH:0,LTC:0,ETH:0,XRP:0,USD:25,EUR:0}}}})}async fetchMarkets(){let t=await this.publicGetTradingPairsInfo(),e=[];for(let i=0;i<t.length;i++){let s=t[i],a=s.name,[r,o]=a.split("/"),d=r.toLowerCase(),n=o.toLowerCase(),h=d+"_"+n,l=s.url_symbol,c={amount:s.base_decimals,price:s.counter_decimals},p=s.minimum_order.split(" ")[0],u="Enabled"===s.trading,m=Math.pow(10,-c.amount);e.push({id:l,symbol:a,base:r,quote:o,baseId:d,quoteId:n,symbolId:h,info:s,lot:m,active:u,precision:c,limits:{amount:{min:m,max:void 0},price:{min:Math.pow(10,-c.price),max:void 0},cost:{min:parseFloat(p),max:void 0}}})}return e}async fetchOrderBook(t,e,i={}){await this.loadMarkets();let s=await this.publicGetOrderBookPair(this.extend({pair:this.marketId(t)},i)),a=1e3*parseInt(s.timestamp);return this.parseOrderBook(s,a)}async fetchTicker(t,e={}){await this.loadMarkets();let i=await this.publicGetTickerPair(this.extend({pair:this.marketId(t)},e)),s=1e3*parseInt(i.timestamp),a=this.safeFloat(i,"vwap"),r=this.safeFloat(i,"volume"),o=r*a,d=this.safeFloat(i,"last");return{symbol:t,timestamp:s,datetime:this.iso8601(s),high:this.safeFloat(i,"high"),low:this.safeFloat(i,"low"),bid:this.safeFloat(i,"bid"),bidVolume:void 0,ask:this.safeFloat(i,"ask"),askVolume:void 0,vwap:a,open:this.safeFloat(i,"open"),close:d,last:d,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:r,quoteVolume:o,info:i}}getMarketFromTrade(t){t=this.omit(t,["fee","price","datetime","tid","type","order_id","side"]);let e=Object.keys(t),s=e.length;if(s>2)throw new i(this.id+" getMarketFromTrade too many keys: "+this.json(e)+" in the trade: "+this.json(t));if(2===s){let t=e[0]+e[1];if(t in this.markets_by_id)return this.markets_by_id[t];if((t=e[1]+e[0])in this.markets_by_id)return this.markets_by_id[t]}}getMarketFromTrades(t){let e=this.indexBy(t,"symbol"),i=Object.keys(e);if(1===i.length)return this.markets[i[0]]}parseTrade(t,e){let i=void 0,s=void 0;"date"in t?i=1e3*parseInt(t.date):"datetime"in t&&(i=this.parse8601(t.datetime));let a=this.safeString(t,"side"),r=this.safeString(t,"order_id");void 0===r&&void 0===a&&(a=0===(a=this.safeInteger(t,"type"))?"buy":"sell");let o=this.safeFloat(t,"price"),d=this.safeFloat(t,"amount"),n=this.safeString(t,"tid");if(n=this.safeString(t,"id",n),void 0===e){let i=Object.keys(t);for(let t=0;t<i.length;t++)if(i[t].indexOf("_")>=0){let s=i[t].replace("_","");s in this.markets_by_id&&(e=this.markets_by_id[s])}void 0===e&&(e=this.getMarketFromTrade(t))}let h=this.safeFloat(t,"fee"),l=void 0;void 0!==e&&(o=this.safeFloat(t,e.symbolId,o),d=this.safeFloat(t,e.baseId,d),l=e.quote,s=e.symbol);let c=void 0;return void 0!==o&&void 0!==d&&(c=o*d),{id:n,info:t,timestamp:i,datetime:this.iso8601(i),symbol:s,order:r,type:void 0,side:a,price:o,amount:d,cost:c,fee:{cost:h,currency:l}}}async fetchTrades(t,e,i,s={}){await this.loadMarkets();let a=this.market(t),r=await this.publicGetTransactionsPair(this.extend({pair:a.id,time:"hour"},s));return this.parseTrades(r,a,e,i)}async fetchBalance(t={}){await this.loadMarkets();let e=await this.privatePostBalance(),i={info:e},s=Object.keys(this.currencies);for(let t=0;t<s.length;t++){let a=s[t],r=a.toLowerCase(),o=r+"_balance",d=r+"_available",n=r+"_reserved",h=this.account();d in e&&(h.free=parseFloat(e[d])),n in e&&(h.used=parseFloat(e[n])),o in e&&(h.total=parseFloat(e[o])),i[a]=h}return this.parseBalance(i)}async createOrder(t,e,i,s,a,r={}){await this.loadMarkets();let o="privatePost"+this.capitalize(i),d={pair:this.marketId(t),amount:this.amountToPrecision(t,s)};"market"===e?o+="Market":d.price=this.priceToPrecision(t,a),o+="Pair";let n=await this[o](this.extend(d,r));return{info:n,id:n.id}}async cancelOrder(t,e,i={}){return await this.loadMarkets(),await this.privatePostCancelOrder({id:t})}parseOrderStatus(t){return"Queue"===t.status||"Open"===t.status?"open":"Finished"===t.status?"closed":t.status}async fetchOrderStatus(t,e,i={}){await this.loadMarkets();let s=await this.privatePostOrderStatus(this.extend({id:t},i));return this.parseOrderStatus(s)}async fetchOrder(t,e,i={}){await this.loadMarkets();let s=void 0;void 0!==e&&(s=this.market(e));let a=await this.privatePostOrderStatus(this.extend({id:t},i));return this.parseOrder(a,s)}async fetchMyTrades(t,e,i,s={}){await this.loadMarkets();let a={},r="privatePostUserTransactions",o=void 0;void 0!==t&&(o=this.market(t),a.pair=o.id,r+="Pair"),void 0!==i&&(a.limit=i);let d=await this[r](this.extend(a,s));return this.parseTrades(d,o,e,i)}parseOrder(t,e){let i=this.safeString(t,"id"),s=void 0,a=void 0,r=this.safeString(t,"type");void 0!==r&&(r="1"===r?"sell":"buy");let o=this.safeString(t,"datetime");void 0!==o&&(s=this.parse8601(o),a=this.iso8601(s));let d=void 0;if(void 0===e&&"currency_pair"in t){let i=t.currency_pair;i in this.markets_by_id&&(e=this.markets_by_id[i])}let n=this.safeFloat(t,"amount"),h=0,l=[],c=this.safeValue(t,"transactions"),p=void 0,u=void 0;if(void 0!==c&&Array.isArray(c))for(let t=0;t<c.length;t++){let s=this.parseTrade(this.extend({order_id:i,side:r},c[t]),e);h+=s.amount,void 0===p&&(p=0),p+=s.fee.cost,void 0===u&&(u=0),u+=s.cost,l.push(s)}let m=this.safeString(t,"status");"In Queue"===m||"Open"===m?m="open":"Finished"===m&&(m="closed",void 0===n&&(n=h));let f=void 0;void 0!==n&&(f=n-h);let w=this.safeFloat(t,"price");void 0===e&&(e=this.getMarketFromTrades(l));let v=void 0;return void 0!==e&&(d=e.symbol,v=e.quote),void 0===u?void 0!==w&&(u=w*h):void 0===w&&h>0&&(w=u/h),{id:i,datetime:a,timestamp:s,lastTradeTimestamp:void 0,status:m,symbol:d,type:void 0,side:r,price:w,cost:u,amount:n,filled:h,remaining:f,trades:l,fee:{cost:p,currency:v},info:t}}async fetchOpenOrders(t,e,i,s={}){let a=void 0;await this.loadMarkets(),void 0!==t&&(a=this.market(t));let r=await this.privatePostOpenOrdersAll();return this.parseOrders(r,a,e,i)}getCurrencyName(t){return"BTC"===t?"bitcoin":t.toLowerCase()}isFiat(t){return"USD"===t||"EUR"===t}async fetchDepositAddress(t,e={}){if(this.isFiat(t))throw new s(this.id+" fiat fetchDepositAddress() for "+t+" is not implemented yet");let i=this.getCurrencyName(t),a="BTC"===t,r=a?"v1":"private";r+="Post"+this.capitalize(i),r+=a?"Deposit":"",r+="Address";let o=await this[r](e),d=a?o:this.safeString(o,"address"),n=a?void 0:this.safeString(o,"destination_tag");return this.checkAddress(d),{currency:t,status:"ok",address:d,tag:n,info:o}}async withdraw(t,e,a,r,o={}){if(this.checkAddress(a),this.isFiat(t))throw new s(this.id+" fiat withdraw() for "+t+" is not implemented yet");let d=this.getCurrencyName(t),n={amount:e,address:a},h="BTC"===t?"v1":"private";h+="Post"+this.capitalize(d)+"Withdrawal";let l=o;if("XRP"===t){if(void 0===r)throw new i(this.id+" withdraw() requires a destination_tag param for "+t);n.destination_tag=r,l=this.omit(o,"destination_tag")}let c=await this[h](this.extend(n,l));return{info:c,id:c.id}}sign(t,e="public",i="GET",s={},a,r){let o=this.urls.api+"/";"v1"!==e&&(o+=this.version+"/"),o+=this.implodeParams(t,s);let d=this.omit(s,this.extractParams(t));if("public"===e)Object.keys(d).length&&(o+="?"+this.urlencode(d));else{this.checkRequiredCredentials();let t=this.nonce().toString(),e=t+this.uid+this.apiKey,i=this.encode(this.hmac(this.encode(e),this.encode(this.secret)));d=this.extend({key:this.apiKey,signature:i.toUpperCase(),nonce:t},d),r=this.urlencode(d),a={"Content-Type":"application/x-www-form-urlencoded"}}return{url:o,method:i,body:r,headers:a}}handleErrors(t,s,a,r,o,d){if("string"==typeof d&&!(d.length<2||"{"!==d[0]&&"["!==d[0])){let t=JSON.parse(d);if("error"===this.safeString(t,"status")){let s=this.safeString(t,"code");if(void 0!==s&&"API0005"===s)throw new e(this.id+" invalid signature, use the uid for the main account if you have subaccounts");throw new i(this.id+" "+this.json(t))}}}};
//# sourceMappingURL=bitstamp.js.map
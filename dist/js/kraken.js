"use strict";const e=require("./base/Exchange"),{ExchangeNotAvailable:t,ExchangeError:s,OrderNotFound:i,DDoSProtection:r,InvalidNonce:a,InsufficientFunds:o,CancelPending:n,InvalidOrder:d,InvalidAddress:h}=require("./base/errors");module.exports=class extends e{describe(){return this.deepExtend(super.describe(),{id:"kraken",name:"Kraken",countries:"US",version:"0",rateLimit:3e3,has:{createDepositAddress:!0,fetchDepositAddress:!0,fetchTradingFees:!0,CORS:!1,fetchCurrencies:!0,fetchTickers:!0,fetchOHLCV:!0,fetchOrder:!0,fetchOpenOrders:!0,fetchClosedOrders:!0,fetchMyTrades:!0,withdraw:!0},marketsByAltname:{},timeframes:{"1m":"1","5m":"5","15m":"15","30m":"30","1h":"60","4h":"240","1d":"1440","1w":"10080","2w":"21600"},urls:{logo:"https://user-images.githubusercontent.com/1294454/27766599-22709304-5ede-11e7-9de1-9f33732e1509.jpg",api:{public:"https://api.kraken.com",private:"https://api.kraken.com",zendesk:"https://support.kraken.com/hc/en-us/articles"},www:"https://www.kraken.com",doc:["https://www.kraken.com/en-us/help/api","https://github.com/nothingisdead/npm-kraken-api"],fees:"https://www.kraken.com/en-us/help/fees"},fees:{trading:{tierBased:!0,percentage:!0,taker:.0026,maker:.0016,tiers:{taker:[[0,.0026],[5e4,.0024],[1e5,.0022],[25e4,.002],[5e5,.0018],[1e6,.0016],[25e5,.0014],[5e6,.0012],[1e7,1e-4]],maker:[[0,.0016],[5e4,.0014],[1e5,.0012],[25e4,.001],[5e5,8e-4],[1e6,6e-4],[25e5,4e-4],[5e6,2e-4],[1e7,0]]}},funding:{tierBased:!1,percentage:!1,withdraw:{BTC:.001,ETH:.005,XRP:.02,XLM:2e-5,LTC:.02,DOGE:2,ZEC:1e-4,ICN:.02,REP:.01,ETC:.005,MLN:.003,XMR:.05,DASH:.005,GNO:.01,EOS:.5,BCH:.001,USD:5,EUR:5,CAD:10,JPY:300},deposit:{BTC:0,ETH:0,XRP:0,XLM:0,LTC:0,DOGE:0,ZEC:0,ICN:0,REP:0,ETC:0,MLN:0,XMR:0,DASH:0,GNO:0,EOS:0,BCH:0,USD:5,EUR:0,CAD:5,JPY:0}}},api:{zendesk:{get:["205893708-What-is-the-minimum-order-size-","201396777-What-are-the-deposit-fees-","201893608-What-are-the-withdrawal-fees-"]},public:{get:["Assets","AssetPairs","Depth","OHLC","Spread","Ticker","Time","Trades"]},private:{post:["AddOrder","Balance","CancelOrder","ClosedOrders","DepositAddresses","DepositMethods","DepositStatus","Ledgers","OpenOrders","OpenPositions","QueryLedgers","QueryOrders","QueryTrades","TradeBalance","TradesHistory","TradeVolume","Withdraw","WithdrawCancel","WithdrawInfo","WithdrawStatus"]}},options:{cacheDepositMethodsOnFetchDepositAddress:!0,depositMethods:{}},exceptions:{"EFunding:Unknown withdraw key":s,"EFunding:Invalid amount":o,"EService:Unavailable":t,"EDatabase:Internal error":t,"EService:Busy":t,"EAPI:Rate limit exceeded":r,"EQuery:Unknown asset":s,"EGeneral:Internal error":t}})}costToPrecision(e,t){return this.truncate(parseFloat(t),this.markets[e].precision.price)}feeToPrecision(e,t){return this.truncate(parseFloat(t),this.markets[e].precision.amount)}async fetchMinOrderSizes(){let e=void 0;try{this.parseJsonResponse=!1,e=await this.zendeskGet205893708WhatIsTheMinimumOrderSize(),this.parseJsonResponse=!0}catch(e){throw this.parseJsonResponse=!0,e}let t=e.split("ul>")[1].split("</li"),s={};for(let e=0;e<t.length;e++){let i=t[e].split("): ");if(i.length>1){let e=parseFloat(i[1]);s[(i=i[0].split("("))[1]]=e}}return s}async fetchMarkets(){let e=await this.publicGetAssetPairs(),t=await this.fetchMinOrderSizes(),s=Object.keys(e.result),i=[];for(let r=0;r<s.length;r++){let a=s[r],o=e.result[a],n=o.base,d=o.quote,h=n,l=d;"X"!==h[0]&&"Z"!==h[0]||(h=h.slice(1)),"X"!==l[0]&&"Z"!==l[0]||(l=l.slice(1)),h=this.commonCurrencyCode(h),l=this.commonCurrencyCode(l);let c=a.indexOf(".d")>=0,p=c?o.altname:h+"/"+l,m=void 0;"fees_maker"in o&&(m=parseFloat(o.fees_maker[0][1])/100);let u={amount:o.lot_decimals,price:o.pair_decimals},f=Math.pow(10,-u.amount);h in t&&(f=t[h]),i.push({id:a,symbol:p,base:h,quote:l,baseId:n,quoteId:d,darkpool:c,info:o,altname:o.altname,maker:m,taker:parseFloat(o.fees[0][1])/100,active:!0,precision:u,limits:{amount:{min:f,max:Math.pow(10,u.amount)},price:{min:Math.pow(10,-u.price),max:void 0},cost:{min:0,max:void 0}}})}return i=this.appendInactiveMarkets(i),this.marketsByAltname=this.indexBy(i,"altname"),i}appendInactiveMarkets(e=[]){let t={amount:8,price:8},s={min:0,max:void 0},i={min:Math.pow(10,-t.price),max:void 0},r={darkpool:!1,info:void 0,maker:void 0,taker:void 0,active:!1,precision:t,limits:{amount:{min:Math.pow(10,-t.amount),max:Math.pow(10,t.amount)},price:i,cost:s}},a=[];for(let t=0;t<a.length;t++)e.push(this.extend(r,a[t]));return e}async fetchCurrencies(e={}){let t=(await this.publicGetAssets(e)).result,s=Object.keys(t),i={};for(let e=0;e<s.length;e++){let r=s[e],a=t[r],o=this.commonCurrencyCode(a.altname),n=a.decimals;i[o]={id:r,code:o,info:a,name:o,active:!0,status:"ok",fee:void 0,precision:n,limits:{amount:{min:Math.pow(10,-n),max:Math.pow(10,n)},price:{min:Math.pow(10,-n),max:Math.pow(10,n)},cost:{min:void 0,max:void 0},withdraw:{min:void 0,max:Math.pow(10,n)}}}}return i}async fetchTradingFees(e={}){await this.loadMarkets(),this.checkRequiredCredentials();let t=await this.privatePostTradeVolume(e),s=this.safeFloat(t.result,"volume"),i=this.fees.trading.tiers,r=i.taker[1],a=i.maker[1];for(let e=0;e<i.taker.length;e++)s>=i.taker[e][0]&&(r=i.taker[e][1]);for(let e=0;e<i.maker.length;e++)s>=i.maker[e][0]&&(a=i.maker[e][1]);return{info:t,maker:a,taker:r}}async fetchOrderBook(e,t,i={}){await this.loadMarkets();let r=this.market(e);if(r.darkpool)throw new s(this.id+" does not provide an order book for darkpool symbol "+e);let a={pair:r.id};void 0!==t&&(a.count=t);let o=(await this.publicGetDepth(this.extend(a,i))).result[r.id];return this.parseOrderBook(o)}parseTicker(e,t){let s=this.milliseconds(),i=void 0;t&&(i=t.symbol);let r=parseFloat(e.v[1]),a=parseFloat(e.p[1]),o=r*a,n=parseFloat(e.c[0]);return{symbol:i,timestamp:s,datetime:this.iso8601(s),high:parseFloat(e.h[1]),low:parseFloat(e.l[1]),bid:parseFloat(e.b[0]),bidVolume:void 0,ask:parseFloat(e.a[0]),askVolume:void 0,vwap:a,open:this.safeFloat(e,"o"),close:n,last:n,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:r,quoteVolume:o,info:e}}async fetchTickers(e,t={}){await this.loadMarkets();let s=[];for(let e=0;e<this.symbols.length;e++){let t=this.symbols[e],i=this.markets[t];i.active&&(i.darkpool||s.push(i.id))}let i=s.join(","),r=(await this.publicGetTicker(this.extend({pair:i},t))).result,a=Object.keys(r),o={};for(let e=0;e<a.length;e++){let t=a[e],s=this.markets_by_id[t],i=s.symbol,n=r[t];o[i]=this.parseTicker(n,s)}return o}async fetchTicker(e,t={}){if(await this.loadMarkets(),e.indexOf(".d")>=0)throw new s(this.id+" does not provide a ticker for darkpool symbol "+e);let i=this.market(e),r=(await this.publicGetTicker(this.extend({pair:i.id},t))).result[i.id];return this.parseTicker(r,i)}parseOHLCV(e,t,s="1m",i,r){return[1e3*e[0],parseFloat(e[1]),parseFloat(e[2]),parseFloat(e[3]),parseFloat(e[4]),parseFloat(e[6])]}async fetchOHLCV(e,t="1m",s,i,r={}){await this.loadMarkets();let a=this.market(e),o={pair:a.id,interval:this.timeframes[t]};void 0!==s&&(o.since=parseInt(s/1e3));let n=(await this.publicGetOHLC(this.extend(o,r))).result[a.id];return this.parseOHLCVs(n,a,t,s,i)}parseTrade(e,t){let s=void 0,i=void 0,r=void 0,a=void 0,o=void 0,n=void 0,d=void 0,h=void 0;if(t||(t=this.findMarketByAltnameOrId(e.pair)),"ordertxid"in e){if(d=e.ordertxid,n=e.id,s=parseInt(1e3*e.time),i=e.type,r=e.ordertype,a=this.safeFloat(e,"price"),o=this.safeFloat(e,"vol"),"fee"in e){let s=void 0;t&&(s=t.quote),h={cost:this.safeFloat(e,"fee"),currency:s}}}else{s=parseInt(1e3*e[2]),i="s"===e[3]?"sell":"buy",r="l"===e[4]?"limit":"market",a=parseFloat(e[0]),o=parseFloat(e[1]),e.length>6&&(n=e[6])}let l=t?t.symbol:void 0;return{id:n,order:d,info:e,timestamp:s,datetime:this.iso8601(s),symbol:l,type:r,side:i,price:a,amount:o,cost:a*o,fee:h}}async fetchTrades(e,t,s,i={}){await this.loadMarkets();let r=this.market(e),a=r.id,o=(await this.publicGetTrades(this.extend({pair:a},i))).result,n=o[a],d=n.length;if(d<=0)return[];let h=n[d-1],l=this.safeString(o,"last");return h.push(l),this.parseTrades(n,r,t,s)}async fetchBalance(e={}){await this.loadMarkets();let s=await this.privatePostBalance(),i=this.safeValue(s,"result");if(void 0===i)throw new t(this.id+" fetchBalance failed due to a malformed response "+this.json(s));let r={info:i},a=Object.keys(i);for(let e=0;e<a.length;e++){let t=a[e],s=t;s in this.currencies_by_id?s=this.currencies_by_id[s].code:("X"===s[0]?s=s.slice(1):"Z"===s[0]&&(s=s.slice(1)),s=this.commonCurrencyCode(s));let o=parseFloat(i[t]),n={free:o,used:0,total:o};r[s]=n}return this.parseBalance(r)}async createOrder(e,t,s,i,r,a={}){await this.loadMarkets();let o={pair:this.market(e).id,type:s,ordertype:t,volume:this.amountToPrecision(e,i)};("limit"===t||!("market"===t)&&void 0!==r)&&(o.price=this.priceToPrecision(e,r));let n=await this.privatePostAddOrder(this.extend(o,a)),d=this.safeValue(n.result,"txid");if(void 0!==d&&Array.isArray(d)){d=d.length>1?d:d[0]}return{info:n,id:d}}findMarketByAltnameOrId(e){return e in this.marketsByAltname?this.marketsByAltname[e]:e in this.markets_by_id?this.markets_by_id[e]:void 0}parseOrder(e,t){let s=e.descr,i=s.type,r=s.ordertype,a=void 0;void 0===t&&(t=this.findMarketByAltnameOrId(s.pair));let o=parseInt(1e3*e.opentm),n=this.safeFloat(e,"vol"),d=this.safeFloat(e,"vol_exec"),h=n-d,l=void 0,c=this.safeFloat(e,"cost"),p=this.safeFloat(s,"price");if(p||(p=this.safeFloat(e,"price")),void 0!==t&&(a=t.symbol,"fee"in e)){let s=e.oflags;l={cost:this.safeFloat(e,"fee"),rate:void 0},s.indexOf("fciq")>=0?l.currency=t.quote:s.indexOf("fcib")>=0&&(l.currency=t.base)}return{id:e.id,info:e,timestamp:o,datetime:this.iso8601(o),lastTradeTimestamp:void 0,status:e.status,symbol:a,type:r,side:i,price:p,cost:c,amount:n,filled:d,remaining:h,fee:l}}parseOrders(e,t,s,i){let r=[],a=Object.keys(e);for(let s=0;s<a.length;s++){let i=a[s],o=this.extend({id:i},e[i]);r.push(this.parseOrder(o,t))}return this.filterBySinceLimit(r,s,i)}async fetchOrder(e,t,s={}){await this.loadMarkets();let i=await this.privatePostQueryOrders(this.extend({trades:!0,txid:e},s)),r=i.result,a=this.parseOrder(this.extend({id:e},r[e]));return this.extend({info:i},a)}async fetchMyTrades(e,t,s,i={}){await this.loadMarkets();let r={};void 0!==t&&(r.start=parseInt(t/1e3));let a=(await this.privatePostTradesHistory(this.extend(r,i))).result.trades,o=Object.keys(a);for(let e=0;e<o.length;e++)a[o[e]].id=o[e];let n=this.parseTrades(a,void 0,t,s);return void 0===e?n:this.filterBySymbol(n,e)}async cancelOrder(e,t,s={}){await this.loadMarkets();let r=void 0;try{r=await this.privatePostCancelOrder(this.extend({txid:e},s))}catch(e){if(this.last_http_response&&this.last_http_response.indexOf("EOrder:Unknown order")>=0)throw new i(this.id+" cancelOrder() error "+this.last_http_response);throw e}return r}async fetchOpenOrders(e,t,s,i={}){await this.loadMarkets();let r={};void 0!==t&&(r.start=parseInt(t/1e3));let a=await this.privatePostOpenOrders(this.extend(r,i)),o=this.parseOrders(a.result.open,void 0,t,s);return void 0===e?o:this.filterBySymbol(o,e)}async fetchClosedOrders(e,t,s,i={}){await this.loadMarkets();let r={};void 0!==t&&(r.start=parseInt(t/1e3));let a=await this.privatePostClosedOrders(this.extend(r,i)),o=this.parseOrders(a.result.closed,void 0,t,s);return void 0===e?o:this.filterBySymbol(o,e)}async fetchDepositMethods(e,t={}){await this.loadMarkets();let s=this.currency(e);return(await this.privatePostDepositMethods(this.extend({asset:s.id},t))).result}async createDepositAddress(e,t={}){let s=await this.fetchDepositAddress(e,this.extend({new:"true"},t)),i=this.safeString(s,"address");return this.checkAddress(i),{currency:e,address:i,status:"ok",info:s}}async fetchDepositAddress(e,t={}){await this.loadMarkets();let i=this.currency(e),r=this.safeString(t,"method");if(void 0===r){if(!this.options.cacheDepositMethodsOnFetchDepositAddress)throw new s(this.id+' fetchDepositAddress() requires an extra `method` parameter. Use fetchDepositMethods ("'+e+'") to get a list of available deposit methods or enable the exchange property .options["cacheDepositMethodsOnFetchDepositAddress"] = true');e in this.options.depositMethods||(this.options.depositMethods[e]=await this.fetchDepositMethods(e)),r=this.options.depositMethods[e][0].method}let a={asset:i.id,method:r},o=await this.privatePostDepositAddresses(this.extend(a,t)),n=o.result;if(n.length<1)throw new h(this.id+" privatePostDepositAddresses() returned no addresses");let d=this.safeString(n[0],"address");return this.checkAddress(d),{currency:e,address:d,status:"ok",info:o}}async withdraw(e,t,i,r,a={}){if(this.checkAddress(i),"key"in a){await this.loadMarkets();let s=await this.privatePostWithdraw(this.extend({asset:e,amount:t},a));return{info:s,id:s.result}}throw new s(this.id+" withdraw requires a 'key' parameter (withdrawal key name, as set up on your account)")}sign(e,t="public",s="GET",i={},r,a){let o="/"+this.version+"/"+t+"/"+e;if("public"===t)Object.keys(i).length&&(o+="?"+this.urlencode(i));else if("private"===t){this.checkRequiredCredentials();let e=this.nonce().toString();a=this.urlencode(this.extend({nonce:e},i));let t=this.encode(e+a),s=this.hash(t,"sha256","binary"),n=this.stringToBinary(this.encode(o)),d=this.binaryConcat(n,s),h=this.base64ToBinary(this.secret),l=this.hmac(d,h,"sha512","base64");r={"API-Key":this.apiKey,"API-Sign":this.decode(l),"Content-Type":"application/x-www-form-urlencoded"}}else o="/"+e;return{url:o=this.urls.api[t]+o,method:s,body:a,headers:r}}nonce(){return this.milliseconds()}handleErrors(e,t,i,r,h,l){if(l.indexOf("Invalid order")>=0)throw new d(this.id+" "+l);if(l.indexOf("Invalid nonce")>=0)throw new a(this.id+" "+l);if(l.indexOf("Insufficient funds")>=0)throw new o(this.id+" "+l);if(l.indexOf("Cancel pending")>=0)throw new n(this.id+" "+l);if(l.indexOf("Invalid arguments:volume")>=0)throw new d(this.id+" "+l);if("{"===l[0]){let e=JSON.parse(l);if("string"!=typeof e&&"error"in e){if(e.error.length){let t=this.id+" "+this.json(e);for(let s=0;s<e.error.length;s++)if(e.error[s]in this.exceptions)throw new this.exceptions[e.error[s]](t);throw new s(t)}}}}};
//# sourceMappingURL=kraken.js.map
"use strict";const e=require("./base/Exchange"),{ExchangeError:t,AuthenticationError:s,DDoSProtection:i}=require("./base/errors");module.exports=class extends e{describe(){return this.deepExtend(super.describe(),{id:"coinnest",name:"coinnest",countries:"KR",rateLimit:1e3,has:{fetchOpenOrders:!0},urls:{logo:"https://user-images.githubusercontent.com/1294454/38065728-7289ff5c-330d-11e8-9cc1-cf0cbcb606bc.jpg",api:{public:"https://api.coinnest.co.kr/api",private:"https://api.coinnest.co.kr/api",web:"https://www.coinnest.co.kr"},www:"https://www.coinnest.co.kr",doc:"https://www.coinnest.co.kr/doc/intro.html",fees:["https://coinnesthelp.zendesk.com/hc/ko/articles/115002110252-%EA%B1%B0%EB%9E%98-%EC%88%98%EC%88%98%EB%A3%8C%EB%8A%94-%EC%96%BC%EB%A7%88%EC%9D%B8%EA%B0%80%EC%9A%94-","https://coinnesthelp.zendesk.com/hc/ko/articles/115002110272-%EB%B9%84%ED%8A%B8%EC%BD%94%EC%9D%B8-%EC%88%98%EC%88%98%EB%A3%8C%EB%A5%BC-%EC%84%A0%ED%83%9D%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0%EA%B0%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94-"]},api:{web:{get:["coin/allcoin"]},public:{get:["pub/ticker","pub/depth","pub/trades"]},private:{post:["account/balance","trade/add","trade/cancel","trade/fetchtrust","trade/trust"]}},fees:{trading:{maker:.001,taker:.001},funding:{withdraw:{BTC:"0.002"}}},precision:{amount:8,price:8}})}async fetchMarkets(){let e="KRW".toLowerCase(),t=["btc","bch","btg","bcd","ubtc","btn","kst","ltc","act","eth","etc","ada","qtum","xlm","neo","gas","rpx","hsr","knc","tsl","tron","omg","wtc","mco","storm","gto","pxs","chat","ink","oc","hlc","ent","qbt","spc","put"],s=[];for(let i=0;i<t.length;i++){let a=t[i],r=a+"/"+e,o=this.commonCurrencyCode(a.toUpperCase()),n=o+"/KRW";s.push({id:r,symbol:n,base:o,quote:"KRW",baseId:a,quoteId:e,active:!0,info:void 0})}return s}parseTicker(e,t){let s=1e3*e.time,i=t.symbol,a=this.safeFloat(e,"last");return{symbol:i,timestamp:s,datetime:this.iso8601(s),high:this.safeFloat(e,"high"),low:this.safeFloat(e,"low"),bid:this.safeFloat(e,"buy"),bidVolume:void 0,ask:this.safeFloat(e,"sell"),askVolume:void 0,vwap:void 0,open:void 0,close:a,last:a,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeFloat(e,"vol"),quoteVolume:void 0,info:e}}async fetchTicker(e,t={}){await this.loadMarkets();let s=this.market(e),i=await this.publicGetPubTicker(this.extend({coin:s.baseId},t));return this.parseTicker(i,s)}async fetchOrderBook(e,t,s={}){await this.loadMarkets();let i=this.market(e),a=await this.publicGetPubDepth(this.extend({coin:i.baseId},s));return this.parseOrderBook(a)}parseTrade(e,t){let s=1e3*parseInt(e.date),i=this.safeFloat(e,"price"),a=this.safeFloat(e,"amount"),r=t.symbol,o=this.priceToPrecision(r,a*i);return{timestamp:s,datetime:this.iso8601(s),symbol:r,id:this.safeString(e,"tid"),order:void 0,type:"limit",side:e.type,price:i,amount:a,cost:parseFloat(o),fee:void 0,info:e}}async fetchTrades(e,t,s,i={}){await this.loadMarkets();let a=this.market(e),r=await this.publicGetPubTrades(this.extend({coin:a.baseId},i));return this.parseTrades(r,a,t,s)}async fetchBalance(e={}){await this.loadMarkets();let t=await this.privatePostAccountBalance(e),s={info:t},i=Object.keys(t);for(let e=0;e<i.length;e++){let a=i[e],r=a.split("_");if(2!==r.length)continue;let o=r[1];if("reserved"!==o&&"balance"!==o)continue;let n=r[0].toUpperCase();(n=this.commonCurrencyCode(n))in s||(s[n]={free:0,used:0,total:0}),o="reserved"===o?"used":"free",s[n][o]=parseFloat(t[a]),("used"===o?"free":"used")in s[n]&&(s[n].total=this.sum(s[n].free,s[n].used))}return this.parseBalance(s)}parseOrder(e,t){let s=t.symbol,i=1e3*parseInt(e.time),a=parseInt(e.status);a=4===a?"closed":3===a?"canceled":"open";let r=this.safeFloat(e,"amount_total"),o=this.safeFloat(e,"amount_over"),n=this.safeValue(e,"deals");return n=n?this.safeFloat(n,"sum_amount"):r-o,{id:this.safeString(e,"id"),datetime:this.iso8601(i),timestamp:i,lastTradeTimestamp:void 0,status:a,symbol:s,type:"limit",side:e.type,price:this.safeFloat(e,"price"),cost:void 0,amount:r,filled:n,remaining:o,trades:void 0,fee:void 0,info:this.safeValue(e,"info",e)}}async createOrder(e,t,s,i,a,r={}){await this.loadMarkets();let o=this.market(e),n=await this.privatePostTradeAdd(this.extend({coin:o.baseId,type:s,number:i,price:a},r)),c={id:n.id,time:this.seconds(),type:s,price:a,amount_total:i,amount_over:i,info:n},d=c.id;return this.orders[d]=this.parseOrder(c,o),c}async cancelOrder(e,t,s={}){await this.loadMarkets();let i=this.market(t);return await this.privatePostTradeCancel(this.extend({id:e,coin:i.baseId},s))}async fetchOrder(e,t,s={}){await this.loadMarkets();let i=this.market(t),a=await this.privatePostTradeFetchtrust(this.extend({id:e,coin:i.baseId},s));return this.parseOrder(a,i)}async fetchOrders(e,t,s,i={}){await this.loadMarkets();let a=this.market(e),r={coin:a.baseId};t&&(r.since=parseInt(t/1e3)),s&&(r.limit=s);let o=await this.privatePostTradeTrust(this.extend(r,i));return this.parseOrders(o,a)}async fetchOpenOrders(e,t,s,i={}){return await this.fetchOrders(e,t,s,this.extend({type:"1"},i))}sign(e,t="public",s="GET",i={},a,r){let o=this.urls.api[t]+"/"+e,n=void 0;if("public"===t)(n=this.urlencode(i)).length&&(o+="?"+n);else{this.checkRequiredCredentials(),r=this.urlencode(this.extend(i,{key:this.apiKey,nonce:this.nonce()}));let e=this.hash(this.secret);r+="&signature="+this.hmac(this.encode(r),this.encode(e)),a={"Content-type":"application/x-www-form-urlencoded"}}return{url:o,method:s,body:r,headers:a}}async request(e,a="public",r="GET",o={},n,c){let d=await this.fetch2(e,a,r,o,n,c),h=this.safeString(d,"status");if(!d||"nil"===d||h){throw new(this.safeValue({100:i,101:i,104:s,105:s,106:i},h,t))(this.safeString(d,"msg",this.json(d)))}return d}};
//# sourceMappingURL=coinnest.js.map